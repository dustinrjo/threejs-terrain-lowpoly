!function(r){function n(t){if(e[t])return e[t].exports;var i=e[t]={exports:{},id:t,loaded:!1};return r[t].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var e={};return n.m=r,n.c=e,n.p="",n(0)}([function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _interopRequireDefault = __webpack_require__(1)['default'];\n\nvar _Three = __webpack_require__(2);\n\nvar _Three2 = _interopRequireDefault(_Three);\n\n// Scenes allow you to set up what and where is to be\n// rendered by three.js. This is where you place objects,\n// lights and cameras.\nvar scene = new _Three2['default'].Scene();\n\n// Camera with perspective projection.\nvar aspectsRatio = window.innerWidth / window.innerHeight;\nvar camera = new _Three2['default'].PerspectiveCamera(75, // Field of view\naspectsRatio, // Aspect ratio\n1, // Near clipping plane\n10000 // Far clipping plane\n);\n\n// Distance camera from the center of the scene.\ncamera.position.z = 4;\n\n// Rotate\ncamera.rotation.x = 0.4;\n\n// The WebGL renderer displays your beautifully crafted\n// scenes using WebGL, if your device supports it.\nvar renderer = new _Three2['default'].WebGLRenderer({\n  antialias: true\n});\n\n//\nvar planeMaterial = new _Three2['default'].MeshPhongMaterial({\n  specular: 16484119, // Specular color of the material (light)\n  color: 16731728, // Geometry color in hexadecimal\n  emissive: 16731728, // Emissive color of the material (dark)\n  shininess: 30, // How shiny the specular highlight is\n  shading: _Three2['default'].FlatShading // NoShading, FlatShading or SmoothShading\n});\n\n// Create a geometry with N segments.\nvar planeGeometry = new _Three2['default'].PlaneGeometry(30, 60, 60, 120);\n\n// Move the vertices by random.\nplaneGeometry.vertices.map(function (vertex) {\n  vertex.x += -0.5 + Math.random() / 10;\n  vertex.y += -0.5 + Math.random() / 10;\n  vertex.z = -0.5 + Math.random() / 5;\n  return vertex;\n});\n\n// Update geometry.\nplaneGeometry.computeFaceNormals();\n\n// Create plane\nvar plane = new _Three2['default'].Mesh(planeGeometry, planeMaterial);\n\n// Create a wireframe\nvar wireframeMaterial = new _Three2['default'].MeshBasicMaterial({\n  color: 16731728,\n  wireframe: true\n});\nvar wireframe = new _Three2['default'].Mesh(planeGeometry, wireframeMaterial);\nscene.add(wireframe);\nscene.add(plane);\n\n// Creates a light that shines from a specific direction\n// not from a specific position. This light will behave\n// as though it is infinitely far away and the rays produced\n// from it are all parallel. The best analogy would be a\n// light source that acts like the sun: the sun is so far\n// away that all sunlight hitting objects comes from the\n// same angle.\nvar light = new _Three2['default'].DirectionalLight(16777215, 0.3);\nlight.position.set(1, 1, 1);\nscene.add(light);\n\n// Resizes the output canvas to (width, height), and also\n// sets the viewport to fit that size, starting in (0, 0).\nrenderer.setSize(window.innerWidth, window.innerHeight);\n\n// Add the renderer element to the DOM.\ndocument.body.appendChild(renderer.domElement);\n\nvar mouseX = 0;\nvar mouseY = 0;\n\n// Move the light according to the mouse position.\nfunction animate() {\n  requestAnimationFrame(animate);\n  light.position.x = -1 + mouseX / window.innerWidth * 2;\n  light.position.y = 1 - mouseY / window.innerHeight * 2;\n  renderer.render(scene, camera);\n}\n\nanimate();\n\nfunction onMouseMove(event) {\n  mouseX = event.x;\n  mouseY = event.y;\n}\n\n// Update camera aspect and renderer size on window resize.\nfunction onWindowResize() {\n  camera.aspect = window.innerWidth / window.innerHeight;\n  camera.updateProjectionMatrix();\n  renderer.setSize(window.innerWidth, window.innerHeight);\n}\nwindow.addEventListener('resize', onWindowResize, false);\nwindow.addEventListener('mousemove', onMouseMove, false);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./sourcecode/index.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./sourcecode/index.js?")},function(module,exports,__webpack_require__){eval('"use strict";\n\nexports["default"] = function (obj) {\n  return obj && obj.__esModule ? obj : {\n    "default": obj\n  };\n};\n\nexports.__esModule = true;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-runtime/helpers/interop-require-default.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/babel-runtime/helpers/interop-require-default.js?')},function(module,exports,__webpack_require__){eval("var self = self || {};// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '70' };\r\n\r\n// browserify support\r\n\r\nif ( true ) {\r\n\r\n	module.exports = THREE;\r\n\r\n}\r\n\r\n// polyfills\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n	Math.sign = function ( x ) {\r\n\r\n		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;\r\n\r\n	};\r\n\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\nTHREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\r\n\r\n// GL STATE CONSTANTS\r\n\r\nTHREE.CullFaceNone = 0;\r\nTHREE.CullFaceBack = 1;\r\nTHREE.CullFaceFront = 2;\r\nTHREE.CullFaceFrontBack = 3;\r\n\r\nTHREE.FrontFaceDirectionCW = 0;\r\nTHREE.FrontFaceDirectionCCW = 1;\r\n\r\n// SHADOWING TYPES\r\n\r\nTHREE.BasicShadowMap = 0;\r\nTHREE.PCFShadowMap = 1;\r\nTHREE.PCFSoftShadowMap = 2;\r\n\r\n// MATERIAL CONSTANTS\r\n\r\n// side\r\n\r\nTHREE.FrontSide = 0;\r\nTHREE.BackSide = 1;\r\nTHREE.DoubleSide = 2;\r\n\r\n// shading\r\n\r\nTHREE.NoShading = 0;\r\nTHREE.FlatShading = 1;\r\nTHREE.SmoothShading = 2;\r\n\r\n// colors\r\n\r\nTHREE.NoColors = 0;\r\nTHREE.FaceColors = 1;\r\nTHREE.VertexColors = 2;\r\n\r\n// blending modes\r\n\r\nTHREE.NoBlending = 0;\r\nTHREE.NormalBlending = 1;\r\nTHREE.AdditiveBlending = 2;\r\nTHREE.SubtractiveBlending = 3;\r\nTHREE.MultiplyBlending = 4;\r\nTHREE.CustomBlending = 5;\r\n\r\n// custom blending equations\r\n// (numbers start from 100 not to clash with other\r\n//  mappings to OpenGL constants defined in Texture.js)\r\n\r\nTHREE.AddEquation = 100;\r\nTHREE.SubtractEquation = 101;\r\nTHREE.ReverseSubtractEquation = 102;\r\nTHREE.MinEquation = 103;\r\nTHREE.MaxEquation = 104;\r\n\r\n// custom blending destination factors\r\n\r\nTHREE.ZeroFactor = 200;\r\nTHREE.OneFactor = 201;\r\nTHREE.SrcColorFactor = 202;\r\nTHREE.OneMinusSrcColorFactor = 203;\r\nTHREE.SrcAlphaFactor = 204;\r\nTHREE.OneMinusSrcAlphaFactor = 205;\r\nTHREE.DstAlphaFactor = 206;\r\nTHREE.OneMinusDstAlphaFactor = 207;\r\n\r\n// custom blending source factors\r\n\r\n//THREE.ZeroFactor = 200;\r\n//THREE.OneFactor = 201;\r\n//THREE.SrcAlphaFactor = 204;\r\n//THREE.OneMinusSrcAlphaFactor = 205;\r\n//THREE.DstAlphaFactor = 206;\r\n//THREE.OneMinusDstAlphaFactor = 207;\r\nTHREE.DstColorFactor = 208;\r\nTHREE.OneMinusDstColorFactor = 209;\r\nTHREE.SrcAlphaSaturateFactor = 210;\r\n\r\n\r\n// TEXTURE CONSTANTS\r\n\r\nTHREE.MultiplyOperation = 0;\r\nTHREE.MixOperation = 1;\r\nTHREE.AddOperation = 2;\r\n\r\n// Mapping modes\r\n\r\nTHREE.UVMapping = 300;\r\n\r\nTHREE.CubeReflectionMapping = 301;\r\nTHREE.CubeRefractionMapping = 302;\r\n\r\nTHREE.EquirectangularReflectionMapping = 303;\r\nTHREE.EquirectangularRefractionMapping = 304;\r\n\r\nTHREE.SphericalReflectionMapping = 305;\r\n\r\n// Wrapping modes\r\n\r\nTHREE.RepeatWrapping = 1000;\r\nTHREE.ClampToEdgeWrapping = 1001;\r\nTHREE.MirroredRepeatWrapping = 1002;\r\n\r\n// Filters\r\n\r\nTHREE.NearestFilter = 1003;\r\nTHREE.NearestMipMapNearestFilter = 1004;\r\nTHREE.NearestMipMapLinearFilter = 1005;\r\nTHREE.LinearFilter = 1006;\r\nTHREE.LinearMipMapNearestFilter = 1007;\r\nTHREE.LinearMipMapLinearFilter = 1008;\r\n\r\n// Data types\r\n\r\nTHREE.UnsignedByteType = 1009;\r\nTHREE.ByteType = 1010;\r\nTHREE.ShortType = 1011;\r\nTHREE.UnsignedShortType = 1012;\r\nTHREE.IntType = 1013;\r\nTHREE.UnsignedIntType = 1014;\r\nTHREE.FloatType = 1015;\r\n\r\n// Pixel types\r\n\r\n//THREE.UnsignedByteType = 1009;\r\nTHREE.UnsignedShort4444Type = 1016;\r\nTHREE.UnsignedShort5551Type = 1017;\r\nTHREE.UnsignedShort565Type = 1018;\r\n\r\n// Pixel formats\r\n\r\nTHREE.AlphaFormat = 1019;\r\nTHREE.RGBFormat = 1020;\r\nTHREE.RGBAFormat = 1021;\r\nTHREE.LuminanceFormat = 1022;\r\nTHREE.LuminanceAlphaFormat = 1023;\r\n// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\nTHREE.RGBEFormat = THREE.RGBAFormat; //1024;\r\n\r\n// DDS / ST3C Compressed texture formats\r\n\r\nTHREE.RGB_S3TC_DXT1_Format = 2001;\r\nTHREE.RGBA_S3TC_DXT1_Format = 2002;\r\nTHREE.RGBA_S3TC_DXT3_Format = 2003;\r\nTHREE.RGBA_S3TC_DXT5_Format = 2004;\r\n\r\n\r\n// PVRTC compressed texture formats\r\n\r\nTHREE.RGB_PVRTC_4BPPV1_Format = 2100;\r\nTHREE.RGB_PVRTC_2BPPV1_Format = 2101;\r\nTHREE.RGBA_PVRTC_4BPPV1_Format = 2102;\r\nTHREE.RGBA_PVRTC_2BPPV1_Format = 2103;\r\n\r\n\r\n// DEPRECATED\r\n\r\nTHREE.Projector = function () {\r\n\r\n	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n	this.projectVector = function ( vector, camera ) {\r\n\r\n		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n		vector.project( camera );\r\n\r\n	};\r\n\r\n	this.unprojectVector = function ( vector, camera ) {\r\n\r\n		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n		vector.unproject( camera );\r\n\r\n	};\r\n\r\n	this.pickingRay = function ( vector, camera ) {\r\n\r\n		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n	this.domElement = document.createElement( 'canvas' );\r\n	this.clear = function () {};\r\n	this.render = function () {};\r\n	this.setClearColor = function () {};\r\n	this.setSize = function () {};\r\n\r\n};\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( color ) {\r\n\r\n	if ( arguments.length === 3 ) {\r\n\r\n		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );\r\n\r\n	}\r\n\r\n	return this.set( color )\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n	constructor: THREE.Color,\r\n\r\n	r: 1, g: 1, b: 1,\r\n\r\n	set: function ( value ) {\r\n\r\n		if ( value instanceof THREE.Color ) {\r\n\r\n			this.copy( value );\r\n\r\n		} else if ( typeof value === 'number' ) {\r\n\r\n			this.setHex( value );\r\n\r\n		} else if ( typeof value === 'string' ) {\r\n\r\n			this.setStyle( value );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setHex: function ( hex ) {\r\n\r\n		hex = Math.floor( hex );\r\n\r\n		this.r = ( hex >> 16 & 255 ) / 255;\r\n		this.g = ( hex >> 8 & 255 ) / 255;\r\n		this.b = ( hex & 255 ) / 255;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setRGB: function ( r, g, b ) {\r\n\r\n		this.r = r;\r\n		this.g = g;\r\n		this.b = b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setHSL: function ( h, s, l ) {\r\n\r\n		// h,s,l ranges are in 0.0 - 1.0\r\n\r\n		if ( s === 0 ) {\r\n\r\n			this.r = this.g = this.b = l;\r\n\r\n		} else {\r\n\r\n			var hue2rgb = function ( p, q, t ) {\r\n\r\n				if ( t < 0 ) t += 1;\r\n				if ( t > 1 ) t -= 1;\r\n				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n				if ( t < 1 / 2 ) return q;\r\n				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n				return p;\r\n\r\n			};\r\n\r\n			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n			var q = ( 2 * l ) - p;\r\n\r\n			this.r = hue2rgb( q, p, h + 1 / 3 );\r\n			this.g = hue2rgb( q, p, h );\r\n			this.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setStyle: function ( style ) {\r\n\r\n		// rgb(255,0,0)\r\n\r\n		if ( /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.test( style ) ) {\r\n\r\n			var color = /^rgb\\((\\d+), ?(\\d+), ?(\\d+)\\)$/i.exec( style );\r\n\r\n			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		// rgb(100%,0%,0%)\r\n\r\n		if ( /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.test( style ) ) {\r\n\r\n			var color = /^rgb\\((\\d+)\\%, ?(\\d+)\\%, ?(\\d+)\\%\\)$/i.exec( style );\r\n\r\n			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		// #ff0000\r\n\r\n		if ( /^\\#([0-9a-f]{6})$/i.test( style ) ) {\r\n\r\n			var color = /^\\#([0-9a-f]{6})$/i.exec( style );\r\n\r\n			this.setHex( parseInt( color[ 1 ], 16 ) );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		// #f00\r\n\r\n		if ( /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {\r\n\r\n			var color = /^\\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );\r\n\r\n			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		// red\r\n\r\n		if ( /^(\\w+)$/i.test( style ) ) {\r\n\r\n			this.setHex( THREE.ColorKeywords[ style ] );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n\r\n	},\r\n\r\n	copy: function ( color ) {\r\n\r\n		this.r = color.r;\r\n		this.g = color.g;\r\n		this.b = color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyGammaToLinear: function ( color ) {\r\n\r\n		this.r = color.r * color.r;\r\n		this.g = color.g * color.g;\r\n		this.b = color.b * color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copyLinearToGamma: function ( color ) {\r\n\r\n		this.r = Math.sqrt( color.r );\r\n		this.g = Math.sqrt( color.g );\r\n		this.b = Math.sqrt( color.b );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	convertGammaToLinear: function () {\r\n\r\n		var r = this.r, g = this.g, b = this.b;\r\n\r\n		this.r = r * r;\r\n		this.g = g * g;\r\n		this.b = b * b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	convertLinearToGamma: function () {\r\n\r\n		this.r = Math.sqrt( this.r );\r\n		this.g = Math.sqrt( this.g );\r\n		this.b = Math.sqrt( this.b );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getHex: function () {\r\n\r\n		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n	},\r\n\r\n	getHexString: function () {\r\n\r\n		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n	},\r\n\r\n	getHSL: function ( optionalTarget ) {\r\n\r\n		// h,s,l ranges are in 0.0 - 1.0\r\n\r\n		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n		var r = this.r, g = this.g, b = this.b;\r\n\r\n		var max = Math.max( r, g, b );\r\n		var min = Math.min( r, g, b );\r\n\r\n		var hue, saturation;\r\n		var lightness = ( min + max ) / 2.0;\r\n\r\n		if ( min === max ) {\r\n\r\n			hue = 0;\r\n			saturation = 0;\r\n\r\n		} else {\r\n\r\n			var delta = max - min;\r\n\r\n			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n			switch ( max ) {\r\n\r\n				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n				case g: hue = ( b - r ) / delta + 2; break;\r\n				case b: hue = ( r - g ) / delta + 4; break;\r\n\r\n			}\r\n\r\n			hue /= 6;\r\n\r\n		}\r\n\r\n		hsl.h = hue;\r\n		hsl.s = saturation;\r\n		hsl.l = lightness;\r\n\r\n		return hsl;\r\n\r\n	},\r\n\r\n	getStyle: function () {\r\n\r\n		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n	},\r\n\r\n	offsetHSL: function ( h, s, l ) {\r\n\r\n		var hsl = this.getHSL();\r\n\r\n		hsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n		this.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( color ) {\r\n\r\n		this.r += color.r;\r\n		this.g += color.g;\r\n		this.b += color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addColors: function ( color1, color2 ) {\r\n\r\n		this.r = color1.r + color2.r;\r\n		this.g = color1.g + color2.g;\r\n		this.b = color1.b + color2.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.r += s;\r\n		this.g += s;\r\n		this.b += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( color ) {\r\n\r\n		this.r *= color.r;\r\n		this.g *= color.g;\r\n		this.b *= color.b;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		this.r *= s;\r\n		this.g *= s;\r\n		this.b *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( color, alpha ) {\r\n\r\n		this.r += ( color.r - this.r ) * alpha;\r\n		this.g += ( color.g - this.g ) * alpha;\r\n		this.b += ( color.b - this.b ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( c ) {\r\n\r\n		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.r = array[ 0 ];\r\n		this.g = array[ 1 ];\r\n		this.b = array[ 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		return [ this.r, this.g, this.b ];\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Color().setRGB( this.r, this.g, this.b );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n	this._x = x || 0;\r\n	this._y = y || 0;\r\n	this._z = z || 0;\r\n	this._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n	constructor: THREE.Quaternion,\r\n\r\n	_x: 0,_y: 0, _z: 0, _w: 0,\r\n\r\n	get x () {\r\n\r\n		return this._x;\r\n\r\n	},\r\n\r\n	set x ( value ) {\r\n\r\n		this._x = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get y () {\r\n\r\n		return this._y;\r\n\r\n	},\r\n\r\n	set y ( value ) {\r\n\r\n		this._y = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get z () {\r\n\r\n		return this._z;\r\n\r\n	},\r\n\r\n	set z ( value ) {\r\n\r\n		this._z = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get w () {\r\n\r\n		return this._w;\r\n\r\n	},\r\n\r\n	set w ( value ) {\r\n\r\n		this._w = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	set: function ( x, y, z, w ) {\r\n\r\n		this._x = x;\r\n		this._y = y;\r\n		this._z = z;\r\n		this._w = w;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( quaternion ) {\r\n\r\n		this._x = quaternion.x;\r\n		this._y = quaternion.y;\r\n		this._z = quaternion.z;\r\n		this._w = quaternion.w;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromEuler: function ( euler, update ) {\r\n\r\n		if ( euler instanceof THREE.Euler === false ) {\r\n\r\n			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n		}\r\n\r\n		// http://www.mathworks.com/matlabcentral/fileexchange/\r\n		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n		//	content/SpinCalc.m\r\n\r\n		var c1 = Math.cos( euler._x / 2 );\r\n		var c2 = Math.cos( euler._y / 2 );\r\n		var c3 = Math.cos( euler._z / 2 );\r\n		var s1 = Math.sin( euler._x / 2 );\r\n		var s2 = Math.sin( euler._y / 2 );\r\n		var s3 = Math.sin( euler._z / 2 );\r\n\r\n		if ( euler.order === 'XYZ' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( euler.order === 'YXZ' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		} else if ( euler.order === 'ZXY' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( euler.order === 'ZYX' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		} else if ( euler.order === 'YZX' ) {\r\n\r\n			this._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n		} else if ( euler.order === 'XZY' ) {\r\n\r\n			this._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n			this._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n			this._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n			this._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n		}\r\n\r\n		if ( update !== false ) this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromAxisAngle: function ( axis, angle ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n		// assumes axis is normalized\r\n\r\n		var halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n		this._x = axis.x * s;\r\n		this._y = axis.y * s;\r\n		this._z = axis.z * s;\r\n		this._w = Math.cos( halfAngle );\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromRotationMatrix: function ( m ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var te = m.elements,\r\n\r\n			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n			trace = m11 + m22 + m33,\r\n			s;\r\n\r\n		if ( trace > 0 ) {\r\n\r\n			s = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n			this._w = 0.25 / s;\r\n			this._x = ( m32 - m23 ) * s;\r\n			this._y = ( m13 - m31 ) * s;\r\n			this._z = ( m21 - m12 ) * s;\r\n\r\n		} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n			this._w = ( m32 - m23 ) / s;\r\n			this._x = 0.25 * s;\r\n			this._y = ( m12 + m21 ) / s;\r\n			this._z = ( m13 + m31 ) / s;\r\n\r\n		} else if ( m22 > m33 ) {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n			this._w = ( m13 - m31 ) / s;\r\n			this._x = ( m12 + m21 ) / s;\r\n			this._y = 0.25 * s;\r\n			this._z = ( m23 + m32 ) / s;\r\n\r\n		} else {\r\n\r\n			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n			this._w = ( m21 - m12 ) / s;\r\n			this._x = ( m13 + m31 ) / s;\r\n			this._y = ( m23 + m32 ) / s;\r\n			this._z = 0.25 * s;\r\n\r\n		}\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromUnitVectors: function () {\r\n\r\n		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n		// assumes direction vectors vFrom and vTo are normalized\r\n\r\n		var v1, r;\r\n\r\n		var EPS = 0.000001;\r\n\r\n		return function ( vFrom, vTo ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			r = vFrom.dot( vTo ) + 1;\r\n\r\n			if ( r < EPS ) {\r\n\r\n				r = 0;\r\n\r\n				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n					v1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n				} else {\r\n\r\n					v1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				v1.crossVectors( vFrom, vTo );\r\n\r\n			}\r\n\r\n			this._x = v1.x;\r\n			this._y = v1.y;\r\n			this._z = v1.z;\r\n			this._w = r;\r\n\r\n			this.normalize();\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	inverse: function () {\r\n\r\n		this.conjugate().normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	conjugate: function () {\r\n\r\n		this._x *= - 1;\r\n		this._y *= - 1;\r\n		this._z *= - 1;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		var l = this.length();\r\n\r\n		if ( l === 0 ) {\r\n\r\n			this._x = 0;\r\n			this._y = 0;\r\n			this._z = 0;\r\n			this._w = 1;\r\n\r\n		} else {\r\n\r\n			l = 1 / l;\r\n\r\n			this._x = this._x * l;\r\n			this._y = this._y * l;\r\n			this._z = this._z * l;\r\n			this._w = this._w * l;\r\n\r\n		}\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( q, p ) {\r\n\r\n		if ( p !== undefined ) {\r\n\r\n			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n			return this.multiplyQuaternions( q, p );\r\n\r\n		}\r\n\r\n		return this.multiplyQuaternions( this, q );\r\n\r\n	},\r\n\r\n	multiplyQuaternions: function ( a, b ) {\r\n\r\n		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVector3: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n		return vector.applyQuaternion( this );\r\n\r\n	},\r\n\r\n	slerp: function ( qb, t ) {\r\n\r\n		if ( t === 0 ) return this;\r\n		if ( t === 1 ) return this.copy( qb );\r\n\r\n		var x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n		if ( cosHalfTheta < 0 ) {\r\n\r\n			this._w = - qb._w;\r\n			this._x = - qb._x;\r\n			this._y = - qb._y;\r\n			this._z = - qb._z;\r\n\r\n			cosHalfTheta = - cosHalfTheta;\r\n\r\n		} else {\r\n\r\n			this.copy( qb );\r\n\r\n		}\r\n\r\n		if ( cosHalfTheta >= 1.0 ) {\r\n\r\n			this._w = w;\r\n			this._x = x;\r\n			this._y = y;\r\n			this._z = z;\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		var halfTheta = Math.acos( cosHalfTheta );\r\n		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n		if ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n			this._w = 0.5 * ( w + this._w );\r\n			this._x = 0.5 * ( x + this._x );\r\n			this._y = 0.5 * ( y + this._y );\r\n			this._z = 0.5 * ( z + this._z );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n		this._w = ( w * ratioA + this._w * ratioB );\r\n		this._x = ( x * ratioA + this._x * ratioB );\r\n		this._y = ( y * ratioA + this._y * ratioB );\r\n		this._z = ( z * ratioA + this._z * ratioB );\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( quaternion ) {\r\n\r\n		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this._x = array[ offset ];\r\n		this._y = array[ offset + 1 ];\r\n		this._z = array[ offset + 2 ];\r\n		this._w = array[ offset + 3 ];\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this._x;\r\n		array[ offset + 1 ] = this._y;\r\n		array[ offset + 2 ] = this._z;\r\n		array[ offset + 3 ] = this._w;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	onChange: function ( callback ) {\r\n\r\n		this.onChangeCallback = callback;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	onChangeCallback: function () {},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Quaternion( this._x, this._y, this._z, this._w );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Quaternion.slerp = function ( qa, qb, qm, t ) {\r\n\r\n	return qm.copy( qa ).slerp( qb, t );\r\n\r\n}\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n	constructor: THREE.Vector2,\r\n\r\n	set: function ( x, y ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( v ) {\r\n\r\n		this.x *= v.x;\r\n		this.y *= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		this.x *= s;\r\n		this.y *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divide: function ( v ) {\r\n\r\n		this.x /= v.x;\r\n		this.y /= v.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		if ( scalar !== 0 ) {\r\n\r\n			var invScalar = 1 / scalar;\r\n\r\n			this.x *= invScalar;\r\n			this.y *= invScalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		if ( this.x > v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y > v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		if ( this.x < v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y < v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		if ( this.x < min.x ) {\r\n\r\n			this.x = min.x;\r\n\r\n		} else if ( this.x > max.x ) {\r\n\r\n			this.x = max.x;\r\n\r\n		}\r\n\r\n		if ( this.y < min.y ) {\r\n\r\n			this.y = min.y;\r\n\r\n		} else if ( this.y > max.y ) {\r\n\r\n			this.y = max.y;\r\n\r\n		}\r\n\r\n		return this;\r\n	},\r\n\r\n	clampScalar: ( function () {\r\n\r\n		var min, max;\r\n\r\n		return function ( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector2();\r\n				max = new THREE.Vector2();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal );\r\n			max.set( maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	} )(),\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	distanceTo: function ( v ) {\r\n\r\n		return Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n	},\r\n\r\n	distanceToSquared: function ( v ) {\r\n\r\n		var dx = this.x - v.x, dy = this.y - v.y;\r\n		return dx * dx + dy * dy;\r\n\r\n	},\r\n\r\n	setLength: function ( l ) {\r\n\r\n		var oldLength = this.length();\r\n\r\n		if ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n			this.multiplyScalar( l / oldLength );\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n	    if ( offset === undefined ) offset = 0;\r\n\r\n	    index = index * attribute.itemSize + offset;\r\n\r\n	    this.x = attribute.array[ index ];\r\n	    this.y = attribute.array[ index + 1 ];\r\n\r\n	    return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Vector2( this.x, this.y );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n	this.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n	constructor: THREE.Vector3,\r\n\r\n	set: function ( x, y, z ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( z ) {\r\n\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			case 2: this.z = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			case 2: return this.z;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n		this.z = v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n		this.z += v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n		this.z += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n		this.z = a.z + b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n		this.z -= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n		this.z = a.z - b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiply: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n			return this.multiplyVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x *= v.x;\r\n		this.y *= v.y;\r\n		this.z *= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( scalar ) {\r\n\r\n		this.x *= scalar;\r\n		this.y *= scalar;\r\n		this.z *= scalar;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVectors: function ( a, b ) {\r\n\r\n		this.x = a.x * b.x;\r\n		this.y = a.y * b.y;\r\n		this.z = a.z * b.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyEuler: function () {\r\n\r\n		var quaternion;\r\n\r\n		return function ( euler ) {\r\n\r\n			if ( euler instanceof THREE.Euler === false ) {\r\n\r\n				console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n			}\r\n\r\n			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n			this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyAxisAngle: function () {\r\n\r\n		var quaternion;\r\n\r\n		return function ( axis, angle ) {\r\n\r\n			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyMatrix3: function ( m ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 affine matrix\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyProjection: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 projection matrix\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyQuaternion: function ( q ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n\r\n		var qx = q.x;\r\n		var qy = q.y;\r\n		var qz = q.z;\r\n		var qw = q.w;\r\n\r\n		// calculate quat * vector\r\n\r\n		var ix =  qw * x + qy * z - qz * y;\r\n		var iy =  qw * y + qz * x - qx * z;\r\n		var iz =  qw * z + qx * y - qy * x;\r\n		var iw = - qx * x - qy * y - qz * z;\r\n\r\n		// calculate result * inverse quat\r\n\r\n		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	project: function () {\r\n\r\n		var matrix;\r\n\r\n		return function ( camera ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n			return this.applyProjection( matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	unproject: function () {\r\n\r\n		var matrix;\r\n\r\n		return function ( camera ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n			return this.applyProjection( matrix );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	transformDirection: function ( m ) {\r\n\r\n		// input: THREE.Matrix4 affine matrix\r\n		// vector interpreted as a direction\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n		this.normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divide: function ( v ) {\r\n\r\n		this.x /= v.x;\r\n		this.y /= v.y;\r\n		this.z /= v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		if ( scalar !== 0 ) {\r\n\r\n			var invScalar = 1 / scalar;\r\n\r\n			this.x *= invScalar;\r\n			this.y *= invScalar;\r\n			this.z *= invScalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n			this.z = 0;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		if ( this.x > v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y > v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z > v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		if ( this.x < v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y < v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z < v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		if ( this.x < min.x ) {\r\n\r\n			this.x = min.x;\r\n\r\n		} else if ( this.x > max.x ) {\r\n\r\n			this.x = max.x;\r\n\r\n		}\r\n\r\n		if ( this.y < min.y ) {\r\n\r\n			this.y = min.y;\r\n\r\n		} else if ( this.y > max.y ) {\r\n\r\n			this.y = max.y;\r\n\r\n		}\r\n\r\n		if ( this.z < min.z ) {\r\n\r\n			this.z = min.z;\r\n\r\n		} else if ( this.z > max.z ) {\r\n\r\n			this.z = max.z;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: ( function () {\r\n\r\n		var min, max;\r\n\r\n		return function ( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector3();\r\n				max = new THREE.Vector3();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal, minVal );\r\n			max.set( maxVal, maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	} )(),\r\n\r\n	floor: function () {\r\n\r\n		this.x = Math.floor( this.x );\r\n		this.y = Math.floor( this.y );\r\n		this.z = Math.floor( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	ceil: function () {\r\n\r\n		this.x = Math.ceil( this.x );\r\n		this.y = Math.ceil( this.y );\r\n		this.z = Math.ceil( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	round: function () {\r\n\r\n		this.x = Math.round( this.x );\r\n		this.y = Math.round( this.y );\r\n		this.z = Math.round( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	roundToZero: function () {\r\n\r\n		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n		this.z = - this.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n	},\r\n\r\n	lengthManhattan: function () {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	setLength: function ( l ) {\r\n\r\n		var oldLength = this.length();\r\n\r\n		if ( oldLength !== 0 && l !== oldLength  ) {\r\n\r\n			this.multiplyScalar( l / oldLength );\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n		this.z += ( v.z - this.z ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	cross: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n			return this.crossVectors( v, w );\r\n\r\n		}\r\n\r\n		var x = this.x, y = this.y, z = this.z;\r\n\r\n		this.x = y * v.z - z * v.y;\r\n		this.y = z * v.x - x * v.z;\r\n		this.z = x * v.y - y * v.x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	crossVectors: function ( a, b ) {\r\n\r\n		var ax = a.x, ay = a.y, az = a.z;\r\n		var bx = b.x, by = b.y, bz = b.z;\r\n\r\n		this.x = ay * bz - az * by;\r\n		this.y = az * bx - ax * bz;\r\n		this.z = ax * by - ay * bx;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	projectOnVector: function () {\r\n\r\n		var v1, dot;\r\n\r\n		return function ( vector ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			v1.copy( vector ).normalize();\r\n\r\n			dot = this.dot( v1 );\r\n\r\n			return this.copy( v1 ).multiplyScalar( dot );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	projectOnPlane: function () {\r\n\r\n		var v1;\r\n\r\n		return function ( planeNormal ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			v1.copy( this ).projectOnVector( planeNormal );\r\n\r\n			return this.sub( v1 );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	reflect: function () {\r\n\r\n		// reflect incident vector off plane orthogonal to normal\r\n		// normal is assumed to have unit length\r\n\r\n		var v1;\r\n\r\n		return function ( normal ) {\r\n\r\n			if ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	angleTo: function ( v ) {\r\n\r\n		var theta = this.dot( v ) / ( this.length() * v.length() );\r\n\r\n		// clamp, to handle numerical problems\r\n\r\n		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n	},\r\n\r\n	distanceTo: function ( v ) {\r\n\r\n		return Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n	},\r\n\r\n	distanceToSquared: function ( v ) {\r\n\r\n		var dx = this.x - v.x;\r\n		var dy = this.y - v.y;\r\n		var dz = this.z - v.z;\r\n\r\n		return dx * dx + dy * dy + dz * dz;\r\n\r\n	},\r\n\r\n	setEulerFromRotationMatrix: function ( m, order ) {\r\n\r\n		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\r\n	},\r\n\r\n	setEulerFromQuaternion: function ( q, order ) {\r\n\r\n		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\r\n	},\r\n\r\n	getPositionFromMatrix: function ( m ) {\r\n\r\n		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\r\n		return this.setFromMatrixPosition( m );\r\n\r\n	},\r\n\r\n	getScaleFromMatrix: function ( m ) {\r\n\r\n		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\r\n		return this.setFromMatrixScale( m );\r\n	},\r\n\r\n	getColumnFromMatrix: function ( index, matrix ) {\r\n\r\n		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\r\n		return this.setFromMatrixColumn( index, matrix );\r\n\r\n	},\r\n\r\n	setFromMatrixPosition: function ( m ) {\r\n\r\n		this.x = m.elements[ 12 ];\r\n		this.y = m.elements[ 13 ];\r\n		this.z = m.elements[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrixScale: function ( m ) {\r\n\r\n		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();\r\n		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();\r\n		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();\r\n\r\n		this.x = sx;\r\n		this.y = sy;\r\n		this.z = sz;\r\n\r\n		return this;\r\n	},\r\n\r\n	setFromMatrixColumn: function ( index, matrix ) {\r\n\r\n		var offset = index * 4;\r\n\r\n		var me = matrix.elements;\r\n\r\n		this.x = me[ offset ];\r\n		this.y = me[ offset + 1 ];\r\n		this.z = me[ offset + 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n		this.z = array[ offset + 2 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n		array[ offset + 2 ] = this.z;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n	    if ( offset === undefined ) offset = 0;\r\n\r\n	    index = index * attribute.itemSize + offset;\r\n\r\n	    this.x = attribute.array[ index ];\r\n	    this.y = attribute.array[ index + 1 ];\r\n	    this.z = attribute.array[ index + 2 ];\r\n\r\n	    return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Vector3( this.x, this.y, this.z );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n	this.x = x || 0;\r\n	this.y = y || 0;\r\n	this.z = z || 0;\r\n	this.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n	constructor: THREE.Vector4,\r\n\r\n	set: function ( x, y, z, w ) {\r\n\r\n		this.x = x;\r\n		this.y = y;\r\n		this.z = z;\r\n		this.w = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( x ) {\r\n\r\n		this.x = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( y ) {\r\n\r\n		this.y = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( z ) {\r\n\r\n		this.z = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setW: function ( w ) {\r\n\r\n		this.w = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponent: function ( index, value ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: this.x = value; break;\r\n			case 1: this.y = value; break;\r\n			case 2: this.z = value; break;\r\n			case 3: this.w = value; break;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getComponent: function ( index ) {\r\n\r\n		switch ( index ) {\r\n\r\n			case 0: return this.x;\r\n			case 1: return this.y;\r\n			case 2: return this.z;\r\n			case 3: return this.w;\r\n			default: throw new Error( 'index is out of range: ' + index );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	copy: function ( v ) {\r\n\r\n		this.x = v.x;\r\n		this.y = v.y;\r\n		this.z = v.z;\r\n		this.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	add: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n			return this.addVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x += v.x;\r\n		this.y += v.y;\r\n		this.z += v.z;\r\n		this.w += v.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addScalar: function ( s ) {\r\n\r\n		this.x += s;\r\n		this.y += s;\r\n		this.z += s;\r\n		this.w += s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	addVectors: function ( a, b ) {\r\n\r\n		this.x = a.x + b.x;\r\n		this.y = a.y + b.y;\r\n		this.z = a.z + b.z;\r\n		this.w = a.w + b.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	sub: function ( v, w ) {\r\n\r\n		if ( w !== undefined ) {\r\n\r\n			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n			return this.subVectors( v, w );\r\n\r\n		}\r\n\r\n		this.x -= v.x;\r\n		this.y -= v.y;\r\n		this.z -= v.z;\r\n		this.w -= v.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	subVectors: function ( a, b ) {\r\n\r\n		this.x = a.x - b.x;\r\n		this.y = a.y - b.y;\r\n		this.z = a.z - b.z;\r\n		this.w = a.w - b.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( scalar ) {\r\n\r\n		this.x *= scalar;\r\n		this.y *= scalar;\r\n		this.z *= scalar;\r\n		this.w *= scalar;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( m ) {\r\n\r\n		var x = this.x;\r\n		var y = this.y;\r\n		var z = this.z;\r\n		var w = this.w;\r\n\r\n		var e = m.elements;\r\n\r\n		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	divideScalar: function ( scalar ) {\r\n\r\n		if ( scalar !== 0 ) {\r\n\r\n			var invScalar = 1 / scalar;\r\n\r\n			this.x *= invScalar;\r\n			this.y *= invScalar;\r\n			this.z *= invScalar;\r\n			this.w *= invScalar;\r\n\r\n		} else {\r\n\r\n			this.x = 0;\r\n			this.y = 0;\r\n			this.z = 0;\r\n			this.w = 1;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setAxisAngleFromQuaternion: function ( q ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n		// q is assumed to be normalized\r\n\r\n		this.w = 2 * Math.acos( q.w );\r\n\r\n		var s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n		if ( s < 0.0001 ) {\r\n\r\n			 this.x = 1;\r\n			 this.y = 0;\r\n			 this.z = 0;\r\n\r\n		} else {\r\n\r\n			 this.x = q.x / s;\r\n			 this.y = q.y / s;\r\n			 this.z = q.z / s;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var angle, x, y, z,		// variables for result\r\n			epsilon = 0.01,		// margin to allow for rounding errors\r\n			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees\r\n\r\n			te = m.elements,\r\n\r\n			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n		if ( ( Math.abs( m12 - m21 ) < epsilon )\r\n		   && ( Math.abs( m13 - m31 ) < epsilon )\r\n		   && ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n			// singularity found\r\n			// first check for identity matrix which must have +1 for all terms\r\n			// in leading diagonal and zero in other terms\r\n\r\n			if ( ( Math.abs( m12 + m21 ) < epsilon2 )\r\n			   && ( Math.abs( m13 + m31 ) < epsilon2 )\r\n			   && ( Math.abs( m23 + m32 ) < epsilon2 )\r\n			   && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n				// this singularity is identity matrix so angle = 0\r\n\r\n				this.set( 1, 0, 0, 0 );\r\n\r\n				return this; // zero angle, arbitrary axis\r\n\r\n			}\r\n\r\n			// otherwise this singularity is angle = 180\r\n\r\n			angle = Math.PI;\r\n\r\n			var xx = ( m11 + 1 ) / 2;\r\n			var yy = ( m22 + 1 ) / 2;\r\n			var zz = ( m33 + 1 ) / 2;\r\n			var xy = ( m12 + m21 ) / 4;\r\n			var xz = ( m13 + m31 ) / 4;\r\n			var yz = ( m23 + m32 ) / 4;\r\n\r\n			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term\r\n\r\n				if ( xx < epsilon ) {\r\n\r\n					x = 0;\r\n					y = 0.707106781;\r\n					z = 0.707106781;\r\n\r\n				} else {\r\n\r\n					x = Math.sqrt( xx );\r\n					y = xy / x;\r\n					z = xz / x;\r\n\r\n				}\r\n\r\n			} else if ( yy > zz ) { // m22 is the largest diagonal term\r\n\r\n				if ( yy < epsilon ) {\r\n\r\n					x = 0.707106781;\r\n					y = 0;\r\n					z = 0.707106781;\r\n\r\n				} else {\r\n\r\n					y = Math.sqrt( yy );\r\n					x = xy / y;\r\n					z = yz / y;\r\n\r\n				}\r\n\r\n			} else { // m33 is the largest diagonal term so base result on this\r\n\r\n				if ( zz < epsilon ) {\r\n\r\n					x = 0.707106781;\r\n					y = 0.707106781;\r\n					z = 0;\r\n\r\n				} else {\r\n\r\n					z = Math.sqrt( zz );\r\n					x = xz / z;\r\n					y = yz / z;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.set( x, y, z, angle );\r\n\r\n			return this; // return 180 deg rotation\r\n\r\n		}\r\n\r\n		// as we have reached here there are no singularities so we can handle normally\r\n\r\n		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )\r\n						  + ( m13 - m31 ) * ( m13 - m31 )\r\n						  + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n		if ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n		// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n		// caught by singularity test above, but I've left it in just in case\r\n\r\n		this.x = ( m32 - m23 ) / s;\r\n		this.y = ( m13 - m31 ) / s;\r\n		this.z = ( m21 - m12 ) / s;\r\n		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	min: function ( v ) {\r\n\r\n		if ( this.x > v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y > v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z > v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		if ( this.w > v.w ) {\r\n\r\n			this.w = v.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	max: function ( v ) {\r\n\r\n		if ( this.x < v.x ) {\r\n\r\n			this.x = v.x;\r\n\r\n		}\r\n\r\n		if ( this.y < v.y ) {\r\n\r\n			this.y = v.y;\r\n\r\n		}\r\n\r\n		if ( this.z < v.z ) {\r\n\r\n			this.z = v.z;\r\n\r\n		}\r\n\r\n		if ( this.w < v.w ) {\r\n\r\n			this.w = v.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clamp: function ( min, max ) {\r\n\r\n		// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n		if ( this.x < min.x ) {\r\n\r\n			this.x = min.x;\r\n\r\n		} else if ( this.x > max.x ) {\r\n\r\n			this.x = max.x;\r\n\r\n		}\r\n\r\n		if ( this.y < min.y ) {\r\n\r\n			this.y = min.y;\r\n\r\n		} else if ( this.y > max.y ) {\r\n\r\n			this.y = max.y;\r\n\r\n		}\r\n\r\n		if ( this.z < min.z ) {\r\n\r\n			this.z = min.z;\r\n\r\n		} else if ( this.z > max.z ) {\r\n\r\n			this.z = max.z;\r\n\r\n		}\r\n\r\n		if ( this.w < min.w ) {\r\n\r\n			this.w = min.w;\r\n\r\n		} else if ( this.w > max.w ) {\r\n\r\n			this.w = max.w;\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clampScalar: ( function () {\r\n\r\n		var min, max;\r\n\r\n		return function ( minVal, maxVal ) {\r\n\r\n			if ( min === undefined ) {\r\n\r\n				min = new THREE.Vector4();\r\n				max = new THREE.Vector4();\r\n\r\n			}\r\n\r\n			min.set( minVal, minVal, minVal, minVal );\r\n			max.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n			return this.clamp( min, max );\r\n\r\n		};\r\n\r\n	} )(),\r\n\r\n    floor: function () {\r\n\r\n        this.x = Math.floor( this.x );\r\n        this.y = Math.floor( this.y );\r\n        this.z = Math.floor( this.z );\r\n        this.w = Math.floor( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    ceil: function () {\r\n\r\n        this.x = Math.ceil( this.x );\r\n        this.y = Math.ceil( this.y );\r\n        this.z = Math.ceil( this.z );\r\n        this.w = Math.ceil( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    round: function () {\r\n\r\n        this.x = Math.round( this.x );\r\n        this.y = Math.round( this.y );\r\n        this.z = Math.round( this.z );\r\n        this.w = Math.round( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n    roundToZero: function () {\r\n\r\n        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n        return this;\r\n\r\n    },\r\n\r\n	negate: function () {\r\n\r\n		this.x = - this.x;\r\n		this.y = - this.y;\r\n		this.z = - this.z;\r\n		this.w = - this.w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	dot: function ( v ) {\r\n\r\n		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n	},\r\n\r\n	lengthSq: function () {\r\n\r\n		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n	},\r\n\r\n	length: function () {\r\n\r\n		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n	},\r\n\r\n	lengthManhattan: function () {\r\n\r\n		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		return this.divideScalar( this.length() );\r\n\r\n	},\r\n\r\n	setLength: function ( l ) {\r\n\r\n		var oldLength = this.length();\r\n\r\n		if ( oldLength !== 0 && l !== oldLength ) {\r\n\r\n			this.multiplyScalar( l / oldLength );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lerp: function ( v, alpha ) {\r\n\r\n		this.x += ( v.x - this.x ) * alpha;\r\n		this.y += ( v.y - this.y ) * alpha;\r\n		this.z += ( v.z - this.z ) * alpha;\r\n		this.w += ( v.w - this.w ) * alpha;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( v ) {\r\n\r\n		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n	},\r\n\r\n	fromArray: function ( array, offset ) {\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		this.x = array[ offset ];\r\n		this.y = array[ offset + 1 ];\r\n		this.z = array[ offset + 2 ];\r\n		this.w = array[ offset + 3 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function ( array, offset ) {\r\n\r\n		if ( array === undefined ) array = [];\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		array[ offset ] = this.x;\r\n		array[ offset + 1 ] = this.y;\r\n		array[ offset + 2 ] = this.z;\r\n		array[ offset + 3 ] = this.w;\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	fromAttribute: function ( attribute, index, offset ) {\r\n\r\n	    if ( offset === undefined ) offset = 0;\r\n\r\n	    index = index * attribute.itemSize + offset;\r\n\r\n	    this.x = attribute.array[ index ];\r\n	    this.y = attribute.array[ index + 1 ];\r\n	    this.z = attribute.array[ index + 2 ];\r\n	    this.w = attribute.array[ index + 3 ];\r\n\r\n	    return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Vector4( this.x, this.y, this.z, this.w );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n	this._x = x || 0;\r\n	this._y = y || 0;\r\n	this._z = z || 0;\r\n	this._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n	constructor: THREE.Euler,\r\n\r\n	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,\r\n\r\n	get x () {\r\n\r\n		return this._x;\r\n\r\n	},\r\n\r\n	set x ( value ) {\r\n\r\n		this._x = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get y () {\r\n\r\n		return this._y;\r\n\r\n	},\r\n\r\n	set y ( value ) {\r\n\r\n		this._y = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get z () {\r\n\r\n		return this._z;\r\n\r\n	},\r\n\r\n	set z ( value ) {\r\n\r\n		this._z = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	get order () {\r\n\r\n		return this._order;\r\n\r\n	},\r\n\r\n	set order ( value ) {\r\n\r\n		this._order = value;\r\n		this.onChangeCallback();\r\n\r\n	},\r\n\r\n	set: function ( x, y, z, order ) {\r\n\r\n		this._x = x;\r\n		this._y = y;\r\n		this._z = z;\r\n		this._order = order || this._order;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( euler ) {\r\n\r\n		this._x = euler._x;\r\n		this._y = euler._y;\r\n		this._z = euler._z;\r\n		this._order = euler._order;\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromRotationMatrix: function ( m, order, update ) {\r\n\r\n		var clamp = THREE.Math.clamp;\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		var te = m.elements;\r\n		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n		order = order || this._order;\r\n\r\n		if ( order === 'XYZ' ) {\r\n\r\n			this._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( - m23, m33 );\r\n				this._z = Math.atan2( - m12, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = Math.atan2( m32, m22 );\r\n				this._z = 0;\r\n\r\n			}\r\n\r\n		} else if ( order === 'YXZ' ) {\r\n\r\n			this._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n				this._y = Math.atan2( m13, m33 );\r\n				this._z = Math.atan2( m21, m22 );\r\n\r\n			} else {\r\n\r\n				this._y = Math.atan2( - m31, m11 );\r\n				this._z = 0;\r\n\r\n			}\r\n\r\n		} else if ( order === 'ZXY' ) {\r\n\r\n			this._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n				this._y = Math.atan2( - m31, m33 );\r\n				this._z = Math.atan2( - m12, m22 );\r\n\r\n			} else {\r\n\r\n				this._y = 0;\r\n				this._z = Math.atan2( m21, m11 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'ZYX' ) {\r\n\r\n			this._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( m32, m33 );\r\n				this._z = Math.atan2( m21, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = 0;\r\n				this._z = Math.atan2( - m12, m22 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'YZX' ) {\r\n\r\n			this._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( - m23, m22 );\r\n				this._y = Math.atan2( - m31, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = 0;\r\n				this._y = Math.atan2( m13, m33 );\r\n\r\n			}\r\n\r\n		} else if ( order === 'XZY' ) {\r\n\r\n			this._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n			if ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n				this._x = Math.atan2( m32, m22 );\r\n				this._y = Math.atan2( m13, m11 );\r\n\r\n			} else {\r\n\r\n				this._x = Math.atan2( - m23, m33 );\r\n				this._y = 0;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )\r\n\r\n		}\r\n\r\n		this._order = order;\r\n\r\n		if ( update !== false ) this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromQuaternion: function () {\r\n\r\n		var matrix;\r\n\r\n		return function ( q, order, update ) {\r\n\r\n			if ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n			matrix.makeRotationFromQuaternion( q );\r\n			this.setFromRotationMatrix( matrix, order, update );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setFromVector3: function ( v, order ) {\r\n\r\n		return this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n	},\r\n\r\n	reorder: function () {\r\n\r\n		// WARNING: this discards revolution information -bhouston\r\n\r\n		var q = new THREE.Quaternion();\r\n\r\n		return function ( newOrder ) {\r\n\r\n			q.setFromEuler( this );\r\n			this.setFromQuaternion( q, newOrder );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	equals: function ( euler ) {\r\n\r\n		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this._x = array[ 0 ];\r\n		this._y = array[ 1 ];\r\n		this._z = array[ 2 ];\r\n		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n		this.onChangeCallback();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		return [ this._x, this._y, this._z, this._order ];\r\n\r\n	},\r\n\r\n	toVector3: function ( optionalResult ) {\r\n\r\n		if ( optionalResult ) {\r\n\r\n			return optionalResult.set( this._x, this._y, this._z );\r\n\r\n		} else {\r\n\r\n			return new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	onChange: function ( callback ) {\r\n\r\n		this.onChangeCallback = callback;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	onChangeCallback: function () {},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Euler( this._x, this._y, this._z, this._order );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n	this.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n	this.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n	constructor: THREE.Line3,\r\n\r\n	set: function ( start, end ) {\r\n\r\n		this.start.copy( start );\r\n		this.end.copy( end );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( line ) {\r\n\r\n		this.start.copy( line.start );\r\n		this.end.copy( line.end );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	delta: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.subVectors( this.end, this.start );\r\n\r\n	},\r\n\r\n	distanceSq: function () {\r\n\r\n		return this.start.distanceToSquared( this.end );\r\n\r\n	},\r\n\r\n	distance: function () {\r\n\r\n		return this.start.distanceTo( this.end );\r\n\r\n	},\r\n\r\n	at: function ( t, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n	},\r\n\r\n	closestPointToPointParameter: function () {\r\n\r\n		var startP = new THREE.Vector3();\r\n		var startEnd = new THREE.Vector3();\r\n\r\n		return function ( point, clampToLine ) {\r\n\r\n			startP.subVectors( point, this.start );\r\n			startEnd.subVectors( this.end, this.start );\r\n\r\n			var startEnd2 = startEnd.dot( startEnd );\r\n			var startEnd_startP = startEnd.dot( startP );\r\n\r\n			var t = startEnd_startP / startEnd2;\r\n\r\n			if ( clampToLine ) {\r\n\r\n				t = THREE.Math.clamp( t, 0, 1 );\r\n\r\n			}\r\n\r\n			return t;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n		var t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( matrix ) {\r\n\r\n		this.start.applyMatrix4( matrix );\r\n		this.end.applyMatrix4( matrix );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( line ) {\r\n\r\n		return line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Line3().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );\r\n	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n	constructor: THREE.Box2,\r\n\r\n	set: function ( min, max ) {\r\n\r\n		this.min.copy( min );\r\n		this.max.copy( max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPoints: function ( points ) {\r\n\r\n		this.makeEmpty();\r\n\r\n		for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n			this.expandByPoint( points[ i ] )\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCenterAndSize: function () {\r\n\r\n		var v1 = new THREE.Vector2();\r\n\r\n		return function ( center, size ) {\r\n\r\n			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n			this.min.copy( center ).sub( halfSize );\r\n			this.max.copy( center ).add( halfSize );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	copy: function ( box ) {\r\n\r\n		this.min.copy( box.min );\r\n		this.max.copy( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeEmpty: function () {\r\n\r\n		this.min.x = this.min.y = Infinity;\r\n		this.max.x = this.max.y = - Infinity;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	empty: function () {\r\n\r\n		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	size: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.subVectors( this.max, this.min );\r\n\r\n	},\r\n\r\n	expandByPoint: function ( point ) {\r\n\r\n		this.min.min( point );\r\n		this.max.max( point );\r\n\r\n		return this;\r\n	},\r\n\r\n	expandByVector: function ( vector ) {\r\n\r\n		this.min.sub( vector );\r\n		this.max.add( vector );\r\n\r\n		return this;\r\n	},\r\n\r\n	expandByScalar: function ( scalar ) {\r\n\r\n		this.min.addScalar( - scalar );\r\n		this.max.addScalar( scalar );\r\n\r\n		return this;\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		if ( point.x < this.min.x || point.x > this.max.x ||\r\n		     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	containsBox: function ( box ) {\r\n\r\n		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	getParameter: function ( point, optionalTarget ) {\r\n\r\n		// This can potentially have a divide by zero if the box\r\n		// has a size dimension of 0.\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n\r\n		return result.set(\r\n			( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n			( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n		);\r\n\r\n	},\r\n\r\n	isIntersectionBox: function ( box ) {\r\n\r\n		// using 6 splitting planes to rule out intersections.\r\n\r\n		if ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n		     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector2();\r\n		return result.copy( point ).clamp( this.min, this.max );\r\n\r\n	},\r\n\r\n	distanceToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector2();\r\n\r\n		return function ( point ) {\r\n\r\n			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n			return clampedPoint.sub( point ).length();\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersect: function ( box ) {\r\n\r\n		this.min.max( box.min );\r\n		this.max.min( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	union: function ( box ) {\r\n\r\n		this.min.min( box.min );\r\n		this.max.max( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.min.add( offset );\r\n		this.max.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( box ) {\r\n\r\n		return box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Box2().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );\r\n	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n	constructor: THREE.Box3,\r\n\r\n	set: function ( min, max ) {\r\n\r\n		this.min.copy( min );\r\n		this.max.copy( max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPoints: function ( points ) {\r\n\r\n		this.makeEmpty();\r\n\r\n		for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n			this.expandByPoint( points[ i ] )\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCenterAndSize: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( center, size ) {\r\n\r\n			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n			this.min.copy( center ).sub( halfSize );\r\n			this.max.copy( center ).add( halfSize );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setFromObject: function () {\r\n\r\n		// Computes the world-axis-aligned bounding box of an object (including its children),\r\n		// accounting for both the object's, and childrens', world transforms\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( object ) {\r\n\r\n			var scope = this;\r\n\r\n			object.updateMatrixWorld( true );\r\n\r\n			this.makeEmpty();\r\n\r\n			object.traverse( function ( node ) {\r\n\r\n				var geometry = node.geometry;\r\n\r\n				if ( geometry !== undefined ) {\r\n\r\n					if ( geometry instanceof THREE.Geometry ) {\r\n\r\n						var vertices = geometry.vertices;\r\n\r\n						for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n							v1.copy( vertices[ i ] );\r\n\r\n							v1.applyMatrix4( node.matrixWorld );\r\n\r\n							scope.expandByPoint( v1 );\r\n\r\n						}\r\n\r\n					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\r\n						var positions = geometry.attributes[ 'position' ].array;\r\n\r\n						for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n							v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n\r\n							v1.applyMatrix4( node.matrixWorld );\r\n\r\n							scope.expandByPoint( v1 );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	copy: function ( box ) {\r\n\r\n		this.min.copy( box.min );\r\n		this.max.copy( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeEmpty: function () {\r\n\r\n		this.min.x = this.min.y = this.min.z = Infinity;\r\n		this.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	empty: function () {\r\n\r\n		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n	},\r\n\r\n	center: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n	},\r\n\r\n	size: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.subVectors( this.max, this.min );\r\n\r\n	},\r\n\r\n	expandByPoint: function ( point ) {\r\n\r\n		this.min.min( point );\r\n		this.max.max( point );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByVector: function ( vector ) {\r\n\r\n		this.min.sub( vector );\r\n		this.max.add( vector );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	expandByScalar: function ( scalar ) {\r\n\r\n		this.min.addScalar( - scalar );\r\n		this.max.addScalar( scalar );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		if ( point.x < this.min.x || point.x > this.max.x ||\r\n		     point.y < this.min.y || point.y > this.max.y ||\r\n		     point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	containsBox: function ( box ) {\r\n\r\n		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	getParameter: function ( point, optionalTarget ) {\r\n\r\n		// This can potentially have a divide by zero if the box\r\n		// has a size dimension of 0.\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return result.set(\r\n			( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n			( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n			( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n		);\r\n\r\n	},\r\n\r\n	isIntersectionBox: function ( box ) {\r\n\r\n		// using 6 splitting planes to rule out intersections.\r\n\r\n		if ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n		     box.max.y < this.min.y || box.min.y > this.max.y ||\r\n		     box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n			return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( point ).clamp( this.min, this.max );\r\n\r\n	},\r\n\r\n	distanceToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( point ) {\r\n\r\n			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n			return clampedPoint.sub( point ).length();\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	getBoundingSphere: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Sphere();\r\n\r\n			result.center = this.center();\r\n			result.radius = this.size( v1 ).length() * 0.5;\r\n\r\n			return result;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersect: function ( box ) {\r\n\r\n		this.min.max( box.min );\r\n		this.max.min( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	union: function ( box ) {\r\n\r\n		this.min.min( box.min );\r\n		this.max.max( box.max );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	applyMatrix4: function () {\r\n\r\n		var points = [\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3(),\r\n			new THREE.Vector3()\r\n		];\r\n\r\n		return function ( matrix ) {\r\n\r\n			// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111\r\n\r\n			this.makeEmpty();\r\n			this.setFromPoints( points );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.min.add( offset );\r\n		this.max.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( box ) {\r\n\r\n		return box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Box3().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n	this.elements = new Float32Array( [\r\n\r\n		1, 0, 0,\r\n		0, 1, 0,\r\n		0, 0, 1\r\n\r\n	] );\r\n\r\n	if ( arguments.length > 0 ) {\r\n\r\n		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n	constructor: THREE.Matrix3,\r\n\r\n	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;\r\n		te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;\r\n		te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	identity: function () {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0,\r\n			0, 1, 0,\r\n			0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( m ) {\r\n\r\n		var me = m.elements;\r\n\r\n		this.set(\r\n\r\n			me[ 0 ], me[ 3 ], me[ 6 ],\r\n			me[ 1 ], me[ 4 ], me[ 7 ],\r\n			me[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVector3: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n		return vector.applyMatrix3( this );\r\n\r\n	},\r\n\r\n	multiplyVector3Array: function ( a ) {\r\n\r\n		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n		return this.applyToVector3Array( a );\r\n\r\n	},\r\n\r\n	applyToVector3Array: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( array, offset, length ) {\r\n\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = array.length;\r\n\r\n			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {\r\n\r\n				v1.x = array[ j ];\r\n				v1.y = array[ j + 1 ];\r\n				v1.z = array[ j + 2 ];\r\n\r\n				v1.applyMatrix3( this );\r\n\r\n				array[ j ]     = v1.x;\r\n				array[ j + 1 ] = v1.y;\r\n				array[ j + 2 ] = v1.z;\r\n\r\n			}\r\n\r\n			return array;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	determinant: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n	},\r\n\r\n	getInverse: function ( matrix, throwOnInvertible ) {\r\n\r\n		// input: THREE.Matrix4\r\n		// ( based on http://code.google.com/p/webgl-mjs/ )\r\n\r\n		var me = matrix.elements;\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];\r\n		te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];\r\n		te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];\r\n		te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];\r\n		te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];\r\n		te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];\r\n		te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];\r\n		te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];\r\n		te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];\r\n\r\n		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];\r\n\r\n		// no inverse\r\n\r\n		if ( det === 0 ) {\r\n\r\n			var msg = \"Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n			if ( throwOnInvertible || false ) {\r\n\r\n				throw new Error( msg );\r\n\r\n			} else {\r\n\r\n				console.warn( msg );\r\n\r\n			}\r\n\r\n			this.identity();\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n		this.multiplyScalar( 1.0 / det );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	transpose: function () {\r\n\r\n		var tmp, m = this.elements;\r\n\r\n		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	flattenToArrayOffset: function ( array, offset ) {\r\n\r\n		var te = this.elements;\r\n\r\n		array[ offset     ] = te[ 0 ];\r\n		array[ offset + 1 ] = te[ 1 ];\r\n		array[ offset + 2 ] = te[ 2 ];\r\n\r\n		array[ offset + 3 ] = te[ 3 ];\r\n		array[ offset + 4 ] = te[ 4 ];\r\n		array[ offset + 5 ] = te[ 5 ];\r\n\r\n		array[ offset + 6 ] = te[ 6 ];\r\n		array[ offset + 7 ] = te[ 7 ];\r\n		array[ offset + 8 ]  = te[ 8 ];\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	getNormalMatrix: function ( m ) {\r\n\r\n		// input: THREE.Matrix4\r\n\r\n		this.getInverse( m ).transpose();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	transposeIntoArray: function ( r ) {\r\n\r\n		var m = this.elements;\r\n\r\n		r[ 0 ] = m[ 0 ];\r\n		r[ 1 ] = m[ 3 ];\r\n		r[ 2 ] = m[ 6 ];\r\n		r[ 3 ] = m[ 1 ];\r\n		r[ 4 ] = m[ 4 ];\r\n		r[ 5 ] = m[ 7 ];\r\n		r[ 6 ] = m[ 2 ];\r\n		r[ 7 ] = m[ 5 ];\r\n		r[ 8 ] = m[ 8 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.elements.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		return [\r\n			te[ 0 ], te[ 1 ], te[ 2 ],\r\n			te[ 3 ], te[ 4 ], te[ 5 ],\r\n			te[ 6 ], te[ 7 ], te[ 8 ]\r\n		];\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Matrix3().fromArray( this.elements );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://exocortex.com\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n	this.elements = new Float32Array( [\r\n\r\n		1, 0, 0, 0,\r\n		0, 1, 0, 0,\r\n		0, 0, 1, 0,\r\n		0, 0, 0, 1\r\n\r\n	] );\r\n\r\n	if ( arguments.length > 0 ) {\r\n\r\n		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n	constructor: THREE.Matrix4,\r\n\r\n	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	identity: function () {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0, 0,\r\n			0, 1, 0, 0,\r\n			0, 0, 1, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( m ) {\r\n\r\n		this.elements.set( m.elements );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	extractPosition: function ( m ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n		return this.copyPosition( m );\r\n\r\n	},\r\n\r\n	copyPosition: function ( m ) {\r\n\r\n		var te = this.elements;\r\n		var me = m.elements;\r\n\r\n		te[ 12 ] = me[ 12 ];\r\n		te[ 13 ] = me[ 13 ];\r\n		te[ 14 ] = me[ 14 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	extractBasis: function ( xAxis, yAxis, zAxis ) {\r\n \r\n 		var te = this.elements;\r\n \r\n		xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );\r\n		yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );\r\n		zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );\r\n \r\n 		return this;\r\n 		\r\n 	},\r\n \r\n	makeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n		this.set(\r\n			xAxis.x, yAxis.x, zAxis.x, 0,\r\n			xAxis.y, yAxis.y, zAxis.y, 0,\r\n			xAxis.z, yAxis.z, zAxis.z, 0,\r\n			0,       0,       0,       1\r\n		);\r\n\r\n	    return this;\r\n\r\n	},\r\n\r\n	extractRotation: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( m ) {\r\n\r\n			var te = this.elements;\r\n			var me = m.elements;\r\n\r\n			var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();\r\n			var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();\r\n			var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();\r\n\r\n			te[ 0 ] = me[ 0 ] * scaleX;\r\n			te[ 1 ] = me[ 1 ] * scaleX;\r\n			te[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n			te[ 4 ] = me[ 4 ] * scaleY;\r\n			te[ 5 ] = me[ 5 ] * scaleY;\r\n			te[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n			te[ 8 ] = me[ 8 ] * scaleZ;\r\n			te[ 9 ] = me[ 9 ] * scaleZ;\r\n			te[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	makeRotationFromEuler: function ( euler ) {\r\n\r\n		if ( euler instanceof THREE.Euler === false ) {\r\n\r\n			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n		}\r\n\r\n		var te = this.elements;\r\n\r\n		var x = euler.x, y = euler.y, z = euler.z;\r\n		var a = Math.cos( x ), b = Math.sin( x );\r\n		var c = Math.cos( y ), d = Math.sin( y );\r\n		var e = Math.cos( z ), f = Math.sin( z );\r\n\r\n		if ( euler.order === 'XYZ' ) {\r\n\r\n			var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = - c * f;\r\n			te[ 8 ] = d;\r\n\r\n			te[ 1 ] = af + be * d;\r\n			te[ 5 ] = ae - bf * d;\r\n			te[ 9 ] = - b * c;\r\n\r\n			te[ 2 ] = bf - ae * d;\r\n			te[ 6 ] = be + af * d;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'YXZ' ) {\r\n\r\n			var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n			te[ 0 ] = ce + df * b;\r\n			te[ 4 ] = de * b - cf;\r\n			te[ 8 ] = a * d;\r\n\r\n			te[ 1 ] = a * f;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = - b;\r\n\r\n			te[ 2 ] = cf * b - de;\r\n			te[ 6 ] = df + ce * b;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'ZXY' ) {\r\n\r\n			var ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n			te[ 0 ] = ce - df * b;\r\n			te[ 4 ] = - a * f;\r\n			te[ 8 ] = de + cf * b;\r\n\r\n			te[ 1 ] = cf + de * b;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = df - ce * b;\r\n\r\n			te[ 2 ] = - a * d;\r\n			te[ 6 ] = b;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'ZYX' ) {\r\n\r\n			var ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = be * d - af;\r\n			te[ 8 ] = ae * d + bf;\r\n\r\n			te[ 1 ] = c * f;\r\n			te[ 5 ] = bf * d + ae;\r\n			te[ 9 ] = af * d - be;\r\n\r\n			te[ 2 ] = - d;\r\n			te[ 6 ] = b * c;\r\n			te[ 10 ] = a * c;\r\n\r\n		} else if ( euler.order === 'YZX' ) {\r\n\r\n			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = bd - ac * f;\r\n			te[ 8 ] = bc * f + ad;\r\n\r\n			te[ 1 ] = f;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = - b * e;\r\n\r\n			te[ 2 ] = - d * e;\r\n			te[ 6 ] = ad * f + bc;\r\n			te[ 10 ] = ac - bd * f;\r\n\r\n		} else if ( euler.order === 'XZY' ) {\r\n\r\n			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n			te[ 0 ] = c * e;\r\n			te[ 4 ] = - f;\r\n			te[ 8 ] = d * e;\r\n\r\n			te[ 1 ] = ac * f + bd;\r\n			te[ 5 ] = a * e;\r\n			te[ 9 ] = ad * f - bc;\r\n\r\n			te[ 2 ] = bc * f - ad;\r\n			te[ 6 ] = b * e;\r\n			te[ 10 ] = bd * f + ac;\r\n\r\n		}\r\n\r\n		// last column\r\n		te[ 3 ] = 0;\r\n		te[ 7 ] = 0;\r\n		te[ 11 ] = 0;\r\n\r\n		// bottom row\r\n		te[ 12 ] = 0;\r\n		te[ 13 ] = 0;\r\n		te[ 14 ] = 0;\r\n		te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setRotationFromQuaternion: function ( q ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\r\n		return this.makeRotationFromQuaternion( q );\r\n\r\n	},\r\n\r\n	makeRotationFromQuaternion: function ( q ) {\r\n\r\n		var te = this.elements;\r\n\r\n		var x = q.x, y = q.y, z = q.z, w = q.w;\r\n		var x2 = x + x, y2 = y + y, z2 = z + z;\r\n		var xx = x * x2, xy = x * y2, xz = x * z2;\r\n		var yy = y * y2, yz = y * z2, zz = z * z2;\r\n		var wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n		te[ 0 ] = 1 - ( yy + zz );\r\n		te[ 4 ] = xy - wz;\r\n		te[ 8 ] = xz + wy;\r\n\r\n		te[ 1 ] = xy + wz;\r\n		te[ 5 ] = 1 - ( xx + zz );\r\n		te[ 9 ] = yz - wx;\r\n\r\n		te[ 2 ] = xz - wy;\r\n		te[ 6 ] = yz + wx;\r\n		te[ 10 ] = 1 - ( xx + yy );\r\n\r\n		// last column\r\n		te[ 3 ] = 0;\r\n		te[ 7 ] = 0;\r\n		te[ 11 ] = 0;\r\n\r\n		// bottom row\r\n		te[ 12 ] = 0;\r\n		te[ 13 ] = 0;\r\n		te[ 14 ] = 0;\r\n		te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	lookAt: function () {\r\n\r\n		var x = new THREE.Vector3();\r\n		var y = new THREE.Vector3();\r\n		var z = new THREE.Vector3();\r\n\r\n		return function ( eye, target, up ) {\r\n\r\n			var te = this.elements;\r\n\r\n			z.subVectors( eye, target ).normalize();\r\n\r\n			if ( z.length() === 0 ) {\r\n\r\n				z.z = 1;\r\n\r\n			}\r\n\r\n			x.crossVectors( up, z ).normalize();\r\n\r\n			if ( x.length() === 0 ) {\r\n\r\n				z.x += 0.0001;\r\n				x.crossVectors( up, z ).normalize();\r\n\r\n			}\r\n\r\n			y.crossVectors( z, x );\r\n\r\n\r\n			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	multiply: function ( m, n ) {\r\n\r\n		if ( n !== undefined ) {\r\n\r\n			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n			return this.multiplyMatrices( m, n );\r\n\r\n		}\r\n\r\n		return this.multiplyMatrices( this, m );\r\n\r\n	},\r\n\r\n	multiplyMatrices: function ( a, b ) {\r\n\r\n		var ae = a.elements;\r\n		var be = b.elements;\r\n		var te = this.elements;\r\n\r\n		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyToArray: function ( a, b, r ) {\r\n\r\n		var te = this.elements;\r\n\r\n		this.multiplyMatrices( a, b );\r\n\r\n		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyScalar: function ( s ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	multiplyVector3: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n		return vector.applyProjection( this );\r\n\r\n	},\r\n\r\n	multiplyVector4: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n		return vector.applyMatrix4( this );\r\n\r\n	},\r\n\r\n	multiplyVector3Array: function ( a ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n		return this.applyToVector3Array( a );\r\n\r\n	},\r\n\r\n	applyToVector3Array: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( array, offset, length ) {\r\n\r\n			if ( offset === undefined ) offset = 0;\r\n			if ( length === undefined ) length = array.length;\r\n\r\n			for ( var i = 0, j = offset, il; i < length; i += 3, j += 3 ) {\r\n\r\n				v1.x = array[ j ];\r\n				v1.y = array[ j + 1 ];\r\n				v1.z = array[ j + 2 ];\r\n\r\n				v1.applyMatrix4( this );\r\n\r\n				array[ j ]     = v1.x;\r\n				array[ j + 1 ] = v1.y;\r\n				array[ j + 2 ] = v1.z;\r\n\r\n			}\r\n\r\n			return array;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateAxis: function ( v ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\r\n		v.transformDirection( this );\r\n\r\n	},\r\n\r\n	crossVector: function ( vector ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n		return vector.applyMatrix4( this );\r\n\r\n	},\r\n\r\n	determinant: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n		//TODO: make this more efficient\r\n		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n		return (\r\n			n41 * (\r\n				+ n14 * n23 * n32\r\n				 - n13 * n24 * n32\r\n				 - n14 * n22 * n33\r\n				 + n12 * n24 * n33\r\n				 + n13 * n22 * n34\r\n				 - n12 * n23 * n34\r\n			) +\r\n			n42 * (\r\n				+ n11 * n23 * n34\r\n				 - n11 * n24 * n33\r\n				 + n14 * n21 * n33\r\n				 - n13 * n21 * n34\r\n				 + n13 * n24 * n31\r\n				 - n14 * n23 * n31\r\n			) +\r\n			n43 * (\r\n				+ n11 * n24 * n32\r\n				 - n11 * n22 * n34\r\n				 - n14 * n21 * n32\r\n				 + n12 * n21 * n34\r\n				 + n14 * n22 * n31\r\n				 - n12 * n24 * n31\r\n			) +\r\n			n44 * (\r\n				- n13 * n22 * n31\r\n				 - n11 * n23 * n32\r\n				 + n11 * n22 * n33\r\n				 + n13 * n21 * n32\r\n				 - n12 * n21 * n33\r\n				 + n12 * n23 * n31\r\n			)\r\n\r\n		);\r\n\r\n	},\r\n\r\n	transpose: function () {\r\n\r\n		var te = this.elements;\r\n		var tmp;\r\n\r\n		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	flattenToArrayOffset: function ( array, offset ) {\r\n\r\n		var te = this.elements;\r\n\r\n		array[ offset     ] = te[ 0 ];\r\n		array[ offset + 1 ] = te[ 1 ];\r\n		array[ offset + 2 ] = te[ 2 ];\r\n		array[ offset + 3 ] = te[ 3 ];\r\n\r\n		array[ offset + 4 ] = te[ 4 ];\r\n		array[ offset + 5 ] = te[ 5 ];\r\n		array[ offset + 6 ] = te[ 6 ];\r\n		array[ offset + 7 ] = te[ 7 ];\r\n\r\n		array[ offset + 8 ]  = te[ 8 ];\r\n		array[ offset + 9 ]  = te[ 9 ];\r\n		array[ offset + 10 ] = te[ 10 ];\r\n		array[ offset + 11 ] = te[ 11 ];\r\n\r\n		array[ offset + 12 ] = te[ 12 ];\r\n		array[ offset + 13 ] = te[ 13 ];\r\n		array[ offset + 14 ] = te[ 14 ];\r\n		array[ offset + 15 ] = te[ 15 ];\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	getPosition: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n			var te = this.elements;\r\n			return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	setPosition: function ( v ) {\r\n\r\n		var te = this.elements;\r\n\r\n		te[ 12 ] = v.x;\r\n		te[ 13 ] = v.y;\r\n		te[ 14 ] = v.z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getInverse: function ( m, throwOnInvertible ) {\r\n\r\n		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n		var te = this.elements;\r\n		var me = m.elements;\r\n\r\n		var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];\r\n		var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];\r\n		var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];\r\n		var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];\r\n\r\n		te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\r\n		te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\r\n		te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\r\n		te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n		te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;\r\n		te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;\r\n		te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;\r\n		te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;\r\n		te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;\r\n		te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;\r\n		te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;\r\n		te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;\r\n		te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;\r\n		te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;\r\n		te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;\r\n		te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;\r\n\r\n		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];\r\n\r\n		if ( det == 0 ) {\r\n\r\n			var msg = \"Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n			if ( throwOnInvertible || false ) {\r\n\r\n				throw new Error( msg );\r\n\r\n			} else {\r\n\r\n				console.warn( msg );\r\n\r\n			}\r\n\r\n			this.identity();\r\n\r\n			return this;\r\n		}\r\n\r\n		this.multiplyScalar( 1 / det );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( v ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .translate() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateX: function ( angle ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateY: function ( angle ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateZ: function ( angle ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\r\n	},\r\n\r\n	rotateByAxis: function ( axis, angle ) {\r\n\r\n		console.warn( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\r\n	},\r\n\r\n	scale: function ( v ) {\r\n\r\n		var te = this.elements;\r\n		var x = v.x, y = v.y, z = v.z;\r\n\r\n		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	getMaxScaleOnAxis: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );\r\n\r\n	},\r\n\r\n	makeTranslation: function ( x, y, z ) {\r\n\r\n		this.set(\r\n\r\n			1, 0, 0, x,\r\n			0, 1, 0, y,\r\n			0, 0, 1, z,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationX: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			1, 0,  0, 0,\r\n			0, c, - s, 0,\r\n			0, s,  c, 0,\r\n			0, 0,  0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationY: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			 c, 0, s, 0,\r\n			 0, 1, 0, 0,\r\n			- s, 0, c, 0,\r\n			 0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationZ: function ( theta ) {\r\n\r\n		var c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n		this.set(\r\n\r\n			c, - s, 0, 0,\r\n			s,  c, 0, 0,\r\n			0,  0, 1, 0,\r\n			0,  0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makeRotationAxis: function ( axis, angle ) {\r\n\r\n		// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n		var c = Math.cos( angle );\r\n		var s = Math.sin( angle );\r\n		var t = 1 - c;\r\n		var x = axis.x, y = axis.y, z = axis.z;\r\n		var tx = t * x, ty = t * y;\r\n\r\n		this.set(\r\n\r\n			tx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n			tx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		 return this;\r\n\r\n	},\r\n\r\n	makeScale: function ( x, y, z ) {\r\n\r\n		this.set(\r\n\r\n			x, 0, 0, 0,\r\n			0, y, 0, 0,\r\n			0, 0, z, 0,\r\n			0, 0, 0, 1\r\n\r\n		);\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	compose: function ( position, quaternion, scale ) {\r\n\r\n		this.makeRotationFromQuaternion( quaternion );\r\n		this.scale( scale );\r\n		this.setPosition( position );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	decompose: function () {\r\n\r\n		var vector = new THREE.Vector3();\r\n		var matrix = new THREE.Matrix4();\r\n\r\n		return function ( position, quaternion, scale ) {\r\n\r\n			var te = this.elements;\r\n\r\n			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n			// if determine is negative, we need to invert one scale\r\n			var det = this.determinant();\r\n			if ( det < 0 ) {\r\n				sx = - sx;\r\n			}\r\n\r\n			position.x = te[ 12 ];\r\n			position.y = te[ 13 ];\r\n			position.z = te[ 14 ];\r\n\r\n			// scale the rotation part\r\n\r\n			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n			var invSX = 1 / sx;\r\n			var invSY = 1 / sy;\r\n			var invSZ = 1 / sz;\r\n\r\n			matrix.elements[ 0 ] *= invSX;\r\n			matrix.elements[ 1 ] *= invSX;\r\n			matrix.elements[ 2 ] *= invSX;\r\n\r\n			matrix.elements[ 4 ] *= invSY;\r\n			matrix.elements[ 5 ] *= invSY;\r\n			matrix.elements[ 6 ] *= invSY;\r\n\r\n			matrix.elements[ 8 ] *= invSZ;\r\n			matrix.elements[ 9 ] *= invSZ;\r\n			matrix.elements[ 10 ] *= invSZ;\r\n\r\n			quaternion.setFromRotationMatrix( matrix );\r\n\r\n			scale.x = sx;\r\n			scale.y = sy;\r\n			scale.z = sz;\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	makeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n		var te = this.elements;\r\n		var x = 2 * near / ( right - left );\r\n		var y = 2 * near / ( top - bottom );\r\n\r\n		var a = ( right + left ) / ( right - left );\r\n		var b = ( top + bottom ) / ( top - bottom );\r\n		var c = - ( far + near ) / ( far - near );\r\n		var d = - 2 * far * near / ( far - near );\r\n\r\n		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;\r\n		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;\r\n		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;\r\n		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	makePerspective: function ( fov, aspect, near, far ) {\r\n\r\n		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );\r\n		var ymin = - ymax;\r\n		var xmin = ymin * aspect;\r\n		var xmax = ymax * aspect;\r\n\r\n		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n	},\r\n\r\n	makeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n		var te = this.elements;\r\n		var w = right - left;\r\n		var h = top - bottom;\r\n		var p = far - near;\r\n\r\n		var x = ( right + left ) / w;\r\n		var y = ( top + bottom ) / h;\r\n		var z = ( far + near ) / p;\r\n\r\n		te[ 0 ] = 2 / w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;\r\n		te[ 1 ] = 0;	te[ 5 ] = 2 / h;	te[ 9 ] = 0;	te[ 13 ] = - y;\r\n		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 / p;	te[ 14 ] = - z;\r\n		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	fromArray: function ( array ) {\r\n\r\n		this.elements.set( array );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	toArray: function () {\r\n\r\n		var te = this.elements;\r\n\r\n		return [\r\n			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],\r\n			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],\r\n			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],\r\n			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]\r\n		];\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Matrix4().fromArray( this.elements );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n	constructor: THREE.Ray,\r\n\r\n	set: function ( origin, direction ) {\r\n\r\n		this.origin.copy( origin );\r\n		this.direction.copy( direction );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( ray ) {\r\n\r\n		this.origin.copy( ray.origin );\r\n		this.direction.copy( ray.direction );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	at: function ( t, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n	},\r\n\r\n	recast: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( t ) {\r\n\r\n			this.origin.copy( this.at( t, v1 ) );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	closestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		result.subVectors( point, this.origin );\r\n		var directionDistance = result.dot( this.direction );\r\n\r\n		if ( directionDistance < 0 ) {\r\n\r\n			return result.copy( this.origin );\r\n\r\n		}\r\n\r\n		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n	},\r\n\r\n	distanceToPoint: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( point ) {\r\n\r\n			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n			// point behind the ray\r\n\r\n			if ( directionDistance < 0 ) {\r\n\r\n				return this.origin.distanceTo( point );\r\n\r\n			}\r\n\r\n			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n			return v1.distanceTo( point );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	distanceSqToSegment: function () {\r\n\r\n		var segCenter = new THREE.Vector3();\r\n		var segDir = new THREE.Vector3();\r\n		var diff = new THREE.Vector3();\r\n\r\n		return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n			// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp\r\n			// It returns the min distance between the ray and the segment\r\n			// defined by v0 and v1\r\n			// It can also set two optional targets :\r\n			// - The closest point on the ray\r\n			// - The closest point on the segment\r\n\r\n			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n			segDir.copy( v1 ).sub( v0 ).normalize();\r\n			diff.copy( this.origin ).sub( segCenter );\r\n\r\n			var segExtent = v0.distanceTo( v1 ) * 0.5;\r\n			var a01 = - this.direction.dot( segDir );\r\n			var b0 = diff.dot( this.direction );\r\n			var b1 = - diff.dot( segDir );\r\n			var c = diff.lengthSq();\r\n			var det = Math.abs( 1 - a01 * a01 );\r\n			var s0, s1, sqrDist, extDet;\r\n\r\n			if ( det > 0 ) {\r\n\r\n				// The ray and segment are not parallel.\r\n\r\n				s0 = a01 * b1 - b0;\r\n				s1 = a01 * b0 - b1;\r\n				extDet = segExtent * det;\r\n\r\n				if ( s0 >= 0 ) {\r\n\r\n					if ( s1 >= - extDet ) {\r\n\r\n						if ( s1 <= extDet ) {\r\n\r\n							// region 0\r\n							// Minimum at interior points of ray and segment.\r\n\r\n							var invDet = 1 / det;\r\n							s0 *= invDet;\r\n							s1 *= invDet;\r\n							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n						} else {\r\n\r\n							// region 1\r\n\r\n							s1 = segExtent;\r\n							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						// region 5\r\n\r\n						s1 = - segExtent;\r\n						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					if ( s1 <= - extDet ) {\r\n\r\n						// region 4\r\n\r\n						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					} else if ( s1 <= extDet ) {\r\n\r\n						// region 3\r\n\r\n						s0 = 0;\r\n						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					} else {\r\n\r\n						// region 2\r\n\r\n						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// Ray and segment are parallel.\r\n\r\n				s1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n			}\r\n\r\n			if ( optionalPointOnRay ) {\r\n\r\n				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n			}\r\n\r\n			if ( optionalPointOnSegment ) {\r\n\r\n				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n			}\r\n\r\n			return sqrDist;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	isIntersectionSphere: function ( sphere ) {\r\n\r\n		return this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n	},\r\n\r\n	intersectSphere: function () {\r\n\r\n		// from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( sphere, optionalTarget ) {\r\n\r\n			v1.subVectors( sphere.center, this.origin );\r\n\r\n			var tca = v1.dot( this.direction );\r\n\r\n			var d2 = v1.dot( v1 ) - tca * tca;\r\n\r\n			var radius2 = sphere.radius * sphere.radius;\r\n\r\n			if ( d2 > radius2 ) return null;\r\n\r\n			var thc = Math.sqrt( radius2 - d2 );\r\n\r\n			// t0 = first intersect point - entrance on front of sphere\r\n			var t0 = tca - thc;\r\n\r\n			// t1 = second intersect point - exit point on back of sphere\r\n			var t1 = tca + thc;\r\n\r\n			// test to see if both t0 and t1 are behind the ray - if so, return null\r\n			if ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n			// test to see if t0 is behind the ray:\r\n			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n			// in order to always return an intersect point that is in front of the ray.\r\n			if ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n			// else t0 is in front of the ray, so return the first collision point scaled by t0 \r\n			return this.at( t0, optionalTarget );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	isIntersectionPlane: function ( plane ) {\r\n\r\n		// check if the ray lies on the plane first\r\n\r\n		var distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n		if ( distToPoint === 0 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		var denominator = plane.normal.dot( this.direction );\r\n\r\n		if ( denominator * distToPoint < 0 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		// ray origin is behind the plane (and is pointing behind it)\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	distanceToPlane: function ( plane ) {\r\n\r\n		var denominator = plane.normal.dot( this.direction );\r\n		if ( denominator == 0 ) {\r\n\r\n			// line is coplanar, return origin\r\n			if ( plane.distanceToPoint( this.origin ) == 0 ) {\r\n\r\n				return 0;\r\n\r\n			}\r\n\r\n			// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n			return null;\r\n\r\n		}\r\n\r\n		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n		// Return if the ray never intersects the plane\r\n\r\n		return t >= 0 ? t :  null;\r\n\r\n	},\r\n\r\n	intersectPlane: function ( plane, optionalTarget ) {\r\n\r\n		var t = this.distanceToPlane( plane );\r\n\r\n		if ( t === null ) {\r\n\r\n			return null;\r\n		}\r\n\r\n		return this.at( t, optionalTarget );\r\n\r\n	},\r\n\r\n	isIntersectionBox: function () {\r\n\r\n		var v = new THREE.Vector3();\r\n\r\n		return function ( box ) {\r\n\r\n			return this.intersectBox( box, v ) !== null;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersectBox: function ( box , optionalTarget ) {\r\n\r\n		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/\r\n\r\n		var tmin,tmax,tymin,tymax,tzmin,tzmax;\r\n\r\n		var invdirx = 1 / this.direction.x,\r\n			invdiry = 1 / this.direction.y,\r\n			invdirz = 1 / this.direction.z;\r\n\r\n		var origin = this.origin;\r\n\r\n		if ( invdirx >= 0 ) {\r\n\r\n			tmin = ( box.min.x - origin.x ) * invdirx;\r\n			tmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n		} else {\r\n\r\n			tmin = ( box.max.x - origin.x ) * invdirx;\r\n			tmax = ( box.min.x - origin.x ) * invdirx;\r\n		}\r\n\r\n		if ( invdiry >= 0 ) {\r\n\r\n			tymin = ( box.min.y - origin.y ) * invdiry;\r\n			tymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n		} else {\r\n\r\n			tymin = ( box.max.y - origin.y ) * invdiry;\r\n			tymax = ( box.min.y - origin.y ) * invdiry;\r\n		}\r\n\r\n		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n		// These lines also handle the case where tmin or tmax is NaN\r\n		// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n		if ( invdirz >= 0 ) {\r\n\r\n			tzmin = ( box.min.z - origin.z ) * invdirz;\r\n			tzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n		} else {\r\n\r\n			tzmin = ( box.max.z - origin.z ) * invdirz;\r\n			tzmax = ( box.min.z - origin.z ) * invdirz;\r\n		}\r\n\r\n		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n		//return point closest to the ray (positive side)\r\n\r\n		if ( tmax < 0 ) return null;\r\n\r\n		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n	},\r\n\r\n	intersectTriangle: function () {\r\n\r\n		// Compute the offset origin, edges, and normal.\r\n		var diff = new THREE.Vector3();\r\n		var edge1 = new THREE.Vector3();\r\n		var edge2 = new THREE.Vector3();\r\n		var normal = new THREE.Vector3();\r\n\r\n		return function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp\r\n\r\n			edge1.subVectors( b, a );\r\n			edge2.subVectors( c, a );\r\n			normal.crossVectors( edge1, edge2 );\r\n\r\n			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n			var DdN = this.direction.dot( normal );\r\n			var sign;\r\n\r\n			if ( DdN > 0 ) {\r\n\r\n				if ( backfaceCulling ) return null;\r\n				sign = 1;\r\n\r\n			} else if ( DdN < 0 ) {\r\n\r\n				sign = - 1;\r\n				DdN = - DdN;\r\n\r\n			} else {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			diff.subVectors( this.origin, a );\r\n			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n			// b1 < 0, no intersection\r\n			if ( DdQxE2 < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n			// b2 < 0, no intersection\r\n			if ( DdE1xQ < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// b1+b2 > 1, no intersection\r\n			if ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// Line intersects triangle, check if ray does.\r\n			var QdN = - sign * diff.dot( normal );\r\n\r\n			// t < 0, no intersection\r\n			if ( QdN < 0 ) {\r\n\r\n				return null;\r\n\r\n			}\r\n\r\n			// Ray intersects triangle.\r\n			return this.at( QdN / DdN, optionalTarget );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	applyMatrix4: function ( matrix4 ) {\r\n\r\n		this.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n		this.origin.applyMatrix4( matrix4 );\r\n		this.direction.sub( this.origin );\r\n		this.direction.normalize();\r\n\r\n		return this;\r\n	},\r\n\r\n	equals: function ( ray ) {\r\n\r\n		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Ray().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n	this.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n	this.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n	constructor: THREE.Sphere,\r\n\r\n	set: function ( center, radius ) {\r\n\r\n		this.center.copy( center );\r\n		this.radius = radius;\r\n\r\n		return this;\r\n	},\r\n\r\n	setFromPoints: function () {\r\n\r\n		var box = new THREE.Box3();\r\n\r\n		return function ( points, optionalCenter )  {\r\n\r\n			var center = this.center;\r\n\r\n			if ( optionalCenter !== undefined ) {\r\n\r\n				center.copy( optionalCenter );\r\n\r\n			} else {\r\n\r\n				box.setFromPoints( points ).center( center );\r\n\r\n			}\r\n\r\n			var maxRadiusSq = 0;\r\n\r\n			for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n			}\r\n\r\n			this.radius = Math.sqrt( maxRadiusSq );\r\n\r\n			return this;\r\n\r\n 		};\r\n\r\n	}(),\r\n\r\n	copy: function ( sphere ) {\r\n\r\n		this.center.copy( sphere.center );\r\n		this.radius = sphere.radius;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	empty: function () {\r\n\r\n		return ( this.radius <= 0 );\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return ( point.distanceTo( this.center ) - this.radius );\r\n\r\n	},\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		var radiusSum = this.radius + sphere.radius;\r\n\r\n		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n	},\r\n\r\n	clampPoint: function ( point, optionalTarget ) {\r\n\r\n		var deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		result.copy( point );\r\n\r\n		if ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n			result.sub( this.center ).normalize();\r\n			result.multiplyScalar( this.radius ).add( this.center );\r\n\r\n		}\r\n\r\n		return result;\r\n\r\n	},\r\n\r\n	getBoundingBox: function ( optionalTarget ) {\r\n\r\n		var box = optionalTarget || new THREE.Box3();\r\n\r\n		box.set( this.center, this.center );\r\n		box.expandByScalar( this.radius );\r\n\r\n		return box;\r\n\r\n	},\r\n\r\n	applyMatrix4: function ( matrix ) {\r\n\r\n		this.center.applyMatrix4( matrix );\r\n		this.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.center.add( offset );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( sphere ) {\r\n\r\n		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Sphere().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n	this.planes = [\r\n\r\n		( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n		( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n		( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n		( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n		( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n		( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n	];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n	constructor: THREE.Frustum,\r\n\r\n	set: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		planes[ 0 ].copy( p0 );\r\n		planes[ 1 ].copy( p1 );\r\n		planes[ 2 ].copy( p2 );\r\n		planes[ 3 ].copy( p3 );\r\n		planes[ 4 ].copy( p4 );\r\n		planes[ 5 ].copy( p5 );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( frustum ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			planes[ i ].copy( frustum.planes[ i ] );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromMatrix: function ( m ) {\r\n\r\n		var planes = this.planes;\r\n		var me = m.elements;\r\n		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	intersectsObject: function () {\r\n\r\n		var sphere = new THREE.Sphere();\r\n\r\n		return function ( object ) {\r\n\r\n			var geometry = object.geometry;\r\n\r\n			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n			sphere.copy( geometry.boundingSphere );\r\n			sphere.applyMatrix4( object.matrixWorld );\r\n\r\n			return this.intersectsSphere( sphere );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	intersectsSphere: function ( sphere ) {\r\n\r\n		var planes = this.planes;\r\n		var center = sphere.center;\r\n		var negRadius = - sphere.radius;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			var distance = planes[ i ].distanceToPoint( center );\r\n\r\n			if ( distance < negRadius ) {\r\n\r\n				return false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	intersectsBox: function () {\r\n\r\n		var p1 = new THREE.Vector3(),\r\n			p2 = new THREE.Vector3();\r\n\r\n		return function ( box ) {\r\n\r\n			var planes = this.planes;\r\n\r\n			for ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n				var plane = planes[ i ];\r\n\r\n				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n				var d1 = plane.distanceToPoint( p1 );\r\n				var d2 = plane.distanceToPoint( p2 );\r\n\r\n				// if both outside plane, no intersection\r\n\r\n				if ( d1 < 0 && d2 < 0 ) {\r\n\r\n					return false;\r\n\r\n				}\r\n			}\r\n\r\n			return true;\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		var planes = this.planes;\r\n\r\n		for ( var i = 0; i < 6; i ++ ) {\r\n\r\n			if ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n				return false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Frustum().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n	this.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n	constructor: THREE.Plane,\r\n\r\n	set: function ( normal, constant ) {\r\n\r\n		this.normal.copy( normal );\r\n		this.constant = constant;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setComponents: function ( x, y, z, w ) {\r\n\r\n		this.normal.set( x, y, z );\r\n		this.constant = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n		this.normal.copy( normal );\r\n		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromCoplanarPoints: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n		var v2 = new THREE.Vector3();\r\n\r\n		return function ( a, b, c ) {\r\n\r\n			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n			this.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	copy: function ( plane ) {\r\n\r\n		this.normal.copy( plane.normal );\r\n		this.constant = plane.constant;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	normalize: function () {\r\n\r\n		// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n		var inverseNormalLength = 1.0 / this.normal.length();\r\n		this.normal.multiplyScalar( inverseNormalLength );\r\n		this.constant *= inverseNormalLength;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	negate: function () {\r\n\r\n		this.constant *= - 1;\r\n		this.normal.negate();\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	distanceToPoint: function ( point ) {\r\n\r\n		return this.normal.dot( point ) + this.constant;\r\n\r\n	},\r\n\r\n	distanceToSphere: function ( sphere ) {\r\n\r\n		return this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n	},\r\n\r\n	projectPoint: function ( point, optionalTarget ) {\r\n\r\n		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n	},\r\n\r\n	orthoPoint: function ( point, optionalTarget ) {\r\n\r\n		var perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n	},\r\n\r\n	isIntersectionLine: function ( line ) {\r\n\r\n		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n		var startSign = this.distanceToPoint( line.start );\r\n		var endSign = this.distanceToPoint( line.end );\r\n\r\n		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n	},\r\n\r\n	intersectLine: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( line, optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			var direction = line.delta( v1 );\r\n\r\n			var denominator = this.normal.dot( direction );\r\n\r\n			if ( denominator == 0 ) {\r\n\r\n				// line is coplanar, return origin\r\n				if ( this.distanceToPoint( line.start ) == 0 ) {\r\n\r\n					return result.copy( line.start );\r\n\r\n				}\r\n\r\n				// Unsure if this is the correct method to handle this case.\r\n				return undefined;\r\n\r\n			}\r\n\r\n			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n			if ( t < 0 || t > 1 ) {\r\n\r\n				return undefined;\r\n\r\n			}\r\n\r\n			return result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n\r\n	coplanarPoint: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n	},\r\n\r\n	applyMatrix4: function () {\r\n\r\n		var v1 = new THREE.Vector3();\r\n		var v2 = new THREE.Vector3();\r\n		var m1 = new THREE.Matrix3();\r\n\r\n		return function ( matrix, optionalNormalMatrix ) {\r\n\r\n			// compute new normal based on theory here:\r\n			// http://www.songho.ca/opengl/gl_normaltransform.html\r\n			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );\r\n\r\n			var newCoplanarPoint = this.coplanarPoint( v2 );\r\n			newCoplanarPoint.applyMatrix4( matrix );\r\n\r\n			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translate: function ( offset ) {\r\n\r\n		this.constant = this.constant - offset.dot( this.normal );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	equals: function ( plane ) {\r\n\r\n		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Plane().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n	generateUUID: function () {\r\n\r\n		// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n		var uuid = new Array( 36 );\r\n		var rnd = 0, r;\r\n\r\n		return function () {\r\n\r\n			for ( var i = 0; i < 36; i ++ ) {\r\n\r\n				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {\r\n\r\n					uuid[ i ] = '-';\r\n\r\n				} else if ( i == 14 ) {\r\n\r\n					uuid[ i ] = '4';\r\n\r\n				} else {\r\n\r\n					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n					r = rnd & 0xf;\r\n					rnd = rnd >> 4;\r\n					uuid[ i ] = chars[ ( i == 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n				}\r\n			}\r\n\r\n			return uuid.join( '' );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	// Clamp value to range <a, b>\r\n\r\n	clamp: function ( x, a, b ) {\r\n\r\n		return ( x < a ) ? a : ( ( x > b ) ? b : x );\r\n\r\n	},\r\n\r\n	// Clamp value to range <a, inf)\r\n\r\n	clampBottom: function ( x, a ) {\r\n\r\n		return x < a ? a : x;\r\n\r\n	},\r\n\r\n	// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n	mapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n	},\r\n\r\n	// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n	smoothstep: function ( x, min, max ) {\r\n\r\n		if ( x <= min ) return 0;\r\n		if ( x >= max ) return 1;\r\n\r\n		x = ( x - min ) / ( max - min );\r\n\r\n		return x * x * ( 3 - 2 * x );\r\n\r\n	},\r\n\r\n	smootherstep: function ( x, min, max ) {\r\n\r\n		if ( x <= min ) return 0;\r\n		if ( x >= max ) return 1;\r\n\r\n		x = ( x - min ) / ( max - min );\r\n\r\n		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n	},\r\n\r\n	// Random float from <0, 1> with 16 bits of randomness\r\n	// (standard Math.random() creates repetitive patterns when applied over larger space)\r\n\r\n	random16: function () {\r\n\r\n		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;\r\n\r\n	},\r\n\r\n	// Random integer from <low, high> interval\r\n\r\n	randInt: function ( low, high ) {\r\n\r\n		return Math.floor( this.randFloat( low, high ) );\r\n\r\n	},\r\n\r\n	// Random float from <low, high> interval\r\n\r\n	randFloat: function ( low, high ) {\r\n\r\n		return low + Math.random() * ( high - low );\r\n\r\n	},\r\n\r\n	// Random float from <-range/2, range/2> interval\r\n\r\n	randFloatSpread: function ( range ) {\r\n\r\n		return range * ( 0.5 - Math.random() );\r\n\r\n	},\r\n\r\n	degToRad: function () {\r\n\r\n		var degreeToRadiansFactor = Math.PI / 180;\r\n\r\n		return function ( degrees ) {\r\n\r\n			return degrees * degreeToRadiansFactor;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	radToDeg: function () {\r\n\r\n		var radianToDegreesFactor = 180 / Math.PI;\r\n\r\n		return function ( radians ) {\r\n\r\n			return radians * radianToDegreesFactor;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	isPowerOfTwo: function ( value ) {\r\n\r\n		return ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n	this.points = points;\r\n\r\n	var c = [], v3 = { x: 0, y: 0, z: 0 },\r\n	point, intPoint, weight, w2, w3,\r\n	pa, pb, pc, pd;\r\n\r\n	this.initFromArray = function ( a ) {\r\n\r\n		this.points = [];\r\n\r\n		for ( var i = 0; i < a.length; i ++ ) {\r\n\r\n			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.getPoint = function ( k ) {\r\n\r\n		point = ( this.points.length - 1 ) * k;\r\n		intPoint = Math.floor( point );\r\n		weight = point - intPoint;\r\n\r\n		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n		c[ 1 ] = intPoint;\r\n		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n		pa = this.points[ c[ 0 ] ];\r\n		pb = this.points[ c[ 1 ] ];\r\n		pc = this.points[ c[ 2 ] ];\r\n		pd = this.points[ c[ 3 ] ];\r\n\r\n		w2 = weight * weight;\r\n		w3 = weight * w2;\r\n\r\n		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n		return v3;\r\n\r\n	};\r\n\r\n	this.getControlPointsArray = function () {\r\n\r\n		var i, p, l = this.points.length,\r\n			coords = [];\r\n\r\n		for ( i = 0; i < l; i ++ ) {\r\n\r\n			p = this.points[ i ];\r\n			coords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n		}\r\n\r\n		return coords;\r\n\r\n	};\r\n\r\n	// approximate length by summing linear segments\r\n\r\n	this.getLength = function ( nSubDivisions ) {\r\n\r\n		var i, index, nSamples, position,\r\n			point = 0, intPoint = 0, oldIntPoint = 0,\r\n			oldPosition = new THREE.Vector3(),\r\n			tmpVec = new THREE.Vector3(),\r\n			chunkLengths = [],\r\n			totalLength = 0;\r\n\r\n		// first point has 0 length\r\n\r\n		chunkLengths[ 0 ] = 0;\r\n\r\n		if ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n		nSamples = this.points.length * nSubDivisions;\r\n\r\n		oldPosition.copy( this.points[ 0 ] );\r\n\r\n		for ( i = 1; i < nSamples; i ++ ) {\r\n\r\n			index = i / nSamples;\r\n\r\n			position = this.getPoint( index );\r\n			tmpVec.copy( position );\r\n\r\n			totalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n			oldPosition.copy( position );\r\n\r\n			point = ( this.points.length - 1 ) * index;\r\n			intPoint = Math.floor( point );\r\n\r\n			if ( intPoint != oldIntPoint ) {\r\n\r\n				chunkLengths[ intPoint ] = totalLength;\r\n				oldIntPoint = intPoint;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// last point ends with total length\r\n\r\n		chunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n		return { chunks: chunkLengths, total: totalLength };\r\n\r\n	};\r\n\r\n	this.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n		var i, j,\r\n			index, indexCurrent, indexNext,\r\n			linearDistance, realDistance,\r\n			sampling, position,\r\n			newpoints = [],\r\n			tmpVec = new THREE.Vector3(),\r\n			sl = this.getLength();\r\n\r\n		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n		for ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n			//tmpVec.copy( this.points[ i - 1 ] );\r\n			//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n			sampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n			indexNext = i / ( this.points.length - 1 );\r\n\r\n			for ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n				position = this.getPoint( index );\r\n				newpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n			}\r\n\r\n			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n		}\r\n\r\n		this.points = newpoints;\r\n\r\n	};\r\n\r\n	// Catmull-Rom\r\n\r\n	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n		var v0 = ( p2 - p0 ) * 0.5,\r\n			v1 = ( p3 - p1 ) * 0.5;\r\n\r\n		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://exocortex.com\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n	this.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n	this.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n	this.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n	var v0 = new THREE.Vector3();\r\n\r\n	return function ( a, b, c, optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		result.subVectors( c, b );\r\n		v0.subVectors( a, b );\r\n		result.cross( v0 );\r\n\r\n		var resultLengthSq = result.lengthSq();\r\n		if ( resultLengthSq > 0 ) {\r\n\r\n			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n		}\r\n\r\n		return result.set( 0, 0, 0 );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycoordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n	var v0 = new THREE.Vector3();\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n\r\n	return function ( point, a, b, c, optionalTarget ) {\r\n\r\n		v0.subVectors( c, a );\r\n		v1.subVectors( b, a );\r\n		v2.subVectors( point, a );\r\n\r\n		var dot00 = v0.dot( v0 );\r\n		var dot01 = v0.dot( v1 );\r\n		var dot02 = v0.dot( v2 );\r\n		var dot11 = v1.dot( v1 );\r\n		var dot12 = v1.dot( v2 );\r\n\r\n		var denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		// colinear or singular triangle\r\n		if ( denom == 0 ) {\r\n			// arbitrary location outside of triangle?\r\n			// not sure if this is the best idea, maybe should be returning undefined\r\n			return result.set( - 2, - 1, - 1 );\r\n		}\r\n\r\n		var invDenom = 1 / denom;\r\n		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n		// barycoordinates must always sum to 1\r\n		return result.set( 1 - u - v, v, u );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n\r\n	return function ( point, a, b, c ) {\r\n\r\n		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n	constructor: THREE.Triangle,\r\n\r\n	set: function ( a, b, c ) {\r\n\r\n		this.a.copy( a );\r\n		this.b.copy( b );\r\n		this.c.copy( c );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n		this.a.copy( points[ i0 ] );\r\n		this.b.copy( points[ i1 ] );\r\n		this.c.copy( points[ i2 ] );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	copy: function ( triangle ) {\r\n\r\n		this.a.copy( triangle.a );\r\n		this.b.copy( triangle.b );\r\n		this.c.copy( triangle.c );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	area: function () {\r\n\r\n		var v0 = new THREE.Vector3();\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			v0.subVectors( this.c, this.b );\r\n			v1.subVectors( this.a, this.b );\r\n\r\n			return v0.cross( v1 ).length() * 0.5;\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	midpoint: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n	},\r\n\r\n	normal: function ( optionalTarget ) {\r\n\r\n		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n	},\r\n\r\n	plane: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Plane();\r\n\r\n		return result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n	},\r\n\r\n	barycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n	},\r\n\r\n	containsPoint: function ( point ) {\r\n\r\n		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n	},\r\n\r\n	equals: function ( triangle ) {\r\n\r\n		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.Triangle().copy( this );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n	this.startTime = 0;\r\n	this.oldTime = 0;\r\n	this.elapsedTime = 0;\r\n\r\n	this.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n	constructor: THREE.Clock,\r\n\r\n	start: function () {\r\n\r\n		this.startTime = self.performance !== undefined && self.performance.now !== undefined\r\n					 ? self.performance.now()\r\n					 : Date.now();\r\n\r\n		this.oldTime = this.startTime;\r\n		this.running = true;\r\n	},\r\n\r\n	stop: function () {\r\n\r\n		this.getElapsedTime();\r\n		this.running = false;\r\n\r\n	},\r\n\r\n	getElapsedTime: function () {\r\n\r\n		this.getDelta();\r\n		return this.elapsedTime;\r\n\r\n	},\r\n\r\n	getDelta: function () {\r\n\r\n		var diff = 0;\r\n\r\n		if ( this.autoStart && ! this.running ) {\r\n\r\n			this.start();\r\n\r\n		}\r\n\r\n		if ( this.running ) {\r\n\r\n			var newTime = self.performance !== undefined && self.performance.now !== undefined\r\n					 ? self.performance.now()\r\n					 : Date.now();\r\n\r\n			diff = 0.001 * ( newTime - this.oldTime );\r\n			this.oldTime = newTime;\r\n\r\n			this.elapsedTime += diff;\r\n\r\n		}\r\n\r\n		return diff;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {}\r\n\r\nTHREE.EventDispatcher.prototype = {\r\n\r\n	constructor: THREE.EventDispatcher,\r\n\r\n	apply: function ( object ) {\r\n\r\n		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;\r\n		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;\r\n		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;\r\n		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;\r\n\r\n	},\r\n\r\n	addEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) this._listeners = {};\r\n\r\n		var listeners = this._listeners;\r\n\r\n		if ( listeners[ type ] === undefined ) {\r\n\r\n			listeners[ type ] = [];\r\n\r\n		}\r\n\r\n		if ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n			listeners[ type ].push( listener );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	hasEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) return false;\r\n\r\n		var listeners = this._listeners;\r\n\r\n		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n			return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	removeEventListener: function ( type, listener ) {\r\n\r\n		if ( this._listeners === undefined ) return;\r\n\r\n		var listeners = this._listeners;\r\n		var listenerArray = listeners[ type ];\r\n\r\n		if ( listenerArray !== undefined ) {\r\n\r\n			var index = listenerArray.indexOf( listener );\r\n\r\n			if ( index !== - 1 ) {\r\n\r\n				listenerArray.splice( index, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	dispatchEvent: function ( event ) {\r\n\r\n		if ( this._listeners === undefined ) return;\r\n\r\n		var listeners = this._listeners;\r\n		var listenerArray = listeners[ event.type ];\r\n\r\n		if ( listenerArray !== undefined ) {\r\n\r\n			event.target = this;\r\n\r\n			var array = [];\r\n			var length = listenerArray.length;\r\n\r\n			for ( var i = 0; i < length; i ++ ) {\r\n\r\n				array[ i ] = listenerArray[ i ];\r\n\r\n			}\r\n\r\n			for ( var i = 0; i < length; i ++ ) {\r\n\r\n				array[ i ].call( this, event );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://exocortex.com/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n	THREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n		this.ray = new THREE.Ray( origin, direction );\r\n		// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n		this.near = near || 0;\r\n		this.far = far || Infinity;\r\n\r\n		this.params = {\r\n			Sprite: {},\r\n			Mesh: {},\r\n			PointCloud: { threshold: 1 },\r\n			LOD: {},\r\n			Line: {}\r\n		};\r\n\r\n	};\r\n\r\n	var descSort = function ( a, b ) {\r\n\r\n		return a.distance - b.distance;\r\n\r\n	};\r\n\r\n	var intersectObject = function ( object, raycaster, intersects, recursive ) {\r\n\r\n		object.raycast( raycaster, intersects );\r\n\r\n		if ( recursive === true ) {\r\n\r\n			var children = object.children;\r\n\r\n			for ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n				intersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	//\r\n\r\n	THREE.Raycaster.prototype = {\r\n\r\n		constructor: THREE.Raycaster,\r\n\r\n		precision: 0.0001,\r\n		linePrecision: 1,\r\n\r\n		set: function ( origin, direction ) {\r\n\r\n			// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n			this.ray.set( origin, direction );\r\n\r\n		},\r\n\r\n		setFromCamera: function ( coords, camera ) {\r\n\r\n			// camera is assumed _not_ to be a child of a transformed object\r\n\r\n			if ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n				this.ray.origin.copy( camera.position );\r\n				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( camera.position ).normalize();\r\n\r\n			} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n				this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n			} else {\r\n\r\n				console.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n			}\r\n\r\n		},\r\n\r\n		intersectObject: function ( object, recursive ) {\r\n\r\n			var intersects = [];\r\n\r\n			intersectObject( object, this, intersects, recursive );\r\n\r\n			intersects.sort( descSort );\r\n\r\n			return intersects;\r\n\r\n		},\r\n\r\n		intersectObjects: function ( objects, recursive ) {\r\n\r\n			var intersects = [];\r\n\r\n			if ( objects instanceof Array === false ) {\r\n\r\n				console.log( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n				return intersects;\r\n\r\n			}\r\n\r\n			for ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n				intersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n			}\r\n\r\n			intersects.sort( descSort );\r\n\r\n			return intersects;\r\n\r\n		}\r\n\r\n	};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Object3D';\r\n\r\n	this.parent = undefined;\r\n	this.children = [];\r\n\r\n	this.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n	var scope = this;\r\n\r\n	var position = new THREE.Vector3();\r\n	var rotation = new THREE.Euler();\r\n	var quaternion = new THREE.Quaternion();\r\n	var scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n	var onRotationChange = function () {\r\n		quaternion.setFromEuler( rotation, false );\r\n	};\r\n\r\n	var onQuaternionChange = function () {\r\n		rotation.setFromQuaternion( quaternion, undefined, false );\r\n	};\r\n\r\n	rotation.onChange( onRotationChange );\r\n	quaternion.onChange( onQuaternionChange );\r\n\r\n	Object.defineProperties( this, {\r\n		position: {\r\n			enumerable: true,\r\n			value: position\r\n		},\r\n		rotation: {\r\n			enumerable: true,\r\n			value: rotation\r\n		},\r\n		quaternion: {\r\n			enumerable: true,\r\n			value: quaternion\r\n		},\r\n		scale: {\r\n			enumerable: true,\r\n			value: scale\r\n		},\r\n	} );\r\n\r\n	this.rotationAutoUpdate = true;\r\n\r\n	this.matrix = new THREE.Matrix4();\r\n	this.matrixWorld = new THREE.Matrix4();\r\n\r\n	this.matrixAutoUpdate = true;\r\n	this.matrixWorldNeedsUpdate = false;\r\n\r\n	this.visible = true;\r\n\r\n	this.castShadow = false;\r\n	this.receiveShadow = false;\r\n\r\n	this.frustumCulled = true;\r\n\r\n	this.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\r\nTHREE.Object3D.prototype = {\r\n\r\n	constructor: THREE.Object3D,\r\n\r\n	get eulerOrder () {\r\n\r\n		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n		return this.rotation.order;\r\n\r\n	},\r\n\r\n	set eulerOrder ( value ) {\r\n\r\n		console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );\r\n\r\n		this.rotation.order = value;\r\n\r\n	},\r\n\r\n	get useQuaternion () {\r\n\r\n		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n	},\r\n\r\n	set useQuaternion ( value ) {\r\n\r\n		console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\r\n	},\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		this.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n		this.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n	},\r\n\r\n	setRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n		// assumes axis is normalized\r\n\r\n		this.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n	},\r\n\r\n	setRotationFromEuler: function ( euler ) {\r\n\r\n		this.quaternion.setFromEuler( euler, true );\r\n\r\n	},\r\n\r\n	setRotationFromMatrix: function ( m ) {\r\n\r\n		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n		this.quaternion.setFromRotationMatrix( m );\r\n\r\n	},\r\n\r\n	setRotationFromQuaternion: function ( q ) {\r\n\r\n		// assumes q is normalized\r\n\r\n		this.quaternion.copy( q );\r\n\r\n	},\r\n\r\n	rotateOnAxis: function () {\r\n\r\n		// rotate object on axis in object space\r\n		// axis is assumed to be normalized\r\n\r\n		var q1 = new THREE.Quaternion();\r\n\r\n		return function ( axis, angle ) {\r\n\r\n			q1.setFromAxisAngle( axis, angle );\r\n\r\n			this.quaternion.multiply( q1 );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	rotateX: function () {\r\n\r\n		var v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateY: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	rotateZ: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n		return function ( angle ) {\r\n\r\n			return this.rotateOnAxis( v1, angle );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateOnAxis: function () {\r\n\r\n		// translate object by distance along axis in object space\r\n		// axis is assumed to be normalized\r\n\r\n		var v1 = new THREE.Vector3();\r\n\r\n		return function ( axis, distance ) {\r\n\r\n			v1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n			this.position.add( v1.multiplyScalar( distance ) );\r\n\r\n			return this;\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	translate: function ( distance, axis ) {\r\n\r\n		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n		return this.translateOnAxis( axis, distance );\r\n\r\n	},\r\n\r\n	translateX: function () {\r\n\r\n		var v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateY: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	translateZ: function () {\r\n\r\n		var v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n		return function ( distance ) {\r\n\r\n			return this.translateOnAxis( v1, distance );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	localToWorld: function ( vector ) {\r\n\r\n		return vector.applyMatrix4( this.matrixWorld );\r\n\r\n	},\r\n\r\n	worldToLocal: function () {\r\n\r\n		var m1 = new THREE.Matrix4();\r\n\r\n		return function ( vector ) {\r\n\r\n			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	lookAt: function () {\r\n\r\n		// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n		var m1 = new THREE.Matrix4();\r\n\r\n		return function ( vector ) {\r\n\r\n			m1.lookAt( vector, this.position, this.up );\r\n\r\n			this.quaternion.setFromRotationMatrix( m1 );\r\n\r\n		};\r\n\r\n	}(),\r\n\r\n	add: function ( object ) {\r\n\r\n		if ( arguments.length > 1 ) {\r\n\r\n			for ( var i = 0; i < arguments.length; i++ ) {\r\n\r\n				this.add( arguments[ i ] );\r\n\r\n			}\r\n\r\n			return this;\r\n\r\n		};\r\n\r\n		if ( object === this ) {\r\n\r\n			console.error( \"THREE.Object3D.add:\", object, \"can't be added as a child of itself.\" );\r\n			return this;\r\n\r\n		}\r\n\r\n		if ( object instanceof THREE.Object3D ) {\r\n\r\n			if ( object.parent !== undefined ) {\r\n\r\n				object.parent.remove( object );\r\n\r\n			}\r\n\r\n			object.parent = this;\r\n			object.dispatchEvent( { type: 'added' } );\r\n\r\n			this.children.push( object );\r\n\r\n		} else {\r\n\r\n			console.error( \"THREE.Object3D.add:\", object, \"is not an instance of THREE.Object3D.\" );\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	remove: function ( object ) {\r\n\r\n		if ( arguments.length > 1 ) {\r\n\r\n			for ( var i = 0; i < arguments.length; i++ ) {\r\n\r\n				this.remove( arguments[ i ] );\r\n\r\n			}\r\n\r\n		};\r\n\r\n		var index = this.children.indexOf( object );\r\n\r\n		if ( index !== - 1 ) {\r\n\r\n			object.parent = undefined;\r\n\r\n			object.dispatchEvent( { type: 'removed' } );\r\n\r\n			this.children.splice( index, 1 );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	getChildByName: function ( name, recursive ) {\r\n\r\n		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n		return this.getObjectByName( name, recursive );\r\n\r\n	},\r\n\r\n	getObjectById: function ( id, recursive ) {\r\n\r\n		return this.getObjectByProperty( 'id', id, recursive );\r\n\r\n	},\r\n\r\n	getObjectByName: function ( name, recursive ) {\r\n\r\n		return this.getObjectByProperty( 'name', name, recursive );\r\n\r\n	},\r\n\r\n	getObjectByProperty: function ( name, value, recursive ) {\r\n\r\n		if ( this[ name ] === value ) return this;\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			var child = this.children[ i ];\r\n			var object = child.getObjectByProperty( name, value, recursive );\r\n\r\n			if ( object !== undefined ) {\r\n\r\n				return object;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return undefined;\r\n\r\n	},\r\n\r\n	getWorldPosition: function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		this.updateMatrixWorld( true );\r\n\r\n		return result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n	},\r\n\r\n	getWorldQuaternion: function () {\r\n\r\n		var position = new THREE.Vector3();\r\n		var scale = new THREE.Vector3();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Quaternion();\r\n\r\n			this.updateMatrixWorld( true );\r\n\r\n			this.matrixWorld.decompose( position, result, scale );\r\n\r\n			return result;\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	getWorldRotation: function () {\r\n\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Euler();\r\n\r\n			this.getWorldQuaternion( quaternion );\r\n\r\n			return result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	getWorldScale: function () {\r\n\r\n		var position = new THREE.Vector3();\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			this.updateMatrixWorld( true );\r\n\r\n			this.matrixWorld.decompose( position, quaternion, result );\r\n\r\n			return result;\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	getWorldDirection: function () {\r\n\r\n		var quaternion = new THREE.Quaternion();\r\n\r\n		return function ( optionalTarget ) {\r\n\r\n			var result = optionalTarget || new THREE.Vector3();\r\n\r\n			this.getWorldQuaternion( quaternion );\r\n\r\n			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	raycast: function () {},\r\n\r\n	traverse: function ( callback ) {\r\n\r\n		callback( this );\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			this.children[ i ].traverse( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	traverseVisible: function ( callback ) {\r\n\r\n		if ( this.visible === false ) return;\r\n\r\n		callback( this );\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			this.children[ i ].traverseVisible( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	traverseAncestors: function ( callback ) {\r\n\r\n		if ( this.parent ) {\r\n\r\n			callback( this.parent );\r\n\r\n			this.parent.traverseAncestors( callback );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	updateMatrix: function () {\r\n\r\n		this.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n		this.matrixWorldNeedsUpdate = true;\r\n\r\n	},\r\n\r\n	updateMatrixWorld: function ( force ) {\r\n\r\n		if ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n		if ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n			if ( this.parent === undefined ) {\r\n\r\n				this.matrixWorld.copy( this.matrix );\r\n\r\n			} else {\r\n\r\n				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n			}\r\n\r\n			this.matrixWorldNeedsUpdate = false;\r\n\r\n			force = true;\r\n\r\n		}\r\n\r\n		// update children\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			this.children[ i ].updateMatrixWorld( force );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.3,\r\n				type: 'Object',\r\n				generator: 'ObjectExporter'\r\n			}\r\n		};\r\n\r\n		//\r\n\r\n		var geometries = {};\r\n\r\n		var parseGeometry = function ( geometry ) {\r\n\r\n			if ( output.geometries === undefined ) {\r\n\r\n				output.geometries = [];\r\n\r\n			}\r\n\r\n			if ( geometries[ geometry.uuid ] === undefined ) {\r\n\r\n				var json = geometry.toJSON();\r\n\r\n				delete json.metadata;\r\n\r\n				geometries[ geometry.uuid ] = json;\r\n\r\n				output.geometries.push( json );\r\n\r\n			}\r\n\r\n			return geometry.uuid;\r\n\r\n		};\r\n\r\n		//\r\n\r\n		var materials = {};\r\n\r\n		var parseMaterial = function ( material ) {\r\n\r\n			if ( output.materials === undefined ) {\r\n\r\n				output.materials = [];\r\n\r\n			}\r\n\r\n			if ( materials[ material.uuid ] === undefined ) {\r\n\r\n				var json = material.toJSON();\r\n\r\n				delete json.metadata;\r\n\r\n				materials[ material.uuid ] = json;\r\n\r\n				output.materials.push( json );\r\n\r\n			}\r\n\r\n			return material.uuid;\r\n\r\n		};\r\n\r\n		//\r\n\r\n		var parseObject = function ( object ) {\r\n\r\n			var data = {};\r\n\r\n			data.uuid = object.uuid;\r\n			data.type = object.type;\r\n\r\n			if ( object.name !== '' ) data.name = object.name;\r\n			if ( JSON.stringify( object.userData ) !== '{}' ) data.userData = object.userData;\r\n			if ( object.visible !== true ) data.visible = object.visible;\r\n\r\n			if ( object instanceof THREE.PerspectiveCamera ) {\r\n\r\n				data.fov = object.fov;\r\n				data.aspect = object.aspect;\r\n				data.near = object.near;\r\n				data.far = object.far;\r\n\r\n			} else if ( object instanceof THREE.OrthographicCamera ) {\r\n\r\n				data.left = object.left;\r\n				data.right = object.right;\r\n				data.top = object.top;\r\n				data.bottom = object.bottom;\r\n				data.near = object.near;\r\n				data.far = object.far;\r\n\r\n			} else if ( object instanceof THREE.AmbientLight ) {\r\n\r\n				data.color = object.color.getHex();\r\n\r\n			} else if ( object instanceof THREE.DirectionalLight ) {\r\n\r\n				data.color = object.color.getHex();\r\n				data.intensity = object.intensity;\r\n\r\n			} else if ( object instanceof THREE.PointLight ) {\r\n\r\n				data.color = object.color.getHex();\r\n				data.intensity = object.intensity;\r\n				data.distance = object.distance;\r\n\r\n			} else if ( object instanceof THREE.SpotLight ) {\r\n\r\n				data.color = object.color.getHex();\r\n				data.intensity = object.intensity;\r\n				data.distance = object.distance;\r\n				data.angle = object.angle;\r\n				data.exponent = object.exponent;\r\n\r\n			} else if ( object instanceof THREE.HemisphereLight ) {\r\n\r\n				data.color = object.color.getHex();\r\n				data.groundColor = object.groundColor.getHex();\r\n\r\n			} else if ( object instanceof THREE.Mesh ) {\r\n\r\n				data.geometry = parseGeometry( object.geometry );\r\n				data.material = parseMaterial( object.material );\r\n\r\n			} else if ( object instanceof THREE.Line ) {\r\n\r\n				data.geometry = parseGeometry( object.geometry );\r\n				data.material = parseMaterial( object.material );\r\n\r\n			} else if ( object instanceof THREE.Sprite ) {\r\n\r\n				data.material = parseMaterial( object.material );\r\n\r\n			}\r\n\r\n			data.matrix = object.matrix.toArray();\r\n\r\n			if ( object.children.length > 0 ) {\r\n\r\n				data.children = [];\r\n\r\n				for ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n					data.children.push( parseObject( object.children[ i ] ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return data;\r\n\r\n		}\r\n\r\n		output.object = parseObject( this );\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	clone: function ( object, recursive ) {\r\n\r\n		if ( object === undefined ) object = new THREE.Object3D();\r\n		if ( recursive === undefined ) recursive = true;\r\n\r\n		object.name = this.name;\r\n\r\n		object.up.copy( this.up );\r\n\r\n		object.position.copy( this.position );\r\n		object.quaternion.copy( this.quaternion );\r\n		object.scale.copy( this.scale );\r\n\r\n		object.rotationAutoUpdate = this.rotationAutoUpdate;\r\n\r\n		object.matrix.copy( this.matrix );\r\n		object.matrixWorld.copy( this.matrixWorld );\r\n\r\n		object.matrixAutoUpdate = this.matrixAutoUpdate;\r\n		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;\r\n\r\n		object.visible = this.visible;\r\n\r\n		object.castShadow = this.castShadow;\r\n		object.receiveShadow = this.receiveShadow;\r\n\r\n		object.frustumCulled = this.frustumCulled;\r\n\r\n		object.userData = JSON.parse( JSON.stringify( this.userData ) );\r\n\r\n		if ( recursive === true ) {\r\n\r\n			for ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n				var child = this.children[ i ];\r\n				object.add( child.clone() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return object;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n	this.a = a;\r\n	this.b = b;\r\n	this.c = c;\r\n\r\n	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n	this.vertexNormals = normal instanceof Array ? normal : [];\r\n\r\n	this.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n	this.vertexColors = color instanceof Array ? color : [];\r\n\r\n	this.vertexTangents = [];\r\n\r\n	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n	constructor: THREE.Face3,\r\n\r\n	clone: function () {\r\n\r\n		var face = new THREE.Face3( this.a, this.b, this.c );\r\n\r\n		face.normal.copy( this.normal );\r\n		face.color.copy( this.color );\r\n\r\n		face.materialIndex = this.materialIndex;\r\n\r\n		for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {\r\n\r\n			face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {\r\n\r\n			face.vertexColors[ i ] = this.vertexColors[ i ].clone();\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {\r\n\r\n			face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();\r\n\r\n		}\r\n\r\n		return face;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/core/Face4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {\r\n\r\n	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' )\r\n	return new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize ) {\r\n\r\n	this.array = array;\r\n	this.itemSize = itemSize;\r\n\r\n	this.needsUpdate = false;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n	constructor: THREE.BufferAttribute,\r\n\r\n	get length () {\r\n\r\n		return this.array.length;\r\n\r\n	},\r\n\r\n	copyAt: function ( index1, attribute, index2 ) {\r\n\r\n		index1 *= this.itemSize;\r\n		index2 *= attribute.itemSize;\r\n\r\n		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n			this.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n		}\r\n\r\n	},\r\n\r\n	set: function ( value ) {\r\n\r\n		this.array.set( value );\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setX: function ( index, x ) {\r\n\r\n		this.array[ index * this.itemSize ] = x;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setY: function ( index, y ) {\r\n\r\n		this.array[ index * this.itemSize + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setZ: function ( index, z ) {\r\n\r\n		this.array[ index * this.itemSize + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXY: function ( index, x, y ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index     ] = x;\r\n		this.array[ index + 1 ] = y;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZ: function ( index, x, y, z ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index     ] = x;\r\n		this.array[ index + 1 ] = y;\r\n		this.array[ index + 2 ] = z;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	setXYZW: function ( index, x, y, z, w ) {\r\n\r\n		index *= this.itemSize;\r\n\r\n		this.array[ index     ] = x;\r\n		this.array[ index + 1 ] = y;\r\n		this.array[ index + 2 ] = z;\r\n		this.array[ index + 3 ] = w;\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );\r\n\r\n	}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( data, itemSize ) {\r\n\r\n	console.warn( 'THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.' );\r\n	return new THREE.BufferAttribute( data, itemSize );\r\n\r\n};\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'BufferGeometry';\r\n\r\n	this.attributes = {};\r\n	this.attributesKeys = [];\r\n\r\n	this.drawcalls = [];\r\n	this.offsets = this.drawcalls; // backwards compatibility\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n};\r\n\r\nTHREE.BufferGeometry.prototype = {\r\n\r\n	constructor: THREE.BufferGeometry,\r\n\r\n	addAttribute: function ( name, attribute ) {\r\n\r\n		if ( attribute instanceof THREE.BufferAttribute === false ) {\r\n\r\n			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n			this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		this.attributes[ name ] = attribute;\r\n		this.attributesKeys = Object.keys( this.attributes );\r\n\r\n	},\r\n\r\n	getAttribute: function ( name ) {\r\n\r\n		return this.attributes[ name ];\r\n\r\n	},\r\n\r\n	addDrawCall: function ( start, count, indexOffset ) {\r\n\r\n		this.drawcalls.push( {\r\n\r\n			start: start,\r\n			count: count,\r\n			index: indexOffset !== undefined ? indexOffset : 0\r\n\r\n		} );\r\n\r\n	},\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		var position = this.attributes.position;\r\n\r\n		if ( position !== undefined ) {\r\n\r\n			matrix.applyToVector3Array( position.array );\r\n			position.needsUpdate = true;\r\n\r\n		}\r\n\r\n		var normal = this.attributes.normal;\r\n\r\n		if ( normal !== undefined ) {\r\n\r\n			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n			normalMatrix.applyToVector3Array( normal.array );\r\n			normal.needsUpdate = true;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	center: function () {\r\n\r\n		// TODO\r\n\r\n	},\r\n\r\n	fromGeometry: function ( geometry, settings ) {\r\n\r\n		settings = settings || { 'vertexColors': THREE.NoColors };\r\n\r\n		var vertices = geometry.vertices;\r\n		var faces = geometry.faces;\r\n		var faceVertexUvs = geometry.faceVertexUvs;\r\n		var vertexColors = settings.vertexColors;\r\n		var hasFaceVertexUv = faceVertexUvs[ 0 ].length > 0;\r\n		var hasFaceVertexNormals = faces[ 0 ].vertexNormals.length == 3;\r\n\r\n		var positions = new Float32Array( faces.length * 3 * 3 );\r\n		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n		var normals = new Float32Array( faces.length * 3 * 3 );\r\n		this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\r\n		if ( vertexColors !== THREE.NoColors ) {\r\n\r\n			var colors = new Float32Array( faces.length * 3 * 3 );\r\n			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n		}\r\n\r\n		if ( hasFaceVertexUv === true ) {\r\n\r\n			var uvs = new Float32Array( faces.length * 3 * 2 );\r\n			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n		}\r\n\r\n		for ( var i = 0, i2 = 0, i3 = 0; i < faces.length; i ++, i2 += 6, i3 += 9 ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			var a = vertices[ face.a ];\r\n			var b = vertices[ face.b ];\r\n			var c = vertices[ face.c ];\r\n\r\n			positions[ i3     ] = a.x;\r\n			positions[ i3 + 1 ] = a.y;\r\n			positions[ i3 + 2 ] = a.z;\r\n\r\n			positions[ i3 + 3 ] = b.x;\r\n			positions[ i3 + 4 ] = b.y;\r\n			positions[ i3 + 5 ] = b.z;\r\n\r\n			positions[ i3 + 6 ] = c.x;\r\n			positions[ i3 + 7 ] = c.y;\r\n			positions[ i3 + 8 ] = c.z;\r\n\r\n			if ( hasFaceVertexNormals === true ) {\r\n\r\n				var na = face.vertexNormals[ 0 ];\r\n				var nb = face.vertexNormals[ 1 ];\r\n				var nc = face.vertexNormals[ 2 ];\r\n\r\n				normals[ i3     ] = na.x;\r\n				normals[ i3 + 1 ] = na.y;\r\n				normals[ i3 + 2 ] = na.z;\r\n\r\n				normals[ i3 + 3 ] = nb.x;\r\n				normals[ i3 + 4 ] = nb.y;\r\n				normals[ i3 + 5 ] = nb.z;\r\n\r\n				normals[ i3 + 6 ] = nc.x;\r\n				normals[ i3 + 7 ] = nc.y;\r\n				normals[ i3 + 8 ] = nc.z;\r\n\r\n			} else {\r\n\r\n				var n = face.normal;\r\n\r\n				normals[ i3     ] = n.x;\r\n				normals[ i3 + 1 ] = n.y;\r\n				normals[ i3 + 2 ] = n.z;\r\n\r\n				normals[ i3 + 3 ] = n.x;\r\n				normals[ i3 + 4 ] = n.y;\r\n				normals[ i3 + 5 ] = n.z;\r\n\r\n				normals[ i3 + 6 ] = n.x;\r\n				normals[ i3 + 7 ] = n.y;\r\n				normals[ i3 + 8 ] = n.z;\r\n\r\n			}\r\n\r\n			if ( vertexColors === THREE.FaceColors ) {\r\n\r\n				var fc = face.color;\r\n\r\n				colors[ i3     ] = fc.r;\r\n				colors[ i3 + 1 ] = fc.g;\r\n				colors[ i3 + 2 ] = fc.b;\r\n\r\n				colors[ i3 + 3 ] = fc.r;\r\n				colors[ i3 + 4 ] = fc.g;\r\n				colors[ i3 + 5 ] = fc.b;\r\n\r\n				colors[ i3 + 6 ] = fc.r;\r\n				colors[ i3 + 7 ] = fc.g;\r\n				colors[ i3 + 8 ] = fc.b;\r\n\r\n			} else if ( vertexColors === THREE.VertexColors ) {\r\n\r\n				var vca = face.vertexColors[ 0 ];\r\n				var vcb = face.vertexColors[ 1 ];\r\n				var vcc = face.vertexColors[ 2 ];\r\n\r\n				colors[ i3     ] = vca.r;\r\n				colors[ i3 + 1 ] = vca.g;\r\n				colors[ i3 + 2 ] = vca.b;\r\n\r\n				colors[ i3 + 3 ] = vcb.r;\r\n				colors[ i3 + 4 ] = vcb.g;\r\n				colors[ i3 + 5 ] = vcb.b;\r\n\r\n				colors[ i3 + 6 ] = vcc.r;\r\n				colors[ i3 + 7 ] = vcc.g;\r\n				colors[ i3 + 8 ] = vcc.b;\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexUv === true ) {\r\n\r\n				var uva = faceVertexUvs[ 0 ][ i ][ 0 ];\r\n				var uvb = faceVertexUvs[ 0 ][ i ][ 1 ];\r\n				var uvc = faceVertexUvs[ 0 ][ i ][ 2 ];\r\n\r\n				uvs[ i2     ] = uva.x;\r\n				uvs[ i2 + 1 ] = uva.y;\r\n\r\n				uvs[ i2 + 2 ] = uvb.x;\r\n				uvs[ i2 + 3 ] = uvb.y;\r\n\r\n				uvs[ i2 + 4 ] = uvc.x;\r\n				uvs[ i2 + 5 ] = uvc.y;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.computeBoundingSphere()\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	computeBoundingBox: function () {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			if ( this.boundingBox === null ) {\r\n\r\n				this.boundingBox = new THREE.Box3();\r\n\r\n			}\r\n\r\n			var positions = this.attributes.position.array;\r\n\r\n			if ( positions ) {\r\n\r\n				var bb = this.boundingBox;\r\n				bb.makeEmpty();\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n					bb.expandByPoint( vector );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( positions === undefined || positions.length === 0 ) {\r\n\r\n				this.boundingBox.min.set( 0, 0, 0 );\r\n				this.boundingBox.max.set( 0, 0, 0 );\r\n\r\n			}\r\n\r\n			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	computeBoundingSphere: function () {\r\n\r\n		var box = new THREE.Box3();\r\n		var vector = new THREE.Vector3();\r\n\r\n		return function () {\r\n\r\n			if ( this.boundingSphere === null ) {\r\n\r\n				this.boundingSphere = new THREE.Sphere();\r\n\r\n			}\r\n\r\n			var positions = this.attributes.position.array;\r\n\r\n			if ( positions ) {\r\n\r\n				box.makeEmpty();\r\n\r\n				var center = this.boundingSphere.center;\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n					box.expandByPoint( vector );\r\n\r\n				}\r\n\r\n				box.center( center );\r\n\r\n				// hoping to find a boundingSphere with a radius smaller than the\r\n				// boundingSphere of the boundingBox:  sqrt(3) smaller in the best case\r\n\r\n				var maxRadiusSq = 0;\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );\r\n					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n				}\r\n\r\n				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n				if ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.' );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}(),\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		// backwards compatibility\r\n\r\n	},\r\n\r\n	computeVertexNormals: function () {\r\n\r\n		var attributes = this.attributes;\r\n\r\n		if ( attributes.position ) {\r\n\r\n			var positions = attributes.position.array;\r\n\r\n			if ( attributes.normal === undefined ) {\r\n\r\n				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n			} else {\r\n\r\n				// reset existing normals to zero\r\n\r\n				var normals = attributes.normal.array;\r\n\r\n				for ( var i = 0, il = normals.length; i < il; i ++ ) {\r\n\r\n					normals[ i ] = 0;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var normals = attributes.normal.array;\r\n\r\n			var vA, vB, vC,\r\n\r\n			pA = new THREE.Vector3(),\r\n			pB = new THREE.Vector3(),\r\n			pC = new THREE.Vector3(),\r\n\r\n			cb = new THREE.Vector3(),\r\n			ab = new THREE.Vector3();\r\n\r\n			// indexed elements\r\n\r\n			if ( attributes.index ) {\r\n\r\n				var indices = attributes.index.array;\r\n\r\n				var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );\r\n\r\n				for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {\r\n\r\n					var start = offsets[ j ].start;\r\n					var count = offsets[ j ].count;\r\n					var index = offsets[ j ].index;\r\n\r\n					for ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n						vA = ( index + indices[ i     ] ) * 3;\r\n						vB = ( index + indices[ i + 1 ] ) * 3;\r\n						vC = ( index + indices[ i + 2 ] ) * 3;\r\n\r\n						pA.fromArray( positions, vA );\r\n						pB.fromArray( positions, vB );\r\n						pC.fromArray( positions, vC );\r\n\r\n						cb.subVectors( pC, pB );\r\n						ab.subVectors( pA, pB );\r\n						cb.cross( ab );\r\n\r\n						normals[ vA     ] += cb.x;\r\n						normals[ vA + 1 ] += cb.y;\r\n						normals[ vA + 2 ] += cb.z;\r\n\r\n						normals[ vB     ] += cb.x;\r\n						normals[ vB + 1 ] += cb.y;\r\n						normals[ vB + 2 ] += cb.z;\r\n\r\n						normals[ vC     ] += cb.x;\r\n						normals[ vC + 1 ] += cb.y;\r\n						normals[ vC + 2 ] += cb.z;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// non-indexed elements (unconnected triangle soup)\r\n\r\n				for ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n					pA.fromArray( positions, i );\r\n					pB.fromArray( positions, i + 3 );\r\n					pC.fromArray( positions, i + 6 );\r\n\r\n					cb.subVectors( pC, pB );\r\n					ab.subVectors( pA, pB );\r\n					cb.cross( ab );\r\n\r\n					normals[ i     ] = cb.x;\r\n					normals[ i + 1 ] = cb.y;\r\n					normals[ i + 2 ] = cb.z;\r\n\r\n					normals[ i + 3 ] = cb.x;\r\n					normals[ i + 4 ] = cb.y;\r\n					normals[ i + 5 ] = cb.z;\r\n\r\n					normals[ i + 6 ] = cb.x;\r\n					normals[ i + 7 ] = cb.y;\r\n					normals[ i + 8 ] = cb.z;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			this.normalizeNormals();\r\n\r\n			attributes.normal.needsUpdate = true;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeTangents: function () {\r\n\r\n		// based on http://www.terathon.com/code/tangent.html\r\n		// (per vertex tangents)\r\n\r\n		if ( this.attributes.index === undefined ||\r\n			 this.attributes.position === undefined ||\r\n			 this.attributes.normal === undefined ||\r\n			 this.attributes.uv === undefined ) {\r\n\r\n			console.warn( 'Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );\r\n			return;\r\n\r\n		}\r\n\r\n		var indices = this.attributes.index.array;\r\n		var positions = this.attributes.position.array;\r\n		var normals = this.attributes.normal.array;\r\n		var uvs = this.attributes.uv.array;\r\n\r\n		var nVertices = positions.length / 3;\r\n\r\n		if ( this.attributes.tangent === undefined ) {\r\n\r\n			this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\r\n\r\n		}\r\n\r\n		var tangents = this.attributes.tangent.array;\r\n\r\n		var tan1 = [], tan2 = [];\r\n\r\n		for ( var k = 0; k < nVertices; k ++ ) {\r\n\r\n			tan1[ k ] = new THREE.Vector3();\r\n			tan2[ k ] = new THREE.Vector3();\r\n\r\n		}\r\n\r\n		var vA = new THREE.Vector3(),\r\n			vB = new THREE.Vector3(),\r\n			vC = new THREE.Vector3(),\r\n\r\n			uvA = new THREE.Vector2(),\r\n			uvB = new THREE.Vector2(),\r\n			uvC = new THREE.Vector2(),\r\n\r\n			x1, x2, y1, y2, z1, z2,\r\n			s1, s2, t1, t2, r;\r\n\r\n		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();\r\n\r\n		function handleTriangle( a, b, c ) {\r\n\r\n			vA.fromArray( positions, a * 3 );\r\n			vB.fromArray( positions, b * 3 );\r\n			vC.fromArray( positions, c * 3 );\r\n\r\n			uvA.fromArray( uvs, a * 2 );\r\n			uvB.fromArray( uvs, b * 2 );\r\n			uvC.fromArray( uvs, c * 2 );\r\n\r\n			x1 = vB.x - vA.x;\r\n			x2 = vC.x - vA.x;\r\n\r\n			y1 = vB.y - vA.y;\r\n			y2 = vC.y - vA.y;\r\n\r\n			z1 = vB.z - vA.z;\r\n			z2 = vC.z - vA.z;\r\n\r\n			s1 = uvB.x - uvA.x;\r\n			s2 = uvC.x - uvA.x;\r\n\r\n			t1 = uvB.y - uvA.y;\r\n			t2 = uvC.y - uvA.y;\r\n\r\n			r = 1.0 / ( s1 * t2 - s2 * t1 );\r\n\r\n			sdir.set(\r\n				( t2 * x1 - t1 * x2 ) * r,\r\n				( t2 * y1 - t1 * y2 ) * r,\r\n				( t2 * z1 - t1 * z2 ) * r\r\n			);\r\n\r\n			tdir.set(\r\n				( s1 * x2 - s2 * x1 ) * r,\r\n				( s1 * y2 - s2 * y1 ) * r,\r\n				( s1 * z2 - s2 * z1 ) * r\r\n			);\r\n\r\n			tan1[ a ].add( sdir );\r\n			tan1[ b ].add( sdir );\r\n			tan1[ c ].add( sdir );\r\n\r\n			tan2[ a ].add( tdir );\r\n			tan2[ b ].add( tdir );\r\n			tan2[ c ].add( tdir );\r\n\r\n		}\r\n\r\n		var i, il;\r\n		var j, jl;\r\n		var iA, iB, iC;\r\n\r\n		if ( this.drawcalls.length === 0 ) {\r\n\r\n			this.addDrawCall( 0, indices.length, 0 );\r\n\r\n		}\r\n\r\n		var drawcalls = this.drawcalls;\r\n\r\n		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\r\n			var start = drawcalls[ j ].start;\r\n			var count = drawcalls[ j ].count;\r\n			var index = drawcalls[ j ].index;\r\n\r\n			for ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n				iA = index + indices[ i ];\r\n				iB = index + indices[ i + 1 ];\r\n				iC = index + indices[ i + 2 ];\r\n\r\n				handleTriangle( iA, iB, iC );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();\r\n		var n = new THREE.Vector3(), n2 = new THREE.Vector3();\r\n		var w, t, test;\r\n\r\n		function handleVertex( v ) {\r\n\r\n			n.fromArray( normals, v * 3 );\r\n			n2.copy( n );\r\n\r\n			t = tan1[ v ];\r\n\r\n			// Gram-Schmidt orthogonalize\r\n\r\n			tmp.copy( t );\r\n			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n			// Calculate handedness\r\n\r\n			tmp2.crossVectors( n2, t );\r\n			test = tmp2.dot( tan2[ v ] );\r\n			w = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n			tangents[ v * 4     ] = tmp.x;\r\n			tangents[ v * 4 + 1 ] = tmp.y;\r\n			tangents[ v * 4 + 2 ] = tmp.z;\r\n			tangents[ v * 4 + 3 ] = w;\r\n\r\n		}\r\n\r\n		for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {\r\n\r\n			var start = drawcalls[ j ].start;\r\n			var count = drawcalls[ j ].count;\r\n			var index = drawcalls[ j ].index;\r\n\r\n			for ( i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n				iA = index + indices[ i ];\r\n				iB = index + indices[ i + 1 ];\r\n				iC = index + indices[ i + 2 ];\r\n\r\n				handleVertex( iA );\r\n				handleVertex( iB );\r\n				handleVertex( iC );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	/*\r\n		computeOffsets\r\n		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.\r\n		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.\r\n		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.\r\n		indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.\r\n	*/\r\n	computeOffsets: function ( indexBufferSize ) {\r\n\r\n		var size = indexBufferSize;\r\n		if ( indexBufferSize === undefined )\r\n			size = 65535; //WebGL limits type of index buffer values to 16-bit.\r\n\r\n		var s = Date.now();\r\n\r\n		var indices = this.attributes.index.array;\r\n		var vertices = this.attributes.position.array;\r\n\r\n		var verticesCount = ( vertices.length / 3 );\r\n		var facesCount = ( indices.length / 3 );\r\n\r\n		/*\r\n		console.log(\"Computing buffers in offsets of \"+size+\" -> indices:\"+indices.length+\" vertices:\"+vertices.length);\r\n		console.log(\"Faces to process: \"+(indices.length/3));\r\n		console.log(\"Reordering \"+verticesCount+\" vertices.\");\r\n		*/\r\n\r\n		var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers\r\n		var indexPtr = 0;\r\n		var vertexPtr = 0;\r\n\r\n		var offsets = [ { start:0, count:0, index:0 } ];\r\n		var offset = offsets[ 0 ];\r\n\r\n		var duplicatedVertices = 0;\r\n		var newVerticeMaps = 0;\r\n		var faceVertices = new Int32Array( 6 );\r\n		var vertexMap = new Int32Array( vertices.length );\r\n		var revVertexMap = new Int32Array( vertices.length );\r\n		for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }\r\n\r\n		/*\r\n			Traverse every face and reorder vertices in the proper offsets of 65k.\r\n			We can have more than 65k entries in the index buffer per offset, but only reference 65k values.\r\n		*/\r\n		for ( var findex = 0; findex < facesCount; findex ++ ) {\r\n			newVerticeMaps = 0;\r\n\r\n			for ( var vo = 0; vo < 3; vo ++ ) {\r\n				var vid = indices[ findex * 3 + vo ];\r\n				if ( vertexMap[ vid ] == - 1 ) {\r\n					//Unmapped vertice\r\n					faceVertices[ vo * 2 ] = vid;\r\n					faceVertices[ vo * 2 + 1 ] = - 1;\r\n					newVerticeMaps ++;\r\n				} else if ( vertexMap[ vid ] < offset.index ) {\r\n					//Reused vertices from previous block (duplicate)\r\n					faceVertices[ vo * 2 ] = vid;\r\n					faceVertices[ vo * 2 + 1 ] = - 1;\r\n					duplicatedVertices ++;\r\n				} else {\r\n					//Reused vertice in the current block\r\n					faceVertices[ vo * 2 ] = vid;\r\n					faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];\r\n				}\r\n			}\r\n\r\n			var faceMax = vertexPtr + newVerticeMaps;\r\n			if ( faceMax > ( offset.index + size ) ) {\r\n				var new_offset = { start:indexPtr, count:0, index:vertexPtr };\r\n				offsets.push( new_offset );\r\n				offset = new_offset;\r\n\r\n				//Re-evaluate reused vertices in light of new offset.\r\n				for ( var v = 0; v < 6; v += 2 ) {\r\n					var new_vid = faceVertices[ v + 1 ];\r\n					if ( new_vid > - 1 && new_vid < offset.index )\r\n						faceVertices[ v + 1 ] = - 1;\r\n				}\r\n			}\r\n\r\n			//Reindex the face.\r\n			for ( var v = 0; v < 6; v += 2 ) {\r\n				var vid = faceVertices[ v ];\r\n				var new_vid = faceVertices[ v + 1 ];\r\n\r\n				if ( new_vid === - 1 )\r\n					new_vid = vertexPtr ++;\r\n\r\n				vertexMap[ vid ] = new_vid;\r\n				revVertexMap[ new_vid ] = vid;\r\n				sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit\r\n				offset.count ++;\r\n			}\r\n		}\r\n\r\n		/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */\r\n		this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );\r\n		this.offsets = offsets;\r\n\r\n		/*\r\n		var orderTime = Date.now();\r\n		console.log(\"Reorder time: \"+(orderTime-s)+\"ms\");\r\n		console.log(\"Duplicated \"+duplicatedVertices+\" vertices.\");\r\n		console.log(\"Compute Buffers time: \"+(Date.now()-s)+\"ms\");\r\n		console.log(\"Draw offsets: \"+offsets.length);\r\n		*/\r\n\r\n		return offsets;\r\n\r\n	},\r\n\r\n	merge: function ( geometry, offset ) {\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n			return;\r\n\r\n		}\r\n\r\n		if ( offset === undefined ) offset = 0;\r\n\r\n		var attributes = this.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			if ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n			var attribute1 = attributes[ key ];\r\n			var attributeArray1 = attribute1.array;\r\n\r\n			var attribute2 = geometry.attributes[ key ];\r\n			var attributeArray2 = attribute2.array;\r\n\r\n			var attributeSize = attribute2.itemSize;\r\n\r\n			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n				attributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	normalizeNormals: function () {\r\n\r\n		var normals = this.attributes.normal.array;\r\n\r\n		var x, y, z, n;\r\n\r\n		for ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n			x = normals[ i ];\r\n			y = normals[ i + 1 ];\r\n			z = normals[ i + 2 ];\r\n\r\n			n = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n			normals[ i     ] *= n;\r\n			normals[ i + 1 ] *= n;\r\n			normals[ i + 2 ] *= n;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	/*\r\n		reoderBuffers:\r\n		Reorder attributes based on a new indexBuffer and indexMap.\r\n		indexBuffer - Uint16Array of the new ordered indices.\r\n		indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.\r\n		vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).\r\n	*/\r\n	reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {\r\n\r\n		/* Create a copy of all attributes for reordering. */\r\n		var sortedAttributes = {};\r\n		for ( var attr in this.attributes ) {\r\n			if ( attr == 'index' )\r\n				continue;\r\n			var sourceArray = this.attributes[ attr ].array;\r\n			sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );\r\n		}\r\n\r\n		/* Move attribute positions based on the new index map */\r\n		for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {\r\n			var vid = indexMap[ new_vid ];\r\n			for ( var attr in this.attributes ) {\r\n				if ( attr == 'index' )\r\n					continue;\r\n				var attrArray = this.attributes[ attr ].array;\r\n				var attrSize = this.attributes[ attr ].itemSize;\r\n				var sortedAttr = sortedAttributes[ attr ];\r\n				for ( var k = 0; k < attrSize; k ++ )\r\n					sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];\r\n			}\r\n		}\r\n\r\n		/* Carry the new sorted buffers locally */\r\n		this.attributes[ 'index' ].array = indexBuffer;\r\n		for ( var attr in this.attributes ) {\r\n			if ( attr == 'index' )\r\n				continue;\r\n			this.attributes[ attr ].array = sortedAttributes[ attr ];\r\n			this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;\r\n		}\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.0,\r\n				type: 'BufferGeometry',\r\n				generator: 'BufferGeometryExporter'\r\n			},\r\n			uuid: this.uuid,\r\n			type: this.type,\r\n			data: {\r\n				attributes: {}\r\n			}\r\n		};\r\n\r\n		var attributes = this.attributes;\r\n		var offsets = this.offsets;\r\n		var boundingSphere = this.boundingSphere;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			var attribute = attributes[ key ];\r\n\r\n			var array = [], typeArray = attribute.array;\r\n\r\n			for ( var i = 0, l = typeArray.length; i < l; i ++ ) {\r\n\r\n				array[ i ] = typeArray[ i ];\r\n\r\n			}\r\n\r\n			output.data.attributes[ key ] = {\r\n				itemSize: attribute.itemSize,\r\n				type: attribute.array.constructor.name,\r\n				array: array\r\n			}\r\n\r\n		}\r\n\r\n		if ( offsets.length > 0 ) {\r\n\r\n			output.data.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n		}\r\n\r\n		if ( boundingSphere !== null ) {\r\n\r\n			output.data.boundingSphere = {\r\n				center: boundingSphere.center.toArray(),\r\n				radius: boundingSphere.radius\r\n			}\r\n\r\n		}\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		var geometry = new THREE.BufferGeometry();\r\n\r\n		for ( var attr in this.attributes ) {\r\n\r\n			var sourceAttr = this.attributes[ attr ];\r\n			geometry.addAttribute( attr, sourceAttr.clone() );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {\r\n\r\n			var offset = this.offsets[ i ];\r\n\r\n			geometry.offsets.push( {\r\n\r\n				start: offset.start,\r\n				index: offset.index,\r\n				count: offset.count\r\n\r\n			} );\r\n\r\n		}\r\n\r\n		return geometry;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Geometry';\r\n\r\n	this.vertices = [];\r\n	this.colors = [];  // one-to-one vertex colors, used in Points and Line\r\n\r\n	this.faces = [];\r\n\r\n	this.faceVertexUvs = [ [] ];\r\n\r\n	this.morphTargets = [];\r\n	this.morphColors = [];\r\n	this.morphNormals = [];\r\n\r\n	this.skinWeights = [];\r\n	this.skinIndices = [];\r\n\r\n	this.lineDistances = [];\r\n\r\n	this.boundingBox = null;\r\n	this.boundingSphere = null;\r\n\r\n	this.hasTangents = false;\r\n\r\n	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false\r\n\r\n	// update flags\r\n\r\n	this.verticesNeedUpdate = false;\r\n	this.elementsNeedUpdate = false;\r\n	this.uvsNeedUpdate = false;\r\n	this.normalsNeedUpdate = false;\r\n	this.tangentsNeedUpdate = false;\r\n	this.colorsNeedUpdate = false;\r\n	this.lineDistancesNeedUpdate = false;\r\n\r\n	this.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nTHREE.Geometry.prototype = {\r\n\r\n	constructor: THREE.Geometry,\r\n\r\n	applyMatrix: function ( matrix ) {\r\n\r\n		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n			var vertex = this.vertices[ i ];\r\n			vertex.applyMatrix4( matrix );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n			var face = this.faces[ i ];\r\n			face.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( this.boundingBox instanceof THREE.Box3 ) {\r\n\r\n			this.computeBoundingBox();\r\n\r\n		}\r\n\r\n		if ( this.boundingSphere instanceof THREE.Sphere ) {\r\n\r\n			this.computeBoundingSphere();\r\n\r\n		}\r\n\r\n	},\r\n\r\n	fromBufferGeometry: function ( geometry ) {\r\n\r\n		var scope = this;\r\n\r\n		var attributes = geometry.attributes;\r\n\r\n		var vertices = attributes.position.array;\r\n		var indices = attributes.index !== undefined ? attributes.index.array : undefined;\r\n		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n		var colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\r\n		var tempNormals = [];\r\n		var tempUVs = [];\r\n\r\n		for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {\r\n\r\n			scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n			if ( normals !== undefined ) {\r\n\r\n				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n			}\r\n\r\n			if ( colors !== undefined ) {\r\n\r\n				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n			}\r\n\r\n			if ( uvs !== undefined ) {\r\n\r\n				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var addFace = function ( a, b, c ) {\r\n\r\n			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n			scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );\r\n\r\n			if ( uvs !== undefined ) {\r\n\r\n				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n			}\r\n\r\n		};\r\n\r\n		if ( indices !== undefined ) {\r\n\r\n			for ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n				addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			for ( var i = 0; i < vertices.length / 3; i += 3 ) {\r\n\r\n				addFace( i, i + 1, i + 2 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.computeFaceNormals();\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			this.boundingBox = geometry.boundingBox.clone();\r\n\r\n		}\r\n\r\n		if ( geometry.boundingSphere !== null ) {\r\n\r\n			this.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n		}\r\n\r\n		return this;\r\n\r\n	},\r\n\r\n	center: function () {\r\n\r\n		this.computeBoundingBox();\r\n\r\n		var offset = new THREE.Vector3();\r\n\r\n		offset.addVectors( this.boundingBox.min, this.boundingBox.max );\r\n		offset.multiplyScalar( - 0.5 );\r\n\r\n		this.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );\r\n		this.computeBoundingBox();\r\n\r\n		return offset;\r\n\r\n	},\r\n\r\n	computeFaceNormals: function () {\r\n\r\n		var cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			var face = this.faces[ f ];\r\n\r\n			var vA = this.vertices[ face.a ];\r\n			var vB = this.vertices[ face.b ];\r\n			var vC = this.vertices[ face.c ];\r\n\r\n			cb.subVectors( vC, vB );\r\n			ab.subVectors( vA, vB );\r\n			cb.cross( ab );\r\n\r\n			cb.normalize();\r\n\r\n			face.normal.copy( cb );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeVertexNormals: function ( areaWeighted ) {\r\n\r\n		var v, vl, f, fl, face, vertices;\r\n\r\n		vertices = new Array( this.vertices.length );\r\n\r\n		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n			vertices[ v ] = new THREE.Vector3();\r\n\r\n		}\r\n\r\n		if ( areaWeighted ) {\r\n\r\n			// vertex normals weighted by triangle areas\r\n			// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n			var vA, vB, vC, vD;\r\n			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),\r\n				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				vA = this.vertices[ face.a ];\r\n				vB = this.vertices[ face.b ];\r\n				vC = this.vertices[ face.c ];\r\n\r\n				cb.subVectors( vC, vB );\r\n				ab.subVectors( vA, vB );\r\n				cb.cross( ab );\r\n\r\n				vertices[ face.a ].add( cb );\r\n				vertices[ face.b ].add( cb );\r\n				vertices[ face.c ].add( cb );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				vertices[ face.a ].add( face.normal );\r\n				vertices[ face.b ].add( face.normal );\r\n				vertices[ face.c ].add( face.normal );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n			vertices[ v ].normalize();\r\n\r\n		}\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeMorphNormals: function () {\r\n\r\n		var i, il, f, fl, face;\r\n\r\n		// save original normals\r\n		// - create temp variables on first access\r\n		//   otherwise just copy (for faster repeated calls)\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			if ( ! face.__originalFaceNormal ) {\r\n\r\n				face.__originalFaceNormal = face.normal.clone();\r\n\r\n			} else {\r\n\r\n				face.__originalFaceNormal.copy( face.normal );\r\n\r\n			}\r\n\r\n			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n				if ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n				} else {\r\n\r\n					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// use temp geometry to compute face and vertex normals for each morph\r\n\r\n		var tmpGeo = new THREE.Geometry();\r\n		tmpGeo.faces = this.faces;\r\n\r\n		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n			// create on first access\r\n\r\n			if ( ! this.morphNormals[ i ] ) {\r\n\r\n				this.morphNormals[ i ] = {};\r\n				this.morphNormals[ i ].faceNormals = [];\r\n				this.morphNormals[ i ].vertexNormals = [];\r\n\r\n				var dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n				var faceNormal, vertexNormals;\r\n\r\n				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n					faceNormal = new THREE.Vector3();\r\n					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n					dstNormalsFace.push( faceNormal );\r\n					dstNormalsVertex.push( vertexNormals );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var morphNormals = this.morphNormals[ i ];\r\n\r\n			// set vertices to morph target\r\n\r\n			tmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n			// compute morph normals\r\n\r\n			tmpGeo.computeFaceNormals();\r\n			tmpGeo.computeVertexNormals();\r\n\r\n			// store morph normals\r\n\r\n			var faceNormal, vertexNormals;\r\n\r\n			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n				face = this.faces[ f ];\r\n\r\n				faceNormal = morphNormals.faceNormals[ f ];\r\n				vertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n				faceNormal.copy( face.normal );\r\n\r\n				vertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n				vertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n				vertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore original normals\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			face.normal = face.__originalFaceNormal;\r\n			face.vertexNormals = face.__originalVertexNormals;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeTangents: function () {\r\n\r\n		// based on http://www.terathon.com/code/tangent.html\r\n		// tangents go to vertices\r\n\r\n		var f, fl, v, vl, i, il, vertexIndex,\r\n			face, uv, vA, vB, vC, uvA, uvB, uvC,\r\n			x1, x2, y1, y2, z1, z2,\r\n			s1, s2, t1, t2, r, t, test,\r\n			tan1 = [], tan2 = [],\r\n			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),\r\n			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),\r\n			n = new THREE.Vector3(), w;\r\n\r\n		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n			tan1[ v ] = new THREE.Vector3();\r\n			tan2[ v ] = new THREE.Vector3();\r\n\r\n		}\r\n\r\n		function handleTriangle( context, a, b, c, ua, ub, uc ) {\r\n\r\n			vA = context.vertices[ a ];\r\n			vB = context.vertices[ b ];\r\n			vC = context.vertices[ c ];\r\n\r\n			uvA = uv[ ua ];\r\n			uvB = uv[ ub ];\r\n			uvC = uv[ uc ];\r\n\r\n			x1 = vB.x - vA.x;\r\n			x2 = vC.x - vA.x;\r\n			y1 = vB.y - vA.y;\r\n			y2 = vC.y - vA.y;\r\n			z1 = vB.z - vA.z;\r\n			z2 = vC.z - vA.z;\r\n\r\n			s1 = uvB.x - uvA.x;\r\n			s2 = uvC.x - uvA.x;\r\n			t1 = uvB.y - uvA.y;\r\n			t2 = uvC.y - uvA.y;\r\n\r\n			r = 1.0 / ( s1 * t2 - s2 * t1 );\r\n			sdir.set( ( t2 * x1 - t1 * x2 ) * r,\r\n					  ( t2 * y1 - t1 * y2 ) * r,\r\n					  ( t2 * z1 - t1 * z2 ) * r );\r\n			tdir.set( ( s1 * x2 - s2 * x1 ) * r,\r\n					  ( s1 * y2 - s2 * y1 ) * r,\r\n					  ( s1 * z2 - s2 * z1 ) * r );\r\n\r\n			tan1[ a ].add( sdir );\r\n			tan1[ b ].add( sdir );\r\n			tan1[ c ].add( sdir );\r\n\r\n			tan2[ a ].add( tdir );\r\n			tan2[ b ].add( tdir );\r\n			tan2[ c ].add( tdir );\r\n\r\n		}\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents\r\n\r\n			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );\r\n\r\n		}\r\n\r\n		var faceIndex = [ 'a', 'b', 'c', 'd' ];\r\n\r\n		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n			face = this.faces[ f ];\r\n\r\n			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {\r\n\r\n				n.copy( face.vertexNormals[ i ] );\r\n\r\n				vertexIndex = face[ faceIndex[ i ] ];\r\n\r\n				t = tan1[ vertexIndex ];\r\n\r\n				// Gram-Schmidt orthogonalize\r\n\r\n				tmp.copy( t );\r\n				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\r\n\r\n				// Calculate handedness\r\n\r\n				tmp2.crossVectors( face.vertexNormals[ i ], t );\r\n				test = tmp2.dot( tan2[ vertexIndex ] );\r\n				w = ( test < 0.0 ) ? - 1.0 : 1.0;\r\n\r\n				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.hasTangents = true;\r\n\r\n	},\r\n\r\n	computeLineDistances: function () {\r\n\r\n		var d = 0;\r\n		var vertices = this.vertices;\r\n\r\n		for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n			if ( i > 0 ) {\r\n\r\n				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n			}\r\n\r\n			this.lineDistances[ i ] = d;\r\n\r\n		}\r\n\r\n	},\r\n\r\n	computeBoundingBox: function () {\r\n\r\n		if ( this.boundingBox === null ) {\r\n\r\n			this.boundingBox = new THREE.Box3();\r\n\r\n		}\r\n\r\n		this.boundingBox.setFromPoints( this.vertices );\r\n\r\n	},\r\n\r\n	computeBoundingSphere: function () {\r\n\r\n		if ( this.boundingSphere === null ) {\r\n\r\n			this.boundingSphere = new THREE.Sphere();\r\n\r\n		}\r\n\r\n		this.boundingSphere.setFromPoints( this.vertices );\r\n\r\n	},\r\n\r\n	merge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n		if ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n			return;\r\n\r\n		}\r\n\r\n		var normalMatrix,\r\n		vertexOffset = this.vertices.length,\r\n		vertices1 = this.vertices,\r\n		vertices2 = geometry.vertices,\r\n		faces1 = this.faces,\r\n		faces2 = geometry.faces,\r\n		uvs1 = this.faceVertexUvs[ 0 ],\r\n		uvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n		if ( matrix !== undefined ) {\r\n\r\n			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n		}\r\n\r\n		// vertices\r\n\r\n		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n			var vertex = vertices2[ i ];\r\n\r\n			var vertexCopy = vertex.clone();\r\n\r\n			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n			vertices1.push( vertexCopy );\r\n\r\n		}\r\n\r\n		// faces\r\n\r\n		for ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n			var face = faces2[ i ], faceCopy, normal, color,\r\n			faceVertexNormals = face.vertexNormals,\r\n			faceVertexColors = face.vertexColors;\r\n\r\n			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n			faceCopy.normal.copy( face.normal );\r\n\r\n			if ( normalMatrix !== undefined ) {\r\n\r\n				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n				normal = faceVertexNormals[ j ].clone();\r\n\r\n				if ( normalMatrix !== undefined ) {\r\n\r\n					normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n				}\r\n\r\n				faceCopy.vertexNormals.push( normal );\r\n\r\n			}\r\n\r\n			faceCopy.color.copy( face.color );\r\n\r\n			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n				color = faceVertexColors[ j ];\r\n				faceCopy.vertexColors.push( color.clone() );\r\n\r\n			}\r\n\r\n			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n			faces1.push( faceCopy );\r\n\r\n		}\r\n\r\n		// uvs\r\n\r\n		for ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n			var uv = uvs2[ i ], uvCopy = [];\r\n\r\n			if ( uv === undefined ) {\r\n\r\n				continue;\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n				uvCopy.push( uv[ j ].clone() );\r\n\r\n			}\r\n\r\n			uvs1.push( uvCopy );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	mergeMesh: function ( mesh ) {\r\n\r\n		if ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n			return;\r\n\r\n		}\r\n\r\n		mesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n		this.merge( mesh.geometry, mesh.matrix );\r\n\r\n	},\r\n\r\n	/*\r\n	 * Checks for duplicate vertices with hashmap.\r\n	 * Duplicated vertices are removed\r\n	 * and faces' vertices are updated.\r\n	 */\r\n\r\n	mergeVertices: function () {\r\n\r\n		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)\r\n		var unique = [], changes = [];\r\n\r\n		var v, key;\r\n		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001\r\n		var precision = Math.pow( 10, precisionPoints );\r\n		var i,il, face;\r\n		var indices, k, j, jl, u;\r\n\r\n		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n			v = this.vertices[ i ];\r\n			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n			if ( verticesMap[ key ] === undefined ) {\r\n\r\n				verticesMap[ key ] = i;\r\n				unique.push( this.vertices[ i ] );\r\n				changes[ i ] = unique.length - 1;\r\n\r\n			} else {\r\n\r\n				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n				changes[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n			}\r\n\r\n		};\r\n\r\n\r\n		// if faces are completely degenerate after merging vertices, we\r\n		// have to remove them from the geometry.\r\n		var faceIndicesToRemove = [];\r\n\r\n		for ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n			face = this.faces[ i ];\r\n\r\n			face.a = changes[ face.a ];\r\n			face.b = changes[ face.b ];\r\n			face.c = changes[ face.c ];\r\n\r\n			indices = [ face.a, face.b, face.c ];\r\n\r\n			var dupIndex = - 1;\r\n\r\n			// if any duplicate vertices are found in a Face3\r\n			// we have to remove the face as nothing can be saved\r\n			for ( var n = 0; n < 3; n ++ ) {\r\n				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n					dupIndex = n;\r\n					faceIndicesToRemove.push( i );\r\n					break;\r\n\r\n				}\r\n			}\r\n\r\n		}\r\n\r\n		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n			var idx = faceIndicesToRemove[ i ];\r\n\r\n			this.faces.splice( idx, 1 );\r\n\r\n			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n				this.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// Use unique set of vertices\r\n\r\n		var diff = this.vertices.length - unique.length;\r\n		this.vertices = unique;\r\n		return diff;\r\n\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.0,\r\n				type: 'BufferGeometry',\r\n				generator: 'BufferGeometryExporter'\r\n			},\r\n			uuid: this.uuid,\r\n			type: this.type\r\n		};\r\n\r\n		if ( this.name !== \"\" ) output.name = this.name;\r\n\r\n		if ( this.parameters !== undefined ) {\r\n\r\n			var parameters = this.parameters;\r\n\r\n			for ( var key in parameters ) {\r\n\r\n				if ( parameters[ key ] !== undefined ) output[ key ] = parameters[ key ];\r\n\r\n			}\r\n\r\n			return output;\r\n\r\n		}\r\n\r\n		var vertices = [];\r\n\r\n		for ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n			var vertex = this.vertices[ i ];\r\n			vertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n		}\r\n\r\n		var faces = [];\r\n		var normals = [];\r\n		var normalsHash = {};\r\n		var colors = [];\r\n		var colorsHash = {};\r\n		var uvs = [];\r\n		var uvsHash = {};\r\n\r\n		for ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n			var face = this.faces[ i ];\r\n\r\n			var hasMaterial = false; // face.materialIndex !== undefined;\r\n			var hasFaceUv = false; // deprecated\r\n			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n			var hasFaceNormal = face.normal.length() > 0;\r\n			var hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n			var hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n			var faceType = 0;\r\n\r\n			faceType = setBit( faceType, 0, 0 );\r\n			faceType = setBit( faceType, 1, hasMaterial );\r\n			faceType = setBit( faceType, 2, hasFaceUv );\r\n			faceType = setBit( faceType, 3, hasFaceVertexUv );\r\n			faceType = setBit( faceType, 4, hasFaceNormal );\r\n			faceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n			faceType = setBit( faceType, 6, hasFaceColor );\r\n			faceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n			faces.push( faceType );\r\n			faces.push( face.a, face.b, face.c );\r\n\r\n\r\n			/*\r\n			if ( hasMaterial ) {\r\n\r\n				faces.push( face.materialIndex );\r\n\r\n			}\r\n			*/\r\n\r\n			if ( hasFaceVertexUv ) {\r\n\r\n				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n				faces.push(\r\n					getUvIndex( faceVertexUvs[ 0 ] ),\r\n					getUvIndex( faceVertexUvs[ 1 ] ),\r\n					getUvIndex( faceVertexUvs[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n			if ( hasFaceNormal ) {\r\n\r\n				faces.push( getNormalIndex( face.normal ) );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexNormal ) {\r\n\r\n				var vertexNormals = face.vertexNormals;\r\n\r\n				faces.push(\r\n					getNormalIndex( vertexNormals[ 0 ] ),\r\n					getNormalIndex( vertexNormals[ 1 ] ),\r\n					getNormalIndex( vertexNormals[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n			if ( hasFaceColor ) {\r\n\r\n				faces.push( getColorIndex( face.color ) );\r\n\r\n			}\r\n\r\n			if ( hasFaceVertexColor ) {\r\n\r\n				var vertexColors = face.vertexColors;\r\n\r\n				faces.push(\r\n					getColorIndex( vertexColors[ 0 ] ),\r\n					getColorIndex( vertexColors[ 1 ] ),\r\n					getColorIndex( vertexColors[ 2 ] )\r\n				);\r\n\r\n			}\r\n\r\n		}\r\n\r\n		function setBit( value, position, enabled ) {\r\n\r\n			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );\r\n\r\n		}\r\n\r\n		function getNormalIndex( normal ) {\r\n\r\n			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n			if ( normalsHash[ hash ] !== undefined ) {\r\n\r\n				return normalsHash[ hash ];\r\n\r\n			}\r\n\r\n			normalsHash[ hash ] = normals.length / 3;\r\n			normals.push( normal.x, normal.y, normal.z );\r\n\r\n			return normalsHash[ hash ];\r\n\r\n		}\r\n\r\n		function getColorIndex( color ) {\r\n\r\n			var hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n			if ( colorsHash[ hash ] !== undefined ) {\r\n\r\n				return colorsHash[ hash ];\r\n\r\n			}\r\n\r\n			colorsHash[ hash ] = colors.length;\r\n			colors.push( color.getHex() );\r\n\r\n			return colorsHash[ hash ];\r\n\r\n		}\r\n\r\n		function getUvIndex( uv ) {\r\n\r\n			var hash = uv.x.toString() + uv.y.toString();\r\n\r\n			if ( uvsHash[ hash ] !== undefined ) {\r\n\r\n				return uvsHash[ hash ];\r\n\r\n			}\r\n\r\n			uvsHash[ hash ] = uvs.length / 2;\r\n			uvs.push( uv.x, uv.y );\r\n\r\n			return uvsHash[ hash ];\r\n\r\n		}\r\n\r\n		output.data = {};\r\n\r\n		output.data.vertices = vertices;\r\n		output.data.normals = normals;\r\n		if ( colors.length > 0 ) output.data.colors = colors;\r\n		if ( uvs.length > 0 ) output.data.uvs = [ uvs ]; // temporal backward compatibility\r\n		output.data.faces = faces;\r\n\r\n		//\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		var geometry = new THREE.Geometry();\r\n\r\n		var vertices = this.vertices;\r\n\r\n		for ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n			geometry.vertices.push( vertices[ i ].clone() );\r\n\r\n		}\r\n\r\n		var faces = this.faces;\r\n\r\n		for ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n			geometry.faces.push( faces[ i ].clone() );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n			var faceVertexUvs = this.faceVertexUvs[ i ];\r\n\r\n			if ( geometry.faceVertexUvs[ i ] === undefined ) {\r\n\r\n				geometry.faceVertexUvs[ i ] = [];\r\n\r\n			}\r\n\r\n			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n				var uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n					var uv = uvs[ k ];\r\n\r\n					uvsCopy.push( uv.clone() );\r\n\r\n				}\r\n\r\n				geometry.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return geometry;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Camera';\r\n\r\n	this.matrixWorldInverse = new THREE.Matrix4();\r\n	this.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n	var quaternion = new THREE.Quaternion();\r\n\r\n	return function ( optionalTarget ) {\r\n\r\n		var result = optionalTarget || new THREE.Vector3();\r\n\r\n		this.getWorldQuaternion( quaternion );\r\n\r\n		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n	}\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n	// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n	var m1 = new THREE.Matrix4();\r\n\r\n	return function ( vector ) {\r\n\r\n		m1.lookAt( this.position, vector, this.up );\r\n\r\n		this.quaternion.setFromRotationMatrix( m1 );\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function ( camera ) {\r\n\r\n	if ( camera === undefined ) camera = new THREE.Camera();\r\n\r\n	THREE.Object3D.prototype.clone.call( this, camera );\r\n\r\n	camera.matrixWorldInverse.copy( this.matrixWorldInverse );\r\n	camera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n	return camera;\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *	- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'CubeCamera';\r\n\r\n	var fov = 90, aspect = 1;\r\n\r\n	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPX.up.set( 0, - 1, 0 );\r\n	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n	this.add( cameraPX );\r\n\r\n	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNX.up.set( 0, - 1, 0 );\r\n	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n	this.add( cameraNX );\r\n\r\n	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPY.up.set( 0, 0, 1 );\r\n	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n	this.add( cameraPY );\r\n\r\n	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNY.up.set( 0, 0, - 1 );\r\n	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n	this.add( cameraNY );\r\n\r\n	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraPZ.up.set( 0, - 1, 0 );\r\n	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n	this.add( cameraPZ );\r\n\r\n	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n	cameraNZ.up.set( 0, - 1, 0 );\r\n	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n	this.add( cameraNZ );\r\n\r\n	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );\r\n\r\n	this.updateCubeMap = function ( renderer, scene ) {\r\n\r\n		var renderTarget = this.renderTarget;\r\n		var generateMipmaps = renderTarget.generateMipmaps;\r\n\r\n		renderTarget.generateMipmaps = false;\r\n\r\n		renderTarget.activeCubeFace = 0;\r\n		renderer.render( scene, cameraPX, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 1;\r\n		renderer.render( scene, cameraNX, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 2;\r\n		renderer.render( scene, cameraPY, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 3;\r\n		renderer.render( scene, cameraNY, renderTarget );\r\n\r\n		renderTarget.activeCubeFace = 4;\r\n		renderer.render( scene, cameraPZ, renderTarget );\r\n\r\n		renderTarget.generateMipmaps = generateMipmaps;\r\n\r\n		renderTarget.activeCubeFace = 5;\r\n		renderer.render( scene, cameraNZ, renderTarget );\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n	THREE.Camera.call( this );\r\n\r\n	this.type = 'OrthographicCamera';\r\n\r\n	this.zoom = 1;\r\n\r\n	this.left = left;\r\n	this.right = right;\r\n	this.top = top;\r\n	this.bottom = bottom;\r\n\r\n	this.near = ( near !== undefined ) ? near : 0.1;\r\n	this.far = ( far !== undefined ) ? far : 2000;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;\r\n\r\nTHREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n	var dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n	var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n	var cx = ( this.right + this.left ) / 2;\r\n	var cy = ( this.top + this.bottom ) / 2;\r\n\r\n	this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype.clone = function () {\r\n\r\n	var camera = new THREE.OrthographicCamera();\r\n\r\n	THREE.Camera.prototype.clone.call( this, camera );\r\n\r\n	camera.zoom = this.zoom;\r\n\r\n	camera.left = this.left;\r\n	camera.right = this.right;\r\n	camera.top = this.top;\r\n	camera.bottom = this.bottom;\r\n\r\n	camera.near = this.near;\r\n	camera.far = this.far;\r\n\r\n	camera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n	return camera;\r\n};\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.PerspectiveCamera = function ( fov, aspect, near, far ) {\r\n\r\n	THREE.Camera.call( this );\r\n\r\n	this.type = 'PerspectiveCamera';\r\n\r\n	this.zoom = 1;\r\n\r\n	this.fov = fov !== undefined ? fov : 50;\r\n	this.aspect = aspect !== undefined ? aspect : 1;\r\n	this.near = near !== undefined ? near : 0.1;\r\n	this.far = far !== undefined ? far : 2000;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );\r\nTHREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;\r\n\r\n\r\n/**\r\n * Uses Focal Length (in mm) to estimate and set FOV\r\n * 35mm (fullframe) camera is used if frame size is not specified;\r\n * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {\r\n\r\n	if ( frameHeight === undefined ) frameHeight = 24;\r\n\r\n	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );\r\n	this.updateProjectionMatrix();\r\n\r\n}\r\n\r\n\r\n/**\r\n * Sets an offset in a larger frustum. This is useful for multi-window or\r\n * multi-monitor/multi-machine setups.\r\n *\r\n * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n * the monitors are in grid like this\r\n *\r\n *   +---+---+---+\r\n *   | A | B | C |\r\n *   +---+---+---+\r\n *   | D | E | F |\r\n *   +---+---+---+\r\n *\r\n * then for each monitor you would call it like this\r\n *\r\n *   var w = 1920;\r\n *   var h = 1080;\r\n *   var fullWidth = w * 3;\r\n *   var fullHeight = h * 2;\r\n *\r\n *   --A--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n *   --B--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n *   --C--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n *   --D--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n *   --E--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n *   --F--\r\n *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n *\r\n *   Note there is no reason monitors have to be the same size or in a grid.\r\n */\r\n\r\nTHREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n	this.fullWidth = fullWidth;\r\n	this.fullHeight = fullHeight;\r\n	this.x = x;\r\n	this.y = y;\r\n	this.width = width;\r\n	this.height = height;\r\n\r\n	this.updateProjectionMatrix();\r\n\r\n};\r\n\r\n\r\nTHREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {\r\n\r\n	var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );\r\n\r\n	if ( this.fullWidth ) {\r\n\r\n		var aspect = this.fullWidth / this.fullHeight;\r\n		var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;\r\n		var bottom = - top;\r\n		var left = aspect * bottom;\r\n		var right = aspect * top;\r\n		var width = Math.abs( right - left );\r\n		var height = Math.abs( top - bottom );\r\n\r\n		this.projectionMatrix.makeFrustum(\r\n			left + this.x * width / this.fullWidth,\r\n			left + ( this.x + this.width ) * width / this.fullWidth,\r\n			top - ( this.y + this.height ) * height / this.fullHeight,\r\n			top - this.y * height / this.fullHeight,\r\n			this.near,\r\n			this.far\r\n		);\r\n\r\n	} else {\r\n\r\n		this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype.clone = function () {\r\n\r\n	var camera = new THREE.PerspectiveCamera();\r\n\r\n	THREE.Camera.prototype.clone.call( this, camera );\r\n\r\n	camera.zoom = this.zoom;\r\n\r\n	camera.fov = this.fov;\r\n	camera.aspect = this.aspect;\r\n	camera.near = this.near;\r\n	camera.far = this.far;\r\n\r\n	camera.projectionMatrix.copy( this.projectionMatrix );\r\n\r\n	return camera;\r\n\r\n};\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Light';\r\n	\r\n	this.color = new THREE.Color( color );\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Light.prototype.constructor = THREE.Light;\r\n\r\nTHREE.Light.prototype.clone = function ( light ) {\r\n\r\n	if ( light === undefined ) light = new THREE.Light();\r\n\r\n	THREE.Object3D.prototype.clone.call( this, light );\r\n\r\n	light.color.copy( this.color );\r\n\r\n	return light;\r\n\r\n};\r\n\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'AmbientLight';\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AmbientLight.prototype.constructor = THREE.AmbientLight;\r\n\r\nTHREE.AmbientLight.prototype.clone = function () {\r\n\r\n	var light = new THREE.AmbientLight();\r\n\r\n	THREE.Light.prototype.clone.call( this, light );\r\n\r\n	return light;\r\n\r\n};\r\n\r\n// File:src/lights/AreaLight.js\r\n\r\n/**\r\n * @author MPanknin / http://www.redplant.de/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.AreaLight = function ( color, intensity ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'AreaLight';\r\n\r\n	this.normal = new THREE.Vector3( 0, - 1, 0 );\r\n	this.right = new THREE.Vector3( 1, 0, 0 );\r\n\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n	this.width = 1.0;\r\n	this.height = 1.0;\r\n\r\n	this.constantAttenuation = 1.5;\r\n	this.linearAttenuation = 0.5;\r\n	this.quadraticAttenuation = 0.1;\r\n\r\n};\r\n\r\nTHREE.AreaLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.AreaLight.prototype.constructor = THREE.AreaLight;\r\n\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'DirectionalLight';\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.target = new THREE.Object3D();\r\n\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n	this.castShadow = false;\r\n	this.onlyShadow = false;\r\n\r\n	//\r\n\r\n	this.shadowCameraNear = 50;\r\n	this.shadowCameraFar = 5000;\r\n\r\n	this.shadowCameraLeft = - 500;\r\n	this.shadowCameraRight = 500;\r\n	this.shadowCameraTop = 500;\r\n	this.shadowCameraBottom = - 500;\r\n\r\n	this.shadowCameraVisible = false;\r\n\r\n	this.shadowBias = 0;\r\n	this.shadowDarkness = 0.5;\r\n\r\n	this.shadowMapWidth = 512;\r\n	this.shadowMapHeight = 512;\r\n\r\n	//\r\n\r\n	this.shadowCascade = false;\r\n\r\n	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );\r\n	this.shadowCascadeCount = 2;\r\n\r\n	this.shadowCascadeBias = [ 0, 0, 0 ];\r\n	this.shadowCascadeWidth = [ 512, 512, 512 ];\r\n	this.shadowCascadeHeight = [ 512, 512, 512 ];\r\n\r\n	this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];\r\n	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];\r\n\r\n	this.shadowCascadeArray = [];\r\n\r\n	//\r\n\r\n	this.shadowMap = null;\r\n	this.shadowMapSize = null;\r\n	this.shadowCamera = null;\r\n	this.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;\r\n\r\nTHREE.DirectionalLight.prototype.clone = function () {\r\n\r\n	var light = new THREE.DirectionalLight();\r\n\r\n	THREE.Light.prototype.clone.call( this, light );\r\n\r\n	light.target = this.target.clone();\r\n\r\n	light.intensity = this.intensity;\r\n\r\n	light.castShadow = this.castShadow;\r\n	light.onlyShadow = this.onlyShadow;\r\n\r\n	//\r\n\r\n	light.shadowCameraNear = this.shadowCameraNear;\r\n	light.shadowCameraFar = this.shadowCameraFar;\r\n\r\n	light.shadowCameraLeft = this.shadowCameraLeft;\r\n	light.shadowCameraRight = this.shadowCameraRight;\r\n	light.shadowCameraTop = this.shadowCameraTop;\r\n	light.shadowCameraBottom = this.shadowCameraBottom;\r\n\r\n	light.shadowCameraVisible = this.shadowCameraVisible;\r\n\r\n	light.shadowBias = this.shadowBias;\r\n	light.shadowDarkness = this.shadowDarkness;\r\n\r\n	light.shadowMapWidth = this.shadowMapWidth;\r\n	light.shadowMapHeight = this.shadowMapHeight;\r\n\r\n	//\r\n\r\n	light.shadowCascade = this.shadowCascade;\r\n\r\n	light.shadowCascadeOffset.copy( this.shadowCascadeOffset );\r\n	light.shadowCascadeCount = this.shadowCascadeCount;\r\n\r\n	light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );\r\n	light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );\r\n	light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );\r\n\r\n	light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );\r\n	light.shadowCascadeFarZ  = this.shadowCascadeFarZ.slice( 0 );\r\n\r\n	return light;\r\n\r\n};\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n	THREE.Light.call( this, skyColor );\r\n\r\n	this.type = 'HemisphereLight';\r\n\r\n	this.position.set( 0, 100, 0 );\r\n\r\n	this.groundColor = new THREE.Color( groundColor );\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;\r\n\r\nTHREE.HemisphereLight.prototype.clone = function () {\r\n\r\n	var light = new THREE.HemisphereLight();\r\n\r\n	THREE.Light.prototype.clone.call( this, light );\r\n\r\n	light.groundColor.copy( this.groundColor );\r\n	light.intensity = this.intensity;\r\n\r\n	return light;\r\n\r\n};\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLight = function ( color, intensity, distance ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'PointLight';\r\n\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n	this.distance = ( distance !== undefined ) ? distance : 0;\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.PointLight.prototype.constructor = THREE.PointLight;\r\n\r\nTHREE.PointLight.prototype.clone = function () {\r\n\r\n	var light = new THREE.PointLight();\r\n\r\n	THREE.Light.prototype.clone.call( this, light );\r\n\r\n	light.intensity = this.intensity;\r\n	light.distance = this.distance;\r\n\r\n	return light;\r\n\r\n};\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {\r\n\r\n	THREE.Light.call( this, color );\r\n\r\n	this.type = 'SpotLight';\r\n\r\n	this.position.set( 0, 1, 0 );\r\n	this.target = new THREE.Object3D();\r\n\r\n	this.intensity = ( intensity !== undefined ) ? intensity : 1;\r\n	this.distance = ( distance !== undefined ) ? distance : 0;\r\n	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n	this.exponent = ( exponent !== undefined ) ? exponent : 10;\r\n\r\n	this.castShadow = false;\r\n	this.onlyShadow = false;\r\n\r\n	//\r\n\r\n	this.shadowCameraNear = 50;\r\n	this.shadowCameraFar = 5000;\r\n	this.shadowCameraFov = 50;\r\n\r\n	this.shadowCameraVisible = false;\r\n\r\n	this.shadowBias = 0;\r\n	this.shadowDarkness = 0.5;\r\n\r\n	this.shadowMapWidth = 512;\r\n	this.shadowMapHeight = 512;\r\n\r\n	//\r\n\r\n	this.shadowMap = null;\r\n	this.shadowMapSize = null;\r\n	this.shadowCamera = null;\r\n	this.shadowMatrix = null;\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.create( THREE.Light.prototype );\r\nTHREE.SpotLight.prototype.constructor = THREE.SpotLight;\r\n\r\nTHREE.SpotLight.prototype.clone = function () {\r\n\r\n	var light = new THREE.SpotLight();\r\n\r\n	THREE.Light.prototype.clone.call( this, light );\r\n\r\n	light.target = this.target.clone();\r\n\r\n	light.intensity = this.intensity;\r\n	light.distance = this.distance;\r\n	light.angle = this.angle;\r\n	light.exponent = this.exponent;\r\n\r\n	light.castShadow = this.castShadow;\r\n	light.onlyShadow = this.onlyShadow;\r\n\r\n	//\r\n\r\n	light.shadowCameraNear = this.shadowCameraNear;\r\n	light.shadowCameraFar = this.shadowCameraFar;\r\n	light.shadowCameraFov = this.shadowCameraFov;\r\n\r\n	light.shadowCameraVisible = this.shadowCameraVisible;\r\n\r\n	light.shadowBias = this.shadowBias;\r\n	light.shadowDarkness = this.shadowDarkness;\r\n\r\n	light.shadowMapWidth = this.shadowMapWidth;\r\n	light.shadowMapHeight = this.shadowMapHeight;\r\n\r\n	return light;\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = function () {\r\n\r\n	this.files = {};\r\n\r\n};\r\n\r\nTHREE.Cache.prototype = {\r\n\r\n	constructor: THREE.Cache,\r\n\r\n	add: function ( key, file ) {\r\n\r\n		// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n		this.files[ key ] = file;\r\n\r\n	},\r\n\r\n	get: function ( key ) {\r\n\r\n		// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n		return this.files[ key ];\r\n\r\n	},\r\n\r\n	remove: function ( key ) {\r\n\r\n		delete this.files[ key ];\r\n\r\n	},\r\n\r\n	clear: function () {\r\n\r\n		this.files = {}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function ( showStatus ) {\r\n\r\n	this.showStatus = showStatus;\r\n	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;\r\n\r\n	this.imageLoader = new THREE.ImageLoader();\r\n\r\n	this.onLoadStart = function () {};\r\n	this.onLoadProgress = function () {};\r\n	this.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n	constructor: THREE.Loader,\r\n\r\n	crossOrigin: undefined,\r\n\r\n	addStatusElement: function () {\r\n\r\n		var e = document.createElement( 'div' );\r\n\r\n		e.style.position = 'absolute';\r\n		e.style.right = '0px';\r\n		e.style.top = '0px';\r\n		e.style.fontSize = '0.8em';\r\n		e.style.textAlign = 'left';\r\n		e.style.background = 'rgba(0,0,0,0.25)';\r\n		e.style.color = '#fff';\r\n		e.style.width = '120px';\r\n		e.style.padding = '0.5em 0.5em 0.5em 0.5em';\r\n		e.style.zIndex = 1000;\r\n\r\n		e.innerHTML = 'Loading ...';\r\n\r\n		return e;\r\n\r\n	},\r\n\r\n	updateProgress: function ( progress ) {\r\n\r\n		var message = 'Loaded ';\r\n\r\n		if ( progress.total ) {\r\n\r\n			message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';\r\n\r\n\r\n		} else {\r\n\r\n			message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';\r\n\r\n		}\r\n\r\n		this.statusDomElement.innerHTML = message;\r\n\r\n	},\r\n\r\n	extractUrlBase: function ( url ) {\r\n\r\n		var parts = url.split( '/' );\r\n\r\n		if ( parts.length === 1 ) return './';\r\n\r\n		parts.pop();\r\n\r\n		return parts.join( '/' ) + '/';\r\n\r\n	},\r\n\r\n	initMaterials: function ( materials, texturePath ) {\r\n\r\n		var array = [];\r\n\r\n		for ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n			array[ i ] = this.createMaterial( materials[ i ], texturePath );\r\n\r\n		}\r\n\r\n		return array;\r\n\r\n	},\r\n\r\n	needsTangents: function ( materials ) {\r\n\r\n		for ( var i = 0, il = materials.length; i < il; i ++ ) {\r\n\r\n			var m = materials[ i ];\r\n\r\n			if ( m instanceof THREE.ShaderMaterial ) return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	},\r\n\r\n	createMaterial: function ( m, texturePath ) {\r\n\r\n		var scope = this;\r\n\r\n		function nearest_pow2( n ) {\r\n\r\n			var l = Math.log( n ) / Math.LN2;\r\n			return Math.pow( 2, Math.round(  l ) );\r\n\r\n		}\r\n\r\n		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {\r\n\r\n			var fullPath = texturePath + sourceFile;\r\n\r\n			var texture;\r\n\r\n			var loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n			if ( loader !== null ) {\r\n\r\n				texture = loader.load( fullPath );\r\n\r\n			} else {\r\n\r\n				texture = new THREE.Texture();\r\n\r\n				loader = scope.imageLoader;\r\n				loader.crossOrigin = scope.crossOrigin;\r\n				loader.load( fullPath, function ( image ) {\r\n\r\n					if ( THREE.Math.isPowerOfTwo( image.width ) === false ||\r\n						 THREE.Math.isPowerOfTwo( image.height ) === false ) {\r\n\r\n						var width = nearest_pow2( image.width );\r\n						var height = nearest_pow2( image.height );\r\n\r\n						var canvas = document.createElement( 'canvas' );\r\n						canvas.width = width;\r\n						canvas.height = height;\r\n\r\n						var context = canvas.getContext( '2d' );\r\n						context.drawImage( image, 0, 0, width, height );\r\n\r\n						texture.image = canvas;\r\n\r\n					} else {\r\n\r\n						texture.image = image;\r\n\r\n					}\r\n\r\n					texture.needsUpdate = true;\r\n\r\n				} );\r\n\r\n			}\r\n\r\n			texture.sourceFile = sourceFile;\r\n\r\n			if ( repeat ) {\r\n\r\n				texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );\r\n\r\n				if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n				if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n			}\r\n\r\n			if ( offset ) {\r\n\r\n				texture.offset.set( offset[ 0 ], offset[ 1 ] );\r\n\r\n			}\r\n\r\n			if ( wrap ) {\r\n\r\n				var wrapMap = {\r\n					'repeat': THREE.RepeatWrapping,\r\n					'mirror': THREE.MirroredRepeatWrapping\r\n				}\r\n\r\n				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];\r\n				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];\r\n\r\n			}\r\n\r\n			if ( anisotropy ) {\r\n\r\n				texture.anisotropy = anisotropy;\r\n\r\n			}\r\n\r\n			where[ name ] = texture;\r\n\r\n		}\r\n\r\n		function rgb2hex( rgb ) {\r\n\r\n			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;\r\n\r\n		}\r\n\r\n		// defaults\r\n\r\n		var mtype = 'MeshLambertMaterial';\r\n		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };\r\n\r\n		// parameters from model file\r\n\r\n		if ( m.shading ) {\r\n\r\n			var shading = m.shading.toLowerCase();\r\n\r\n			if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';\r\n			else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';\r\n\r\n		}\r\n\r\n		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {\r\n\r\n			mpars.blending = THREE[ m.blending ];\r\n\r\n		}\r\n\r\n		if ( m.transparent !== undefined || m.opacity < 1.0 ) {\r\n\r\n			mpars.transparent = m.transparent;\r\n\r\n		}\r\n\r\n		if ( m.depthTest !== undefined ) {\r\n\r\n			mpars.depthTest = m.depthTest;\r\n\r\n		}\r\n\r\n		if ( m.depthWrite !== undefined ) {\r\n\r\n			mpars.depthWrite = m.depthWrite;\r\n\r\n		}\r\n\r\n		if ( m.visible !== undefined ) {\r\n\r\n			mpars.visible = m.visible;\r\n\r\n		}\r\n\r\n		if ( m.flipSided !== undefined ) {\r\n\r\n			mpars.side = THREE.BackSide;\r\n\r\n		}\r\n\r\n		if ( m.doubleSided !== undefined ) {\r\n\r\n			mpars.side = THREE.DoubleSide;\r\n\r\n		}\r\n\r\n		if ( m.wireframe !== undefined ) {\r\n\r\n			mpars.wireframe = m.wireframe;\r\n\r\n		}\r\n\r\n		if ( m.vertexColors !== undefined ) {\r\n\r\n			if ( m.vertexColors === 'face' ) {\r\n\r\n				mpars.vertexColors = THREE.FaceColors;\r\n\r\n			} else if ( m.vertexColors ) {\r\n\r\n				mpars.vertexColors = THREE.VertexColors;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// colors\r\n\r\n		if ( m.colorDiffuse ) {\r\n\r\n			mpars.color = rgb2hex( m.colorDiffuse );\r\n\r\n		} else if ( m.DbgColor ) {\r\n\r\n			mpars.color = m.DbgColor;\r\n\r\n		}\r\n\r\n		if ( m.colorSpecular ) {\r\n\r\n			mpars.specular = rgb2hex( m.colorSpecular );\r\n\r\n		}\r\n\r\n		if ( m.colorAmbient ) {\r\n\r\n			mpars.ambient = rgb2hex( m.colorAmbient );\r\n\r\n		}\r\n\r\n		if ( m.colorEmissive ) {\r\n\r\n			mpars.emissive = rgb2hex( m.colorEmissive );\r\n\r\n		}\r\n\r\n		// modifiers\r\n\r\n		if ( m.transparency ) {\r\n\r\n			mpars.opacity = m.transparency;\r\n\r\n		}\r\n\r\n		if ( m.specularCoef ) {\r\n\r\n			mpars.shininess = m.specularCoef;\r\n\r\n		}\r\n\r\n		// textures\r\n\r\n		if ( m.mapDiffuse && texturePath ) {\r\n\r\n			create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\r\n		}\r\n\r\n		if ( m.mapLight && texturePath ) {\r\n\r\n			create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\r\n		}\r\n\r\n		if ( m.mapBump && texturePath ) {\r\n\r\n			create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\r\n		}\r\n\r\n		if ( m.mapNormal && texturePath ) {\r\n\r\n			create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\r\n		}\r\n\r\n		if ( m.mapSpecular && texturePath ) {\r\n\r\n			create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\r\n		}\r\n\r\n		if ( m.mapAlpha && texturePath ) {\r\n\r\n			create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\r\n		}\r\n\r\n		//\r\n\r\n		if ( m.mapBumpScale ) {\r\n\r\n			mpars.bumpScale = m.mapBumpScale;\r\n\r\n		}\r\n\r\n		if ( m.mapNormalFactor ) {\r\n\r\n			mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );\r\n\r\n		}\r\n\r\n		var material = new THREE[ mtype ]( mpars );\r\n\r\n		if ( m.DbgName !== undefined ) material.name = m.DbgName;\r\n\r\n		return material;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n	handlers: [],\r\n\r\n	add: function ( regex, loader ) {\r\n\r\n		this.handlers.push( regex, loader );\r\n\r\n	},\r\n\r\n	get: function ( file ) {\r\n\r\n		for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {\r\n\r\n			var regex = this.handlers[ i ];\r\n			var loader  = this.handlers[ i + 1 ];\r\n\r\n			if ( regex.test( file ) ) {\r\n\r\n				return loader;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return null;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n	this.cache = new THREE.Cache();\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n	constructor: THREE.XHRLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var cached = scope.cache.get( url );\r\n\r\n		if ( cached !== undefined ) {\r\n\r\n			if ( onLoad ) onLoad( cached );\r\n			return;\r\n\r\n		}\r\n\r\n		var request = new XMLHttpRequest();\r\n		request.open( 'GET', url, true );\r\n\r\n		request.addEventListener( 'load', function ( event ) {\r\n\r\n			scope.cache.add( url, this.response );\r\n\r\n			if ( onLoad ) onLoad( this.response );\r\n\r\n			scope.manager.itemEnd( url );\r\n\r\n		}, false );\r\n\r\n		if ( onProgress !== undefined ) {\r\n\r\n			request.addEventListener( 'progress', function ( event ) {\r\n\r\n				onProgress( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		if ( onError !== undefined ) {\r\n\r\n			request.addEventListener( 'error', function ( event ) {\r\n\r\n				onError( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;\r\n		if ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\r\n		request.send( null );\r\n\r\n		scope.manager.itemStart( url );\r\n\r\n	},\r\n\r\n	setResponseType: function ( value ) {\r\n\r\n		this.responseType = value;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n	this.cache = new THREE.Cache();\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n	constructor: THREE.ImageLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var cached = scope.cache.get( url );\r\n\r\n		if ( cached !== undefined ) {\r\n\r\n			onLoad( cached );\r\n			return;\r\n\r\n		}\r\n\r\n		var image = document.createElement( 'img' );\r\n\r\n		if ( onLoad !== undefined ) {\r\n\r\n			image.addEventListener( 'load', function ( event ) {\r\n\r\n				scope.cache.add( url, this );\r\n\r\n				onLoad( this );\r\n				scope.manager.itemEnd( url );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		if ( onProgress !== undefined ) {\r\n\r\n			image.addEventListener( 'progress', function ( event ) {\r\n\r\n				onProgress( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		if ( onError !== undefined ) {\r\n\r\n			image.addEventListener( 'error', function ( event ) {\r\n\r\n				onError( event );\r\n\r\n			}, false );\r\n\r\n		}\r\n\r\n		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n		image.src = url;\r\n\r\n		scope.manager.itemStart( url );\r\n\r\n		return image;\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	}\r\n\r\n}\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( showStatus ) {\r\n\r\n	THREE.Loader.call( this, showStatus );\r\n\r\n	this.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );\r\nTHREE.JSONLoader.prototype.constructor = THREE.JSONLoader;\r\n\r\nTHREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {\r\n\r\n	var scope = this;\r\n\r\n	// todo: unify load API to for easier SceneLoader use\r\n\r\n	texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );\r\n\r\n	this.onLoadStart();\r\n	this.loadAjaxJSON( this, url, callback, texturePath );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {\r\n\r\n	var xhr = new XMLHttpRequest();\r\n\r\n	var length = 0;\r\n\r\n	xhr.onreadystatechange = function () {\r\n\r\n		if ( xhr.readyState === xhr.DONE ) {\r\n\r\n			if ( xhr.status === 200 || xhr.status === 0 ) {\r\n\r\n				if ( xhr.responseText ) {\r\n\r\n					var json = JSON.parse( xhr.responseText );\r\n\r\n					if ( json.metadata !== undefined && json.metadata.type === 'scene' ) {\r\n\r\n						console.error( 'THREE.JSONLoader: \"' + url + '\" seems to be a Scene. Use THREE.SceneLoader instead.' );\r\n						return;\r\n\r\n					}\r\n\r\n					var result = context.parse( json, texturePath );\r\n					callback( result.geometry, result.materials );\r\n\r\n				} else {\r\n\r\n					console.error( 'THREE.JSONLoader: \"' + url + '\" seems to be unreachable or the file is empty.' );\r\n\r\n				}\r\n\r\n				// in context of more complex asset initialization\r\n				// do not block on single failed file\r\n				// maybe should go even one more level up\r\n\r\n				context.onLoadComplete();\r\n\r\n			} else {\r\n\r\n				console.error( 'THREE.JSONLoader: Couldn\\'t load \"' + url + '\" (' + xhr.status + ')' );\r\n\r\n			}\r\n\r\n		} else if ( xhr.readyState === xhr.LOADING ) {\r\n\r\n			if ( callbackProgress ) {\r\n\r\n				if ( length === 0 ) {\r\n\r\n					length = xhr.getResponseHeader( 'Content-Length' );\r\n\r\n				}\r\n\r\n				callbackProgress( { total: length, loaded: xhr.responseText.length } );\r\n\r\n			}\r\n\r\n		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {\r\n\r\n			if ( callbackProgress !== undefined ) {\r\n\r\n				length = xhr.getResponseHeader( 'Content-Length' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	xhr.open( 'GET', url, true );\r\n	xhr.withCredentials = this.withCredentials;\r\n	xhr.send( null );\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype.parse = function ( json, texturePath ) {\r\n\r\n	var scope = this,\r\n	geometry = new THREE.Geometry(),\r\n	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n	parseModel( scale );\r\n\r\n	parseSkin();\r\n	parseMorphing( scale );\r\n\r\n	geometry.computeFaceNormals();\r\n	geometry.computeBoundingSphere();\r\n\r\n	function parseModel( scale ) {\r\n\r\n		function isBitSet( value, position ) {\r\n\r\n			return value & ( 1 << position );\r\n\r\n		}\r\n\r\n		var i, j, fi,\r\n\r\n		offset, zLength,\r\n\r\n		colorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n		type,\r\n		isQuad,\r\n		hasMaterial,\r\n		hasFaceVertexUv,\r\n		hasFaceNormal, hasFaceVertexNormal,\r\n		hasFaceColor, hasFaceVertexColor,\r\n\r\n		vertex, face, faceA, faceB, color, hex, normal,\r\n\r\n		uvLayer, uv, u, v,\r\n\r\n		faces = json.faces,\r\n		vertices = json.vertices,\r\n		normals = json.normals,\r\n		colors = json.colors,\r\n\r\n		nUvLayers = 0;\r\n\r\n		if ( json.uvs !== undefined ) {\r\n\r\n			// disregard empty arrays\r\n\r\n			for ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n				if ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n			}\r\n\r\n			for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n				geometry.faceVertexUvs[ i ] = [];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		offset = 0;\r\n		zLength = vertices.length;\r\n\r\n		while ( offset < zLength ) {\r\n\r\n			vertex = new THREE.Vector3();\r\n\r\n			vertex.x = vertices[ offset ++ ] * scale;\r\n			vertex.y = vertices[ offset ++ ] * scale;\r\n			vertex.z = vertices[ offset ++ ] * scale;\r\n\r\n			geometry.vertices.push( vertex );\r\n\r\n		}\r\n\r\n		offset = 0;\r\n		zLength = faces.length;\r\n\r\n		while ( offset < zLength ) {\r\n\r\n			type = faces[ offset ++ ];\r\n\r\n\r\n			isQuad              = isBitSet( type, 0 );\r\n			hasMaterial         = isBitSet( type, 1 );\r\n			hasFaceVertexUv     = isBitSet( type, 3 );\r\n			hasFaceNormal       = isBitSet( type, 4 );\r\n			hasFaceVertexNormal = isBitSet( type, 5 );\r\n			hasFaceColor	     = isBitSet( type, 6 );\r\n			hasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n			// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n			if ( isQuad ) {\r\n\r\n				faceA = new THREE.Face3();\r\n				faceA.a = faces[ offset ];\r\n				faceA.b = faces[ offset + 1 ];\r\n				faceA.c = faces[ offset + 3 ];\r\n\r\n				faceB = new THREE.Face3();\r\n				faceB.a = faces[ offset + 1 ];\r\n				faceB.b = faces[ offset + 2 ];\r\n				faceB.c = faces[ offset + 3 ];\r\n\r\n				offset += 4;\r\n\r\n				if ( hasMaterial ) {\r\n\r\n					materialIndex = faces[ offset ++ ];\r\n					faceA.materialIndex = materialIndex;\r\n					faceB.materialIndex = materialIndex;\r\n\r\n				}\r\n\r\n				// to get face <=> uv index correspondence\r\n\r\n				fi = geometry.faces.length;\r\n\r\n				if ( hasFaceVertexUv ) {\r\n\r\n					for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n						uvLayer = json.uvs[ i ];\r\n\r\n						geometry.faceVertexUvs[ i ][ fi ] = [];\r\n						geometry.faceVertexUvs[ i ][ fi + 1 ] = []\r\n\r\n						for ( j = 0; j < 4; j ++ ) {\r\n\r\n							uvIndex = faces[ offset ++ ];\r\n\r\n							u = uvLayer[ uvIndex * 2 ];\r\n							v = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n							uv = new THREE.Vector2( u, v );\r\n\r\n							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				if ( hasFaceNormal ) {\r\n\r\n					normalIndex = faces[ offset ++ ] * 3;\r\n\r\n					faceA.normal.set(\r\n						normals[ normalIndex ++ ],\r\n						normals[ normalIndex ++ ],\r\n						normals[ normalIndex ]\r\n					);\r\n\r\n					faceB.normal.copy( faceA.normal );\r\n\r\n				}\r\n\r\n				if ( hasFaceVertexNormal ) {\r\n\r\n					for ( i = 0; i < 4; i ++ ) {\r\n\r\n						normalIndex = faces[ offset ++ ] * 3;\r\n\r\n						normal = new THREE.Vector3(\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ]\r\n						);\r\n\r\n\r\n						if ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n						if ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n					}\r\n\r\n				}\r\n\r\n\r\n				if ( hasFaceColor ) {\r\n\r\n					colorIndex = faces[ offset ++ ];\r\n					hex = colors[ colorIndex ];\r\n\r\n					faceA.color.setHex( hex );\r\n					faceB.color.setHex( hex );\r\n\r\n				}\r\n\r\n\r\n				if ( hasFaceVertexColor ) {\r\n\r\n					for ( i = 0; i < 4; i ++ ) {\r\n\r\n						colorIndex = faces[ offset ++ ];\r\n						hex = colors[ colorIndex ];\r\n\r\n						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n					}\r\n\r\n				}\r\n\r\n				geometry.faces.push( faceA );\r\n				geometry.faces.push( faceB );\r\n\r\n			} else {\r\n\r\n				face = new THREE.Face3();\r\n				face.a = faces[ offset ++ ];\r\n				face.b = faces[ offset ++ ];\r\n				face.c = faces[ offset ++ ];\r\n\r\n				if ( hasMaterial ) {\r\n\r\n					materialIndex = faces[ offset ++ ];\r\n					face.materialIndex = materialIndex;\r\n\r\n				}\r\n\r\n				// to get face <=> uv index correspondence\r\n\r\n				fi = geometry.faces.length;\r\n\r\n				if ( hasFaceVertexUv ) {\r\n\r\n					for ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n						uvLayer = json.uvs[ i ];\r\n\r\n						geometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n						for ( j = 0; j < 3; j ++ ) {\r\n\r\n							uvIndex = faces[ offset ++ ];\r\n\r\n							u = uvLayer[ uvIndex * 2 ];\r\n							v = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n							uv = new THREE.Vector2( u, v );\r\n\r\n							geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				if ( hasFaceNormal ) {\r\n\r\n					normalIndex = faces[ offset ++ ] * 3;\r\n\r\n					face.normal.set(\r\n						normals[ normalIndex ++ ],\r\n						normals[ normalIndex ++ ],\r\n						normals[ normalIndex ]\r\n					);\r\n\r\n				}\r\n\r\n				if ( hasFaceVertexNormal ) {\r\n\r\n					for ( i = 0; i < 3; i ++ ) {\r\n\r\n						normalIndex = faces[ offset ++ ] * 3;\r\n\r\n						normal = new THREE.Vector3(\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ++ ],\r\n							normals[ normalIndex ]\r\n						);\r\n\r\n						face.vertexNormals.push( normal );\r\n\r\n					}\r\n\r\n				}\r\n\r\n\r\n				if ( hasFaceColor ) {\r\n\r\n					colorIndex = faces[ offset ++ ];\r\n					face.color.setHex( colors[ colorIndex ] );\r\n\r\n				}\r\n\r\n\r\n				if ( hasFaceVertexColor ) {\r\n\r\n					for ( i = 0; i < 3; i ++ ) {\r\n\r\n						colorIndex = faces[ offset ++ ];\r\n						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n					}\r\n\r\n				}\r\n\r\n				geometry.faces.push( face );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function parseSkin() {\r\n		var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n		if ( json.skinWeights ) {\r\n\r\n			for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n				var x =                               json.skinWeights[ i     ];\r\n				var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n				var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n				var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( json.skinIndices ) {\r\n\r\n			for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n				var a =                               json.skinIndices[ i     ];\r\n				var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n				var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n				var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		geometry.bones = json.bones;\r\n\r\n		if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n		}\r\n\r\n\r\n		// could change this to json.animations[0] or remove completely\r\n\r\n		geometry.animation = json.animation;\r\n		geometry.animations = json.animations;\r\n\r\n	};\r\n\r\n	function parseMorphing( scale ) {\r\n\r\n		if ( json.morphTargets !== undefined ) {\r\n\r\n			var i, l, v, vl, dstVertices, srcVertices;\r\n\r\n			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n				geometry.morphTargets[ i ] = {};\r\n				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n				geometry.morphTargets[ i ].vertices = [];\r\n\r\n				dstVertices = geometry.morphTargets[ i ].vertices;\r\n				srcVertices = json.morphTargets [ i ].vertices;\r\n\r\n				for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n					var vertex = new THREE.Vector3();\r\n					vertex.x = srcVertices[ v ] * scale;\r\n					vertex.y = srcVertices[ v + 1 ] * scale;\r\n					vertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n					dstVertices.push( vertex );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( json.morphColors !== undefined ) {\r\n\r\n			var i, l, c, cl, dstColors, srcColors, color;\r\n\r\n			for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {\r\n\r\n				geometry.morphColors[ i ] = {};\r\n				geometry.morphColors[ i ].name = json.morphColors[ i ].name;\r\n				geometry.morphColors[ i ].colors = [];\r\n\r\n				dstColors = geometry.morphColors[ i ].colors;\r\n				srcColors = json.morphColors [ i ].colors;\r\n\r\n				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {\r\n\r\n					color = new THREE.Color( 0xffaa00 );\r\n					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );\r\n					dstColors.push( color );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	if ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n		return { geometry: geometry };\r\n\r\n	} else {\r\n\r\n		var materials = this.initMaterials( json.materials, texturePath );\r\n\r\n		if ( this.needsTangents( materials ) ) {\r\n\r\n			geometry.computeTangents();\r\n\r\n		}\r\n\r\n		return { geometry: geometry, materials: materials };\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n	var scope = this;\r\n\r\n	var loaded = 0, total = 0;\r\n\r\n	this.onLoad = onLoad;\r\n	this.onProgress = onProgress;\r\n	this.onError = onError;\r\n\r\n	this.itemStart = function ( url ) {\r\n\r\n		total ++;\r\n\r\n	};\r\n\r\n	this.itemEnd = function ( url ) {\r\n\r\n		loaded ++;\r\n\r\n		if ( scope.onProgress !== undefined ) {\r\n\r\n			scope.onProgress( url, loaded, total );\r\n\r\n		}\r\n\r\n		if ( loaded === total && scope.onLoad !== undefined ) {\r\n\r\n			scope.onLoad();\r\n\r\n		}\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n	constructor: THREE.BufferGeometryLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	parse: function ( json ) {\r\n\r\n		var geometry = new THREE.BufferGeometry();\r\n\r\n		var attributes = json.attributes;\r\n\r\n		for ( var key in attributes ) {\r\n\r\n			var attribute = attributes[ key ];\r\n			var typedArray = new self[ attribute.type ]( attribute.array );\r\n\r\n			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );\r\n\r\n		}\r\n\r\n		var offsets = json.offsets;\r\n\r\n		if ( offsets !== undefined ) {\r\n\r\n			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );\r\n\r\n		}\r\n\r\n		var boundingSphere = json.boundingSphere;\r\n\r\n		if ( boundingSphere !== undefined ) {\r\n\r\n			var center = new THREE.Vector3();\r\n\r\n			if ( boundingSphere.center !== undefined ) {\r\n\r\n				center.fromArray( boundingSphere.center );\r\n\r\n			}\r\n\r\n			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n		}\r\n\r\n		return geometry;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n	constructor: THREE.MaterialLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	parse: function ( json ) {\r\n\r\n		var material = new THREE[ json.type ];\r\n\r\n		if ( json.color !== undefined ) material.color.setHex( json.color );\r\n		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );\r\n		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n		if ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n		if ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n		if ( json.shading !== undefined ) material.shading = json.shading;\r\n		if ( json.blending !== undefined ) material.blending = json.blending;\r\n		if ( json.side !== undefined ) material.side = json.side;\r\n		if ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n		if ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\r\n		if ( json.materials !== undefined ) {\r\n\r\n			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n				material.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return material;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n	constructor: THREE.ObjectLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.XHRLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( text ) {\r\n\r\n			onLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	},\r\n\r\n	parse: function ( json ) {\r\n\r\n		var geometries = this.parseGeometries( json.geometries );\r\n		var materials = this.parseMaterials( json.materials );\r\n		var object = this.parseObject( json.object, geometries, materials );\r\n\r\n		return object;\r\n\r\n	},\r\n\r\n	parseGeometries: function ( json ) {\r\n\r\n		var geometries = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			var geometryLoader = new THREE.JSONLoader();\r\n			var bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var geometry;\r\n				var data = json[ i ];\r\n\r\n				switch ( data.type ) {\r\n\r\n					case 'PlaneGeometry':\r\n\r\n						geometry = new THREE.PlaneGeometry(\r\n							data.width,\r\n							data.height,\r\n							data.widthSegments,\r\n							data.heightSegments\r\n						);\r\n\r\n						break;\r\n\r\n					case 'BoxGeometry':\r\n					case 'CubeGeometry': // backwards compatible\r\n\r\n						geometry = new THREE.BoxGeometry(\r\n							data.width,\r\n							data.height,\r\n							data.depth,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.depthSegments\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CircleGeometry':\r\n\r\n						geometry = new THREE.CircleGeometry(\r\n							data.radius,\r\n							data.segments\r\n						);\r\n\r\n						break;\r\n\r\n					case 'CylinderGeometry':\r\n\r\n						geometry = new THREE.CylinderGeometry(\r\n							data.radiusTop,\r\n							data.radiusBottom,\r\n							data.height,\r\n							data.radialSegments,\r\n							data.heightSegments,\r\n							data.openEnded\r\n						);\r\n\r\n						break;\r\n\r\n					case 'SphereGeometry':\r\n\r\n						geometry = new THREE.SphereGeometry(\r\n							data.radius,\r\n							data.widthSegments,\r\n							data.heightSegments,\r\n							data.phiStart,\r\n							data.phiLength,\r\n							data.thetaStart,\r\n							data.thetaLength\r\n						);\r\n\r\n						break;\r\n\r\n					case 'IcosahedronGeometry':\r\n\r\n						geometry = new THREE.IcosahedronGeometry(\r\n							data.radius,\r\n							data.detail\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TorusGeometry':\r\n\r\n						geometry = new THREE.TorusGeometry(\r\n							data.radius,\r\n							data.tube,\r\n							data.radialSegments,\r\n							data.tubularSegments,\r\n							data.arc\r\n						);\r\n\r\n						break;\r\n\r\n					case 'TorusKnotGeometry':\r\n\r\n						geometry = new THREE.TorusKnotGeometry(\r\n							data.radius,\r\n							data.tube,\r\n							data.radialSegments,\r\n							data.tubularSegments,\r\n							data.p,\r\n							data.q,\r\n							data.heightScale\r\n						);\r\n\r\n						break;\r\n\r\n					case 'BufferGeometry':\r\n\r\n						geometry = bufferGeometryLoader.parse( data.data );\r\n\r\n						break;\r\n\r\n					case 'Geometry':\r\n\r\n						geometry = geometryLoader.parse( data.data ).geometry;\r\n\r\n						break;\r\n\r\n				}\r\n\r\n				geometry.uuid = data.uuid;\r\n\r\n				if ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n				geometries[ data.uuid ] = geometry;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return geometries;\r\n\r\n	},\r\n\r\n	parseMaterials: function ( json ) {\r\n\r\n		var materials = {};\r\n\r\n		if ( json !== undefined ) {\r\n\r\n			var loader = new THREE.MaterialLoader();\r\n\r\n			for ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n				var data = json[ i ];\r\n				var material = loader.parse( data );\r\n\r\n				material.uuid = data.uuid;\r\n\r\n				if ( data.name !== undefined ) material.name = data.name;\r\n\r\n				materials[ data.uuid ] = material;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return materials;\r\n\r\n	},\r\n\r\n	parseObject: function () {\r\n\r\n		var matrix = new THREE.Matrix4();\r\n\r\n		return function ( data, geometries, materials ) {\r\n\r\n			var object;\r\n\r\n			switch ( data.type ) {\r\n\r\n				case 'Scene':\r\n\r\n					object = new THREE.Scene();\r\n\r\n					break;\r\n\r\n				case 'PerspectiveCamera':\r\n\r\n					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n					break;\r\n\r\n				case 'OrthographicCamera':\r\n\r\n					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n					break;\r\n\r\n				case 'AmbientLight':\r\n\r\n					object = new THREE.AmbientLight( data.color );\r\n\r\n					break;\r\n\r\n				case 'DirectionalLight':\r\n\r\n					object = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n					break;\r\n\r\n				case 'PointLight':\r\n\r\n					object = new THREE.PointLight( data.color, data.intensity, data.distance );\r\n\r\n					break;\r\n\r\n				case 'SpotLight':\r\n\r\n					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );\r\n\r\n					break;\r\n\r\n				case 'HemisphereLight':\r\n\r\n					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n					break;\r\n\r\n				case 'Mesh':\r\n\r\n					var geometry = geometries[ data.geometry ];\r\n					var material = materials[ data.material ];\r\n\r\n					if ( geometry === undefined ) {\r\n\r\n						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );\r\n\r\n					}\r\n\r\n					if ( material === undefined ) {\r\n\r\n						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );\r\n\r\n					}\r\n\r\n					object = new THREE.Mesh( geometry, material );\r\n\r\n					break;\r\n\r\n				case 'Line':\r\n\r\n					var geometry = geometries[ data.geometry ];\r\n					var material = materials[ data.material ];\r\n\r\n					if ( geometry === undefined ) {\r\n\r\n						console.warn( 'THREE.ObjectLoader: Undefined geometry', data.geometry );\r\n\r\n					}\r\n\r\n					if ( material === undefined ) {\r\n\r\n						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );\r\n\r\n					}\r\n\r\n					object = new THREE.Line( geometry, material );\r\n\r\n					break;\r\n\r\n				case 'Sprite':\r\n\r\n					var material = materials[ data.material ];\r\n\r\n					if ( material === undefined ) {\r\n\r\n						console.warn( 'THREE.ObjectLoader: Undefined material', data.material );\r\n\r\n					}\r\n\r\n					object = new THREE.Sprite( material );\r\n\r\n					break;\r\n\r\n				case 'Group':\r\n\r\n					object = new THREE.Group();\r\n\r\n					break;\r\n\r\n				default:\r\n\r\n					object = new THREE.Object3D();\r\n\r\n			}\r\n\r\n			object.uuid = data.uuid;\r\n\r\n			if ( data.name !== undefined ) object.name = data.name;\r\n			if ( data.matrix !== undefined ) {\r\n\r\n				matrix.fromArray( data.matrix );\r\n				matrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n			} else {\r\n\r\n				if ( data.position !== undefined ) object.position.fromArray( data.position );\r\n				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n			}\r\n\r\n			if ( data.visible !== undefined ) object.visible = data.visible;\r\n			if ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n			if ( data.children !== undefined ) {\r\n\r\n				for ( var child in data.children ) {\r\n\r\n					object.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return object;\r\n\r\n		}\r\n\r\n	}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n	constructor: THREE.TextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var loader = new THREE.ImageLoader( scope.manager );\r\n		loader.setCrossOrigin( this.crossOrigin );\r\n		loader.load( url, function ( image ) {\r\n\r\n			var texture = new THREE.Texture( image );\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad !== undefined ) {\r\n\r\n				onLoad( texture );\r\n\r\n			}\r\n\r\n		}, onProgress, onError );\r\n\r\n	},\r\n\r\n	setCrossOrigin: function ( value ) {\r\n\r\n		this.crossOrigin = value;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {\r\n\r\n	// override in sub classes\r\n	this._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n	constructor: THREE.BinaryTextureLoader,\r\n\r\n	load: function ( url, onLoad, onProgress, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var texture = new THREE.DataTexture( );\r\n\r\n		var loader = new THREE.XHRLoader();\r\n		loader.setResponseType( 'arraybuffer' );\r\n\r\n		loader.load( url, function ( buffer ) {\r\n\r\n			var texData = scope._parser( buffer );\r\n\r\n			if ( !texData ) return;\r\n\r\n			if ( undefined !== texData.image ) {\r\n\r\n				texture.image = texData.image;\r\n\r\n			} else if ( undefined !== texData.data ){\r\n\r\n				texture.image.width = texData.width;\r\n				texture.image.height = texData.height;\r\n				texture.image.data = texData.data;\r\n\r\n			}\r\n\r\n			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n			if ( undefined !== texData.format ) {\r\n\r\n				texture.format = texData.format;\r\n\r\n			}\r\n			if ( undefined !== texData.type ) {\r\n\r\n				texture.type = texData.type;\r\n\r\n			}\r\n\r\n			if ( undefined !== texData.mipmaps ) {\r\n\r\n				texture.mipmaps = texData.mipmaps;\r\n\r\n			}\r\n\r\n			if ( 1 === texData.mipmapCount ) {\r\n\r\n				texture.minFilter = THREE.LinearFilter;\r\n\r\n			}\r\n\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad ) onLoad( texture, texData );\r\n\r\n		}, onProgress, onError );\r\n\r\n\r\n		return texture;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function () {\r\n\r\n	// override in sub classes\r\n	this._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n	constructor: THREE.CompressedTextureLoader,\r\n\r\n	load: function ( url, onLoad, onError ) {\r\n\r\n		var scope = this;\r\n\r\n		var images = [];\r\n\r\n		var texture = new THREE.CompressedTexture();\r\n		texture.image = images;\r\n\r\n		var loader = new THREE.XHRLoader();\r\n		loader.setResponseType( 'arraybuffer' );\r\n\r\n		if ( url instanceof Array ) {\r\n\r\n			var loaded = 0;\r\n\r\n			var loadTexture = function ( i ) {\r\n\r\n				loader.load( url[ i ], function ( buffer ) {\r\n\r\n					var texDatas = scope._parser( buffer, true );\r\n\r\n					images[ i ] = {\r\n						width: texDatas.width,\r\n						height: texDatas.height,\r\n						format: texDatas.format,\r\n						mipmaps: texDatas.mipmaps\r\n					};\r\n\r\n					loaded += 1;\r\n\r\n					if ( loaded === 6 ) {\r\n\r\n 						if (texDatas.mipmapCount == 1)\r\n 							texture.minFilter = THREE.LinearFilter;\r\n\r\n						texture.format = texDatas.format;\r\n						texture.needsUpdate = true;\r\n\r\n						if ( onLoad ) onLoad( texture );\r\n\r\n					}\r\n\r\n				} );\r\n\r\n			};\r\n\r\n			for ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n				loadTexture( i );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// compressed cubemap texture stored in a single DDS file\r\n\r\n			loader.load( url, function ( buffer ) {\r\n\r\n				var texDatas = scope._parser( buffer, true );\r\n\r\n				if ( texDatas.isCubemap ) {\r\n\r\n					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n					for ( var f = 0; f < faces; f ++ ) {\r\n\r\n						images[ f ] = { mipmaps : [] };\r\n\r\n						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n							images[ f ].format = texDatas.format;\r\n							images[ f ].width = texDatas.width;\r\n							images[ f ].height = texDatas.height;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					texture.image.width = texDatas.width;\r\n					texture.image.height = texDatas.height;\r\n					texture.mipmaps = texDatas.mipmaps;\r\n\r\n				}\r\n\r\n				if ( texDatas.mipmapCount === 1 ) {\r\n\r\n					texture.minFilter = THREE.LinearFilter;\r\n\r\n				}\r\n\r\n				texture.format = texDatas.format;\r\n				texture.needsUpdate = true;\r\n\r\n				if ( onLoad ) onLoad( texture );\r\n\r\n			} );\r\n\r\n		}\r\n\r\n		return texture;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n	this.type = 'Material';\r\n\r\n	this.side = THREE.FrontSide;\r\n\r\n	this.opacity = 1;\r\n	this.transparent = false;\r\n\r\n	this.blending = THREE.NormalBlending;\r\n\r\n	this.blendSrc = THREE.SrcAlphaFactor;\r\n	this.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n	this.blendEquation = THREE.AddEquation;\r\n\r\n	this.depthTest = true;\r\n	this.depthWrite = true;\r\n\r\n	this.polygonOffset = false;\r\n	this.polygonOffsetFactor = 0;\r\n	this.polygonOffsetUnits = 0;\r\n\r\n	this.alphaTest = 0;\r\n\r\n	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n	this.visible = true;\r\n\r\n	this.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n	constructor: THREE.Material,\r\n\r\n	setValues: function ( values ) {\r\n\r\n		if ( values === undefined ) return;\r\n\r\n		for ( var key in values ) {\r\n\r\n			var newValue = values[ key ];\r\n\r\n			if ( newValue === undefined ) {\r\n\r\n				console.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n				continue;\r\n\r\n			}\r\n\r\n			if ( key in this ) {\r\n\r\n				var currentValue = this[ key ];\r\n\r\n				if ( currentValue instanceof THREE.Color ) {\r\n\r\n					currentValue.set( newValue );\r\n\r\n				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n					currentValue.copy( newValue );\r\n\r\n				} else if ( key == 'overdraw' ) {\r\n\r\n					// ensure overdraw is backwards-compatable with legacy boolean type\r\n					this[ key ] = Number( newValue );\r\n\r\n				} else {\r\n\r\n					this[ key ] = newValue;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	},\r\n\r\n	toJSON: function () {\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.2,\r\n				type: 'material',\r\n				generator: 'MaterialExporter'\r\n			},\r\n			uuid: this.uuid,\r\n			type: this.type\r\n		};\r\n\r\n		if ( this.name !== \"\" ) output.name = this.name;\r\n\r\n		if ( this instanceof THREE.MeshBasicMaterial ) {\r\n\r\n			output.color = this.color.getHex();\r\n			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n			if ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n		} else if ( this instanceof THREE.MeshLambertMaterial ) {\r\n\r\n			output.color = this.color.getHex();\r\n			output.ambient = this.ambient.getHex();\r\n			output.emissive = this.emissive.getHex();\r\n			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n			if ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n		} else if ( this instanceof THREE.MeshPhongMaterial ) {\r\n\r\n			output.color = this.color.getHex();\r\n			output.ambient = this.ambient.getHex();\r\n			output.emissive = this.emissive.getHex();\r\n			output.specular = this.specular.getHex();\r\n			output.shininess = this.shininess;\r\n			if ( this.vertexColors !== THREE.NoColors ) output.vertexColors = this.vertexColors;\r\n			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n			if ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n		} else if ( this instanceof THREE.MeshNormalMaterial ) {\r\n\r\n			if ( this.shading !== THREE.FlatShading ) output.shading = this.shading;\r\n			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n			if ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n		} else if ( this instanceof THREE.MeshDepthMaterial ) {\r\n\r\n			if ( this.blending !== THREE.NormalBlending ) output.blending = this.blending;\r\n			if ( this.side !== THREE.FrontSide ) output.side = this.side;\r\n\r\n		} else if ( this instanceof THREE.ShaderMaterial ) {\r\n\r\n			output.uniforms = this.uniforms;\r\n			output.vertexShader = this.vertexShader;\r\n			output.fragmentShader = this.fragmentShader;\r\n\r\n		} else if ( this instanceof THREE.SpriteMaterial ) {\r\n\r\n			output.color = this.color.getHex();\r\n\r\n		}\r\n\r\n		if ( this.opacity < 1 ) output.opacity = this.opacity;\r\n		if ( this.transparent !== false ) output.transparent = this.transparent;\r\n		if ( this.wireframe !== false ) output.wireframe = this.wireframe;\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	clone: function ( material ) {\r\n\r\n		if ( material === undefined ) material = new THREE.Material();\r\n\r\n		material.name = this.name;\r\n\r\n		material.side = this.side;\r\n\r\n		material.opacity = this.opacity;\r\n		material.transparent = this.transparent;\r\n\r\n		material.blending = this.blending;\r\n\r\n		material.blendSrc = this.blendSrc;\r\n		material.blendDst = this.blendDst;\r\n		material.blendEquation = this.blendEquation;\r\n\r\n		material.depthTest = this.depthTest;\r\n		material.depthWrite = this.depthWrite;\r\n\r\n		material.polygonOffset = this.polygonOffset;\r\n		material.polygonOffsetFactor = this.polygonOffsetFactor;\r\n		material.polygonOffsetUnits = this.polygonOffsetUnits;\r\n\r\n		material.alphaTest = this.alphaTest;\r\n\r\n		material.overdraw = this.overdraw;\r\n\r\n		material.visible = this.visible;\r\n\r\n		return material;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Material.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\",\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'LineBasicMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.linewidth = 1;\r\n	this.linecap = 'round';\r\n	this.linejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.LineBasicMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.color.copy( this.color );\r\n\r\n	material.linewidth = this.linewidth;\r\n	material.linecap = this.linecap;\r\n	material.linejoin = this.linejoin;\r\n\r\n	material.vertexColors = this.vertexColors;\r\n\r\n	material.fog = this.fog;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>,\r\n *\r\n *  vertexColors: <bool>\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'LineDashedMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.linewidth = 1;\r\n\r\n	this.scale = 1;\r\n	this.dashSize = 3;\r\n	this.gapSize = 1;\r\n\r\n	this.vertexColors = false;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.LineDashedMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.color.copy( this.color );\r\n\r\n	material.linewidth = this.linewidth;\r\n\r\n	material.scale = this.scale;\r\n	material.dashSize = this.dashSize;\r\n	material.gapSize = this.gapSize;\r\n\r\n	material.vertexColors = this.vertexColors;\r\n\r\n	material.fog = this.fog;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshBasicMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n	this.map = null;\r\n\r\n	this.lightMap = null;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.MeshBasicMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.color.copy( this.color );\r\n\r\n	material.map = this.map;\r\n\r\n	material.lightMap = this.lightMap;\r\n\r\n	material.specularMap = this.specularMap;\r\n\r\n	material.alphaMap = this.alphaMap;\r\n\r\n	material.envMap = this.envMap;\r\n	material.combine = this.combine;\r\n	material.reflectivity = this.reflectivity;\r\n	material.refractionRatio = this.refractionRatio;\r\n\r\n	material.fog = this.fog;\r\n\r\n	material.shading = this.shading;\r\n\r\n	material.wireframe = this.wireframe;\r\n	material.wireframeLinewidth = this.wireframeLinewidth;\r\n	material.wireframeLinecap = this.wireframeLinecap;\r\n	material.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n	material.vertexColors = this.vertexColors;\r\n\r\n	material.skinning = this.skinning;\r\n	material.morphTargets = this.morphTargets;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshLambertMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // diffuse\r\n	this.ambient = new THREE.Color( 0xffffff );\r\n	this.emissive = new THREE.Color( 0x000000 );\r\n\r\n	this.wrapAround = false;\r\n	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n	this.map = null;\r\n\r\n	this.lightMap = null;\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n	this.morphNormals = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.MeshLambertMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.color.copy( this.color );\r\n	material.ambient.copy( this.ambient );\r\n	material.emissive.copy( this.emissive );\r\n\r\n	material.wrapAround = this.wrapAround;\r\n	material.wrapRGB.copy( this.wrapRGB );\r\n\r\n	material.map = this.map;\r\n\r\n	material.lightMap = this.lightMap;\r\n\r\n	material.specularMap = this.specularMap;\r\n\r\n	material.alphaMap = this.alphaMap;\r\n\r\n	material.envMap = this.envMap;\r\n	material.combine = this.combine;\r\n	material.reflectivity = this.reflectivity;\r\n	material.refractionRatio = this.refractionRatio;\r\n\r\n	material.fog = this.fog;\r\n\r\n	material.shading = this.shading;\r\n\r\n	material.wireframe = this.wireframe;\r\n	material.wireframeLinewidth = this.wireframeLinewidth;\r\n	material.wireframeLinecap = this.wireframeLinecap;\r\n	material.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n	material.vertexColors = this.vertexColors;\r\n\r\n	material.skinning = this.skinning;\r\n	material.morphTargets = this.morphTargets;\r\n	material.morphNormals = this.morphNormals;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  ambient: <hex>,\r\n *  emissive: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshPhongMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff ); // diffuse\r\n	this.ambient = new THREE.Color( 0xffffff );\r\n	this.emissive = new THREE.Color( 0x000000 );\r\n	this.specular = new THREE.Color( 0x111111 );\r\n	this.shininess = 30;\r\n\r\n	this.metal = false;\r\n\r\n	this.wrapAround = false;\r\n	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );\r\n\r\n	this.map = null;\r\n\r\n	this.lightMap = null;\r\n\r\n	this.bumpMap = null;\r\n	this.bumpScale = 1;\r\n\r\n	this.normalMap = null;\r\n	this.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n	this.specularMap = null;\r\n\r\n	this.alphaMap = null;\r\n\r\n	this.envMap = null;\r\n	this.combine = THREE.MultiplyOperation;\r\n	this.reflectivity = 1;\r\n	this.refractionRatio = 0.98;\r\n\r\n	this.fog = true;\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n	this.wireframeLinecap = 'round';\r\n	this.wireframeLinejoin = 'round';\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.skinning = false;\r\n	this.morphTargets = false;\r\n	this.morphNormals = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.MeshPhongMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.color.copy( this.color );\r\n	material.ambient.copy( this.ambient );\r\n	material.emissive.copy( this.emissive );\r\n	material.specular.copy( this.specular );\r\n	material.shininess = this.shininess;\r\n\r\n	material.metal = this.metal;\r\n\r\n	material.wrapAround = this.wrapAround;\r\n	material.wrapRGB.copy( this.wrapRGB );\r\n\r\n	material.map = this.map;\r\n\r\n	material.lightMap = this.lightMap;\r\n\r\n	material.bumpMap = this.bumpMap;\r\n	material.bumpScale = this.bumpScale;\r\n\r\n	material.normalMap = this.normalMap;\r\n	material.normalScale.copy( this.normalScale );\r\n\r\n	material.specularMap = this.specularMap;\r\n\r\n	material.alphaMap = this.alphaMap;\r\n\r\n	material.envMap = this.envMap;\r\n	material.combine = this.combine;\r\n	material.reflectivity = this.reflectivity;\r\n	material.refractionRatio = this.refractionRatio;\r\n\r\n	material.fog = this.fog;\r\n\r\n	material.shading = this.shading;\r\n\r\n	material.wireframe = this.wireframe;\r\n	material.wireframeLinewidth = this.wireframeLinewidth;\r\n	material.wireframeLinecap = this.wireframeLinecap;\r\n	material.wireframeLinejoin = this.wireframeLinejoin;\r\n\r\n	material.vertexColors = this.vertexColors;\r\n\r\n	material.skinning = this.skinning;\r\n	material.morphTargets = this.morphTargets;\r\n	material.morphNormals = this.morphNormals;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'MeshDepthMaterial';\r\n\r\n	this.morphTargets = false;\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.MeshDepthMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.wireframe = this.wireframe;\r\n	material.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  shading: THREE.FlatShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this, parameters );\r\n\r\n	this.type = 'MeshNormalMaterial';\r\n\r\n	this.shading = THREE.FlatShading;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.morphTargets = false;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.MeshNormalMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.shading = this.shading;\r\n\r\n	material.wireframe = this.wireframe;\r\n	material.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/MeshFaceMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MeshFaceMaterial = function ( materials ) {\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.type = 'MeshFaceMaterial';\r\n	\r\n	this.materials = materials instanceof Array ? materials : [];\r\n\r\n};\r\n\r\nTHREE.MeshFaceMaterial.prototype = {\r\n\r\n	constructor: THREE.MeshFaceMaterial,\r\n\r\n	toJSON: function () {\r\n\r\n		var output = {\r\n			metadata: {\r\n				version: 4.2,\r\n				type: 'material',\r\n				generator: 'MaterialExporter'\r\n			},\r\n			uuid: this.uuid,\r\n			type: this.type,\r\n			materials: []\r\n		};\r\n\r\n		for ( var i = 0, l = this.materials.length; i < l; i ++ ) {\r\n\r\n			output.materials.push( this.materials[ i ].toJSON() );\r\n\r\n		}\r\n\r\n		return output;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		var material = new THREE.MeshFaceMaterial();\r\n\r\n		for ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n			material.materials.push( this.materials[ i ].clone() );\r\n\r\n		}\r\n\r\n		return material;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/materials/PointCloudMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>,\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  vertexColors: <bool>,\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointCloudMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'PointCloudMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n\r\n	this.map = null;\r\n\r\n	this.size = 1;\r\n	this.sizeAttenuation = true;\r\n\r\n	this.vertexColors = THREE.NoColors;\r\n\r\n	this.fog = true;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;\r\n\r\nTHREE.PointCloudMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.PointCloudMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.color.copy( this.color );\r\n\r\n	material.map = this.map;\r\n\r\n	material.size = this.size;\r\n	material.sizeAttenuation = this.sizeAttenuation;\r\n\r\n	material.vertexColors = this.vertexColors;\r\n\r\n	material.fog = this.fog;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// backwards compatibility\r\n\r\nTHREE.ParticleBasicMaterial = function ( parameters ) {\r\n\r\n	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n	return new THREE.PointCloudMaterial( parameters );\r\n\r\n};\r\n\r\nTHREE.ParticleSystemMaterial = function ( parameters ) {\r\n\r\n	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );\r\n	return new THREE.PointCloudMaterial( parameters );\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"f\", value: 1.0 }, \"parameter2\": { type: \"i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>,\r\n *\r\n *	fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'ShaderMaterial';\r\n\r\n	this.defines = {};\r\n	this.uniforms = {};\r\n	this.attributes = null;\r\n\r\n	this.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n	this.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n	this.shading = THREE.SmoothShading;\r\n\r\n	this.linewidth = 1;\r\n\r\n	this.wireframe = false;\r\n	this.wireframeLinewidth = 1;\r\n\r\n	this.fog = false; // set to use scene fog\r\n\r\n	this.lights = false; // set to use scene lights\r\n\r\n	this.vertexColors = THREE.NoColors; // set to use \"color\" attribute stream\r\n\r\n	this.skinning = false; // set to use skinning attribute streams\r\n\r\n	this.morphTargets = false; // set to use morph targets\r\n	this.morphNormals = false; // set to use morph normals\r\n\r\n	// When rendered geometry doesn't include these attributes but the material does,\r\n	// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n	this.defaultAttributeValues = {\r\n		'color': [ 1, 1, 1 ],\r\n		'uv': [ 0, 0 ],\r\n		'uv2': [ 0, 0 ]\r\n	};\r\n\r\n	this.index0AttributeName = undefined;\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.ShaderMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.fragmentShader = this.fragmentShader;\r\n	material.vertexShader = this.vertexShader;\r\n\r\n	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );\r\n\r\n	material.attributes = this.attributes;\r\n	material.defines = this.defines;\r\n\r\n	material.shading = this.shading;\r\n\r\n	material.wireframe = this.wireframe;\r\n	material.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n	material.fog = this.fog;\r\n\r\n	material.lights = this.lights;\r\n\r\n	material.vertexColors = this.vertexColors;\r\n\r\n	material.skinning = this.skinning;\r\n\r\n	material.morphTargets = this.morphTargets;\r\n	material.morphNormals = this.morphNormals;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n	THREE.ShaderMaterial.call( this, parameters );\r\n\r\n	this.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\r\nTHREE.RawShaderMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.RawShaderMaterial();\r\n\r\n	THREE.ShaderMaterial.prototype.clone.call( this, material );\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  blending: THREE.NormalBlending,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *	uvOffset: new THREE.Vector2(),\r\n *	uvScale: new THREE.Vector2(),\r\n *\r\n *  fog: <bool>\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n	THREE.Material.call( this );\r\n\r\n	this.type = 'SpriteMaterial';\r\n\r\n	this.color = new THREE.Color( 0xffffff );\r\n	this.map = null;\r\n\r\n	this.rotation = 0;\r\n\r\n	this.fog = false;\r\n\r\n	// set parameters\r\n\r\n	this.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.clone = function () {\r\n\r\n	var material = new THREE.SpriteMaterial();\r\n\r\n	THREE.Material.prototype.clone.call( this, material );\r\n\r\n	material.color.copy( this.color );\r\n	material.map = this.map;\r\n\r\n	material.rotation = this.rotation;\r\n\r\n	material.fog = this.fog;\r\n\r\n	return material;\r\n\r\n};\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n	this.uuid = THREE.Math.generateUUID();\r\n\r\n	this.name = '';\r\n\r\n	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n	this.mipmaps = [];\r\n\r\n	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n	this.format = format !== undefined ? format : THREE.RGBAFormat;\r\n	this.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n	this.offset = new THREE.Vector2( 0, 0 );\r\n	this.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n	this.generateMipmaps = true;\r\n	this.premultiplyAlpha = false;\r\n	this.flipY = true;\r\n	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n	this._needsUpdate = false;\r\n	this.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n	constructor: THREE.Texture,\r\n\r\n	get needsUpdate () {\r\n\r\n		return this._needsUpdate;\r\n\r\n	},\r\n\r\n	set needsUpdate ( value ) {\r\n\r\n		if ( value === true ) this.update();\r\n\r\n		this._needsUpdate = value;\r\n\r\n	},\r\n\r\n	clone: function ( texture ) {\r\n\r\n		if ( texture === undefined ) texture = new THREE.Texture();\r\n\r\n		texture.image = this.image;\r\n		texture.mipmaps = this.mipmaps.slice( 0 );\r\n\r\n		texture.mapping = this.mapping;\r\n\r\n		texture.wrapS = this.wrapS;\r\n		texture.wrapT = this.wrapT;\r\n\r\n		texture.magFilter = this.magFilter;\r\n		texture.minFilter = this.minFilter;\r\n\r\n		texture.anisotropy = this.anisotropy;\r\n\r\n		texture.format = this.format;\r\n		texture.type = this.type;\r\n\r\n		texture.offset.copy( this.offset );\r\n		texture.repeat.copy( this.repeat );\r\n\r\n		texture.generateMipmaps = this.generateMipmaps;\r\n		texture.premultiplyAlpha = this.premultiplyAlpha;\r\n		texture.flipY = this.flipY;\r\n		texture.unpackAlignment = this.unpackAlignment;\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	update: function () {\r\n\r\n		this.dispatchEvent( { type: 'update' } );\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n	\r\n	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.images = images;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nTHREE.CubeTexture.clone = function ( texture ) {\r\n\r\n	if ( texture === undefined ) texture = new THREE.CubeTexture();\r\n\r\n	THREE.Texture.prototype.clone.call( this, texture );\r\n\r\n	texture.images = this.images;\r\n\r\n	return texture;\r\n\r\n};\r\n\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.image = { width: width, height: height };\r\n	this.mipmaps = mipmaps;\r\n\r\n	// no flipping for cube textures\r\n	// (also flipping doesn't work for compressed textures )\r\n\r\n	this.flipY = false;\r\n\r\n	// can't generate mipmaps for compressed textures\r\n	// mips must be embedded in DDS files\r\n\r\n	this.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\nTHREE.CompressedTexture.prototype.clone = function () {\r\n\r\n	var texture = new THREE.CompressedTexture();\r\n\r\n	THREE.Texture.prototype.clone.call( this, texture );\r\n\r\n	return texture;\r\n\r\n};\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.image = { data: data, width: width, height: height };\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\nTHREE.DataTexture.prototype.clone = function () {\r\n\r\n	var texture = new THREE.DataTexture();\r\n\r\n	THREE.Texture.prototype.clone.call( this, texture );\r\n\r\n	return texture;\r\n\r\n};\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n	this.generateMipmaps = false;\r\n\r\n	var scope = this;\r\n\r\n	var update = function () {\r\n\r\n		requestAnimationFrame( update );\r\n\r\n		if ( video.readyState === video.HAVE_ENOUGH_DATA ) {\r\n\r\n			scope.needsUpdate = true;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	update();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Group.prototype.constructor = THREE.Group;\r\n\r\n// File:src/objects/PointCloud.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.PointCloud = function ( geometry, material ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'PointCloud';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.PointCloud.prototype.constructor = THREE.PointCloud;\r\n\r\nTHREE.PointCloud.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n\r\n	return function ( raycaster, intersects ) {\r\n\r\n		var object = this;\r\n		var geometry = object.geometry;\r\n		var threshold = raycaster.params.PointCloud.threshold;\r\n\r\n		inverseMatrix.getInverse( this.matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {\r\n\r\n				return;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n		var position = new THREE.Vector3();\r\n\r\n		var testPoint = function ( point, index ) {\r\n\r\n			var rayPointDistance = ray.distanceToPoint( point );\r\n\r\n			if ( rayPointDistance < localThreshold ) {\r\n\r\n				var intersectPoint = ray.closestPointToPoint( point );\r\n				intersectPoint.applyMatrix4( object.matrixWorld );\r\n\r\n				var distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					distanceToRay: rayPointDistance,\r\n					point: intersectPoint.clone(),\r\n					index: index,\r\n					face: null,\r\n					object: object\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		};\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var attributes = geometry.attributes;\r\n			var positions = attributes.position.array;\r\n\r\n			if ( attributes.index !== undefined ) {\r\n\r\n				var indices = attributes.index.array;\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					var offset = {\r\n						start: 0,\r\n						count: indices.length,\r\n						index: 0\r\n					};\r\n\r\n					offsets = [ offset ];\r\n\r\n				}\r\n\r\n				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {\r\n\r\n					var start = offsets[ oi ].start;\r\n					var count = offsets[ oi ].count;\r\n					var index = offsets[ oi ].index;\r\n\r\n					for ( var i = start, il = start + count; i < il; i ++ ) {\r\n\r\n						var a = index + indices[ i ];\r\n\r\n						position.fromArray( positions, a * 3 );\r\n\r\n						testPoint( position, a );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				var pointCount = positions.length / 3;\r\n\r\n				for ( var i = 0; i < pointCount; i ++ ) {\r\n\r\n					position.set(\r\n						positions[ 3 * i ],\r\n						positions[ 3 * i + 1 ],\r\n						positions[ 3 * i + 2 ]\r\n					);\r\n\r\n					testPoint( position, i );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			var vertices = this.geometry.vertices;\r\n\r\n			for ( var i = 0; i < vertices.length; i ++ ) {\r\n\r\n				testPoint( vertices[ i ], i );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.PointCloud.prototype.clone = function ( object ) {\r\n\r\n	if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );\r\n\r\n	THREE.Object3D.prototype.clone.call( this, object );\r\n\r\n	return object;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.ParticleSystem = function ( geometry, material ) {\r\n\r\n	console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );\r\n	return new THREE.PointCloud( geometry, material );\r\n\r\n};\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Line';\r\n\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n	this.mode = ( mode !== undefined ) ? mode : THREE.LineStrip;\r\n\r\n};\r\n\r\nTHREE.LineStrip = 0;\r\nTHREE.LinePieces = 1;\r\n\r\nTHREE.Line.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Line.prototype.constructor = THREE.Line;\r\n\r\nTHREE.Line.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n	var sphere = new THREE.Sphere();\r\n\r\n	return function ( raycaster, intersects ) {\r\n\r\n		var precision = raycaster.linePrecision;\r\n		var precisionSq = precision * precision;\r\n\r\n		var geometry = this.geometry;\r\n\r\n		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n		// Checking boundingSphere distance to ray\r\n\r\n		sphere.copy( geometry.boundingSphere );\r\n		sphere.applyMatrix4( this.matrixWorld );\r\n\r\n		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		inverseMatrix.getInverse( this.matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		var vStart = new THREE.Vector3();\r\n		var vEnd = new THREE.Vector3();\r\n		var interSegment = new THREE.Vector3();\r\n		var interRay = new THREE.Vector3();\r\n		var step = this.mode === THREE.LineStrip ? 1 : 2;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var attributes = geometry.attributes;\r\n\r\n			if ( attributes.index !== undefined ) {\r\n\r\n				var indices = attributes.index.array;\r\n				var positions = attributes.position.array;\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					offsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\r\n				}\r\n\r\n				for ( var oi = 0; oi < offsets.length; oi++){\r\n\r\n					var start = offsets[ oi ].start;\r\n					var count = offsets[ oi ].count;\r\n					var index = offsets[ oi ].index;\r\n\r\n					for ( var i = start; i < start + count - 1; i += step ) {\r\n\r\n						var a = index + indices[ i ];\r\n						var b = index + indices[ i + 1 ];\r\n\r\n						vStart.fromArray( positions, a * 3 );\r\n						vEnd.fromArray( positions, b * 3 );\r\n\r\n						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n						if ( distSq > precisionSq ) continue;\r\n\r\n						var distance = ray.origin.distanceTo( interRay );\r\n\r\n						if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n						intersects.push( {\r\n\r\n							distance: distance,\r\n							// What do we want? intersection point on the ray or on the segment??\r\n							// point: raycaster.ray.at( distance ),\r\n							point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n							face: null,\r\n							faceIndex: null,\r\n							object: this\r\n\r\n						} );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				var positions = attributes.position.array;\r\n\r\n				for ( var i = 0; i < positions.length / 3 - 1; i += step ) {\r\n\r\n					vStart.fromArray( positions, 3 * i );\r\n					vEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n					var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n					if ( distSq > precisionSq ) continue;\r\n\r\n					var distance = ray.origin.distanceTo( interRay );\r\n\r\n					if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						// What do we want? intersection point on the ray or on the segment??\r\n						// point: raycaster.ray.at( distance ),\r\n						point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n						face: null,\r\n						faceIndex: null,\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			var vertices = geometry.vertices;\r\n			var nbVertices = vertices.length;\r\n\r\n			for ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n				var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n				if ( distSq > precisionSq ) continue;\r\n\r\n				var distance = ray.origin.distanceTo( interRay );\r\n\r\n				if ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					// What do we want? intersection point on the ray or on the segment??\r\n					// point: raycaster.ray.at( distance ),\r\n					point: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n					face: null,\r\n					faceIndex: null,\r\n					object: this\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Line.prototype.clone = function ( object ) {\r\n\r\n	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.mode );\r\n\r\n	THREE.Object3D.prototype.clone.call( this, object );\r\n\r\n	return object;\r\n\r\n};\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Mesh';\r\n	\r\n	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();\r\n	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n	this.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Mesh.prototype.constructor = THREE.Mesh;\r\n\r\nTHREE.Mesh.prototype.updateMorphTargets = function () {\r\n\r\n	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n		this.morphTargetBase = - 1;\r\n		this.morphTargetForcedOrder = [];\r\n		this.morphTargetInfluences = [];\r\n		this.morphTargetDictionary = {};\r\n\r\n		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n			this.morphTargetInfluences.push( 0 );\r\n			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {\r\n\r\n	if ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n		return this.morphTargetDictionary[ name ];\r\n\r\n	}\r\n\r\n	console.log( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n	return 0;\r\n\r\n};\r\n\r\n\r\nTHREE.Mesh.prototype.raycast = ( function () {\r\n\r\n	var inverseMatrix = new THREE.Matrix4();\r\n	var ray = new THREE.Ray();\r\n	var sphere = new THREE.Sphere();\r\n\r\n	var vA = new THREE.Vector3();\r\n	var vB = new THREE.Vector3();\r\n	var vC = new THREE.Vector3();\r\n\r\n	return function ( raycaster, intersects ) {\r\n\r\n		var geometry = this.geometry;\r\n\r\n		// Checking boundingSphere distance to ray\r\n\r\n		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n		sphere.copy( geometry.boundingSphere );\r\n		sphere.applyMatrix4( this.matrixWorld );\r\n\r\n		if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		// Check boundingBox before continuing\r\n\r\n		inverseMatrix.getInverse( this.matrixWorld );\r\n		ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n		if ( geometry.boundingBox !== null ) {\r\n\r\n			if ( ray.isIntersectionBox( geometry.boundingBox ) === false )  {\r\n\r\n				return;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var material = this.material;\r\n\r\n			if ( material === undefined ) return;\r\n\r\n			var attributes = geometry.attributes;\r\n\r\n			var a, b, c;\r\n			var precision = raycaster.precision;\r\n\r\n			if ( attributes.index !== undefined ) {\r\n\r\n				var indices = attributes.index.array;\r\n				var positions = attributes.position.array;\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					offsets = [ { start: 0, count: indices.length, index: 0 } ];\r\n\r\n				}\r\n\r\n				for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {\r\n\r\n					var start = offsets[ oi ].start;\r\n					var count = offsets[ oi ].count;\r\n					var index = offsets[ oi ].index;\r\n\r\n					for ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n						a = index + indices[ i ];\r\n						b = index + indices[ i + 1 ];\r\n						c = index + indices[ i + 2 ];\r\n\r\n						vA.fromArray( positions, a * 3 );\r\n						vB.fromArray( positions, b * 3 );\r\n						vC.fromArray( positions, c * 3 );\r\n\r\n						if ( material.side === THREE.BackSide ) {\r\n\r\n							var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\r\n						} else {\r\n\r\n							var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n						}\r\n\r\n						if ( intersectionPoint === null ) continue;\r\n\r\n						intersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n						intersects.push( {\r\n\r\n							distance: distance,\r\n							point: intersectionPoint,\r\n							face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n							faceIndex: null,\r\n							object: this\r\n\r\n						} );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				var positions = attributes.position.array;\r\n\r\n				for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {\r\n\r\n					a = i;\r\n					b = i + 1;\r\n					c = i + 2;\r\n\r\n					vA.fromArray( positions, j );\r\n					vB.fromArray( positions, j + 3 );\r\n					vC.fromArray( positions, j + 6 );\r\n\r\n					if ( material.side === THREE.BackSide ) {\r\n\r\n						var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );\r\n\r\n					} else {\r\n\r\n						var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );\r\n\r\n					}\r\n\r\n					if ( intersectionPoint === null ) continue;\r\n\r\n					intersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n					intersects.push( {\r\n\r\n						distance: distance,\r\n						point: intersectionPoint,\r\n						face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),\r\n						faceIndex: null,\r\n						object: this\r\n\r\n					} );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n			var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;\r\n			var objectMaterials = isFaceMaterial === true ? this.material.materials : null;\r\n\r\n			var a, b, c, d;\r\n			var precision = raycaster.precision;\r\n\r\n			var vertices = geometry.vertices;\r\n\r\n			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n				var face = geometry.faces[ f ];\r\n\r\n				var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;\r\n\r\n				if ( material === undefined ) continue;\r\n\r\n				a = vertices[ face.a ];\r\n				b = vertices[ face.b ];\r\n				c = vertices[ face.c ];\r\n\r\n				if ( material.morphTargets === true ) {\r\n\r\n					var morphTargets = geometry.morphTargets;\r\n					var morphInfluences = this.morphTargetInfluences;\r\n\r\n					vA.set( 0, 0, 0 );\r\n					vB.set( 0, 0, 0 );\r\n					vC.set( 0, 0, 0 );\r\n\r\n					for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n						var influence = morphInfluences[ t ];\r\n\r\n						if ( influence === 0 ) continue;\r\n\r\n						var targets = morphTargets[ t ].vertices;\r\n\r\n						vA.x += ( targets[ face.a ].x - a.x ) * influence;\r\n						vA.y += ( targets[ face.a ].y - a.y ) * influence;\r\n						vA.z += ( targets[ face.a ].z - a.z ) * influence;\r\n\r\n						vB.x += ( targets[ face.b ].x - b.x ) * influence;\r\n						vB.y += ( targets[ face.b ].y - b.y ) * influence;\r\n						vB.z += ( targets[ face.b ].z - b.z ) * influence;\r\n\r\n						vC.x += ( targets[ face.c ].x - c.x ) * influence;\r\n						vC.y += ( targets[ face.c ].y - c.y ) * influence;\r\n						vC.z += ( targets[ face.c ].z - c.z ) * influence;\r\n\r\n					}\r\n\r\n					vA.add( a );\r\n					vB.add( b );\r\n					vC.add( c );\r\n\r\n					a = vA;\r\n					b = vB;\r\n					c = vC;\r\n\r\n				}\r\n\r\n				if ( material.side === THREE.BackSide ) {\r\n\r\n					var intersectionPoint = ray.intersectTriangle( c, b, a, true );\r\n\r\n				} else {\r\n\r\n					var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );\r\n\r\n				}\r\n\r\n				if ( intersectionPoint === null ) continue;\r\n\r\n				intersectionPoint.applyMatrix4( this.matrixWorld );\r\n\r\n				var distance = raycaster.ray.origin.distanceTo( intersectionPoint );\r\n\r\n				if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n				intersects.push( {\r\n\r\n					distance: distance,\r\n					point: intersectionPoint,\r\n					face: face,\r\n					faceIndex: f,\r\n					object: this\r\n\r\n				} );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Mesh.prototype.clone = function ( object, recursive ) {\r\n\r\n	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );\r\n\r\n	THREE.Object3D.prototype.clone.call( this, object, recursive );\r\n\r\n	return object;\r\n\r\n};\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( belongsToSkin ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.skin = belongsToSkin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Bone.prototype.constructor = THREE.Bone;\r\n\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n	this.identityMatrix = new THREE.Matrix4();\r\n\r\n	// copy the bone array\r\n\r\n	bones = bones || [];\r\n\r\n	this.bones = bones.slice( 0 );\r\n\r\n	// create a bone texture or an array of floats\r\n\r\n	if ( this.useVertexTexture ) {\r\n\r\n		// layout (1 matrix = 4 pixels)\r\n		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n		//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)\r\n		//       16x16 pixel texture max   64 bones (16 * 16 / 4)\r\n		//       32x32 pixel texture max  256 bones (32 * 32 / 4)\r\n		//       64x64 pixel texture max 1024 bones (64 * 64 / 4)\r\n\r\n		var size;\r\n\r\n		if ( this.bones.length > 256 )\r\n			size = 64;\r\n		else if ( this.bones.length > 64 )\r\n			size = 32;\r\n		else if ( this.bones.length > 16 )\r\n			size = 16;\r\n		else\r\n			size = 8;\r\n\r\n		this.boneTextureWidth = size;\r\n		this.boneTextureHeight = size;\r\n\r\n		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n		this.boneTexture.minFilter = THREE.NearestFilter;\r\n		this.boneTexture.magFilter = THREE.NearestFilter;\r\n		this.boneTexture.generateMipmaps = false;\r\n		this.boneTexture.flipY = false;\r\n\r\n	} else {\r\n\r\n		this.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n	}\r\n\r\n	// use the supplied bone inverses or calculate the inverses\r\n\r\n	if ( boneInverses === undefined ) {\r\n\r\n		this.calculateInverses();\r\n\r\n	} else {\r\n\r\n		if ( this.bones.length === boneInverses.length ) {\r\n\r\n			this.boneInverses = boneInverses.slice( 0 );\r\n\r\n		} else {\r\n\r\n			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n			this.boneInverses = [];\r\n\r\n			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n				this.boneInverses.push( new THREE.Matrix4() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.calculateInverses = function () {\r\n\r\n	this.boneInverses = [];\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		var inverse = new THREE.Matrix4();\r\n\r\n		if ( this.bones[ b ] ) {\r\n\r\n			inverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n		}\r\n\r\n		this.boneInverses.push( inverse );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.pose = function () {\r\n\r\n	var bone;\r\n\r\n	// recover the bind-time world matrices\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		bone = this.bones[ b ];\r\n\r\n		if ( bone ) {\r\n\r\n			bone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// compute the local matrices, positions, rotations and scales\r\n\r\n	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n		bone = this.bones[ b ];\r\n\r\n		if ( bone ) {\r\n\r\n			if ( bone.parent ) {\r\n\r\n				bone.matrix.getInverse( bone.parent.matrixWorld );\r\n				bone.matrix.multiply( bone.matrixWorld );\r\n\r\n			} else {\r\n\r\n				bone.matrix.copy( bone.matrixWorld );\r\n\r\n			}\r\n\r\n			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Skeleton.prototype.update = ( function () {\r\n\r\n	var offsetMatrix = new THREE.Matrix4();\r\n	\r\n	return function () {\r\n\r\n		// flatten bone matrices to array\r\n\r\n		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n			// compute the offset between the current and the original transform\r\n\r\n			var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n			offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );\r\n\r\n		}\r\n\r\n		if ( this.useVertexTexture ) {\r\n\r\n			this.boneTexture.needsUpdate = true;\r\n\r\n		}\r\n		\r\n	};\r\n\r\n} )();\r\n\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.type = 'SkinnedMesh';\r\n\r\n	this.bindMode = \"attached\";\r\n	this.bindMatrix = new THREE.Matrix4();\r\n	this.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n	// init bones\r\n\r\n	// TODO: remove bone creation as there is no reason (other than\r\n	// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n	var bones = [];\r\n\r\n	if ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n		var bone, gbone, p, q, s;\r\n\r\n		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {\r\n\r\n			gbone = this.geometry.bones[ b ];\r\n\r\n			p = gbone.pos;\r\n			q = gbone.rotq;\r\n			s = gbone.scl;\r\n\r\n			bone = new THREE.Bone( this );\r\n			bones.push( bone );\r\n\r\n			bone.name = gbone.name;\r\n			bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );\r\n			bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );\r\n\r\n			if ( s !== undefined ) {\r\n\r\n				bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );\r\n\r\n			} else {\r\n\r\n				bone.scale.set( 1, 1, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++b ) {\r\n\r\n			gbone = this.geometry.bones[ b ];\r\n\r\n			if ( gbone.parent !== - 1 ) {\r\n\r\n				bones[ gbone.parent ].add( bones[ b ] );\r\n\r\n			} else {\r\n\r\n				this.add( bones[ b ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.normalizeSkinWeights();\r\n\r\n	this.updateMatrixWorld( true );\r\n	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;\r\n\r\nTHREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {\r\n\r\n	this.skeleton = skeleton;\r\n\r\n	if ( bindMatrix === undefined ) {\r\n\r\n		this.updateMatrixWorld( true );\r\n\r\n		bindMatrix = this.matrixWorld;\r\n\r\n	}\r\n\r\n	this.bindMatrix.copy( bindMatrix );\r\n	this.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.pose = function () {\r\n\r\n	this.skeleton.pose();\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {\r\n\r\n	if ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {\r\n\r\n			var sw = this.geometry.skinWeights[ i ];\r\n\r\n			var scale = 1.0 / sw.lengthManhattan();\r\n\r\n			if ( scale !== Infinity ) {\r\n\r\n				sw.multiplyScalar( scale );\r\n\r\n			} else {\r\n\r\n				sw.set( 1 ); // this will be normalized by the shader anyway\r\n\r\n			}\r\n\r\n		}\r\n\r\n	} else {\r\n\r\n		// skinning weights assumed to be normalized for THREE.BufferGeometry\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {\r\n\r\n	THREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n	if ( this.bindMode === \"attached\" ) {\r\n\r\n		this.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n	} else if ( this.bindMode === \"detached\" ) {\r\n\r\n		this.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n	} else {\r\n\r\n		console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.SkinnedMesh.prototype.clone = function( object ) {\r\n\r\n	if ( object === undefined ) {\r\n\r\n		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );\r\n\r\n	}\r\n\r\n	THREE.Mesh.prototype.clone.call( this, object );\r\n\r\n	return object;\r\n\r\n};\r\n\r\n\r\n// File:src/objects/MorphAnimMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphAnimMesh = function ( geometry, material ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.type = 'MorphAnimMesh';\r\n\r\n	// API\r\n\r\n	this.duration = 1000; // milliseconds\r\n	this.mirroredLoop = false;\r\n	this.time = 0;\r\n\r\n	// internals\r\n\r\n	this.lastKeyframe = 0;\r\n	this.currentKeyframe = 0;\r\n\r\n	this.direction = 1;\r\n	this.directionBackwards = false;\r\n\r\n	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;\r\n\r\nTHREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {\r\n\r\n	this.startKeyframe = start;\r\n	this.endKeyframe = end;\r\n\r\n	this.length = this.endKeyframe - this.startKeyframe + 1;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionForward = function () {\r\n\r\n	this.direction = 1;\r\n	this.directionBackwards = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setDirectionBackward = function () {\r\n\r\n	this.direction = - 1;\r\n	this.directionBackwards = true;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.parseAnimations = function () {\r\n\r\n	var geometry = this.geometry;\r\n\r\n	if ( ! geometry.animations ) geometry.animations = {};\r\n\r\n	var firstAnimation, animations = geometry.animations;\r\n\r\n	var pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n		var morph = geometry.morphTargets[ i ];\r\n		var parts = morph.name.match( pattern );\r\n\r\n		if ( parts && parts.length > 1 ) {\r\n\r\n			var label = parts[ 1 ];\r\n			var num = parts[ 2 ];\r\n\r\n			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };\r\n\r\n			var animation = animations[ label ];\r\n\r\n			if ( i < animation.start ) animation.start = i;\r\n			if ( i > animation.end ) animation.end = i;\r\n\r\n			if ( ! firstAnimation ) firstAnimation = label;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {\r\n\r\n	if ( ! this.geometry.animations ) this.geometry.animations = {};\r\n\r\n	this.geometry.animations[ label ] = { start: start, end: end };\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {\r\n\r\n	var animation = this.geometry.animations[ label ];\r\n\r\n	if ( animation ) {\r\n\r\n		this.setFrameRange( animation.start, animation.end );\r\n		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );\r\n		this.time = 0;\r\n\r\n	} else {\r\n\r\n		console.warn( 'animation[' + label + '] undefined' );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {\r\n\r\n	var frameTime = this.duration / this.length;\r\n\r\n	this.time += this.direction * delta;\r\n\r\n	if ( this.mirroredLoop ) {\r\n\r\n		if ( this.time > this.duration || this.time < 0 ) {\r\n\r\n			this.direction *= - 1;\r\n\r\n			if ( this.time > this.duration ) {\r\n\r\n				this.time = this.duration;\r\n				this.directionBackwards = true;\r\n\r\n			}\r\n\r\n			if ( this.time < 0 ) {\r\n\r\n				this.time = 0;\r\n				this.directionBackwards = false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	} else {\r\n\r\n		this.time = this.time % this.duration;\r\n\r\n		if ( this.time < 0 ) this.time += this.duration;\r\n\r\n	}\r\n\r\n	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );\r\n\r\n	if ( keyframe !== this.currentKeyframe ) {\r\n\r\n		this.morphTargetInfluences[ this.lastKeyframe ] = 0;\r\n		this.morphTargetInfluences[ this.currentKeyframe ] = 1;\r\n\r\n		this.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n		this.lastKeyframe = this.currentKeyframe;\r\n		this.currentKeyframe = keyframe;\r\n\r\n	}\r\n\r\n	var mix = ( this.time % frameTime ) / frameTime;\r\n\r\n	if ( this.directionBackwards ) {\r\n\r\n		mix = 1 - mix;\r\n\r\n	}\r\n\r\n	this.morphTargetInfluences[ this.currentKeyframe ] = mix;\r\n	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {\r\n\r\n	var influences = this.morphTargetInfluences;\r\n\r\n	for ( var i = 0, l = influences.length; i < l; i ++ ) {\r\n\r\n		influences[ i ] = 0;\r\n\r\n	}\r\n\r\n	if ( a > -1 ) influences[ a ] = 1 - t;\r\n	if ( b > -1 ) influences[ b ] = t;\r\n\r\n};\r\n\r\nTHREE.MorphAnimMesh.prototype.clone = function ( object ) {\r\n\r\n	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );\r\n\r\n	object.duration = this.duration;\r\n	object.mirroredLoop = this.mirroredLoop;\r\n	object.time = this.time;\r\n\r\n	object.lastKeyframe = this.lastKeyframe;\r\n	object.currentKeyframe = this.currentKeyframe;\r\n\r\n	object.direction = this.direction;\r\n	object.directionBackwards = this.directionBackwards;\r\n\r\n	THREE.Mesh.prototype.clone.call( this, object );\r\n\r\n	return object;\r\n\r\n};\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.objects = [];\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LOD.prototype.constructor = THREE.LOD;\r\n\r\nTHREE.LOD.prototype.addLevel = function ( object, distance ) {\r\n\r\n	if ( distance === undefined ) distance = 0;\r\n\r\n	distance = Math.abs( distance );\r\n\r\n	for ( var l = 0; l < this.objects.length; l ++ ) {\r\n\r\n		if ( distance < this.objects[ l ].distance ) {\r\n\r\n			break;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.objects.splice( l, 0, { distance: distance, object: object } );\r\n	this.add( object );\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.getObjectForDistance = function ( distance ) {\r\n\r\n	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n		if ( distance < this.objects[ i ].distance ) {\r\n\r\n			break;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return this.objects[ i - 1 ].object;\r\n\r\n};\r\n\r\nTHREE.LOD.prototype.raycast = ( function () {\r\n\r\n	var matrixPosition = new THREE.Vector3();\r\n\r\n	return function ( raycaster, intersects ) {\r\n\r\n		matrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		var distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n		this.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.LOD.prototype.update = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n\r\n	return function ( camera ) {\r\n\r\n		if ( this.objects.length > 1 ) {\r\n\r\n			v1.setFromMatrixPosition( camera.matrixWorld );\r\n			v2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n			var distance = v1.distanceTo( v2 );\r\n\r\n			this.objects[ 0 ].object.visible = true;\r\n\r\n			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {\r\n\r\n				if ( distance >= this.objects[ i ].distance ) {\r\n\r\n					this.objects[ i - 1 ].object.visible = false;\r\n					this.objects[ i     ].object.visible = true;\r\n\r\n				} else {\r\n\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			for ( ; i < l; i ++ ) {\r\n\r\n				this.objects[ i ].object.visible = false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n}();\r\n\r\nTHREE.LOD.prototype.clone = function ( object ) {\r\n\r\n	if ( object === undefined ) object = new THREE.LOD();\r\n\r\n	THREE.Object3D.prototype.clone.call( this, object );\r\n\r\n	for ( var i = 0, l = this.objects.length; i < l; i ++ ) {\r\n		var x = this.objects[ i ].object.clone();\r\n		x.visible = i === 0;\r\n		object.addLevel( x, this.objects[ i ].distance );\r\n	}\r\n\r\n	return object;\r\n\r\n};\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = ( function () {\r\n\r\n	var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );\r\n	var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );\r\n	var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n	return function ( material ) {\r\n\r\n		THREE.Object3D.call( this );\r\n\r\n		this.type = 'Sprite';\r\n\r\n		this.geometry = geometry;\r\n		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n	};\r\n\r\n} )();\r\n\r\nTHREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Sprite.prototype.constructor = THREE.Sprite;\r\n\r\nTHREE.Sprite.prototype.raycast = ( function () {\r\n\r\n	var matrixPosition = new THREE.Vector3();\r\n\r\n	return function ( raycaster, intersects ) {\r\n\r\n		matrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		var distance = raycaster.ray.distanceToPoint( matrixPosition );\r\n\r\n		if ( distance > this.scale.x ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		intersects.push( {\r\n\r\n			distance: distance,\r\n			point: this.position,\r\n			face: null,\r\n			object: this\r\n\r\n		} );\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.Sprite.prototype.clone = function ( object ) {\r\n\r\n	if ( object === undefined ) object = new THREE.Sprite( this.material );\r\n\r\n	THREE.Object3D.prototype.clone.call( this, object );\r\n\r\n	return object;\r\n\r\n};\r\n\r\n// Backwards compatibility\r\n\r\nTHREE.Particle = THREE.Sprite;\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.lensFlares = [];\r\n\r\n	this.positionScreen = new THREE.Vector3();\r\n	this.customUpdateCallback = undefined;\r\n\r\n	if( texture !== undefined ) {\r\n\r\n		this.add( texture, size, distance, blending, color );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.LensFlare.prototype.constructor = THREE.LensFlare;\r\n\r\n\r\n/*\r\n * Add: adds another flare\r\n */\r\n\r\nTHREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n	if ( size === undefined ) size = - 1;\r\n	if ( distance === undefined ) distance = 0;\r\n	if ( opacity === undefined ) opacity = 1;\r\n	if ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n	if ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n	distance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n	this.lensFlares.push( {\r\n		texture: texture, 			// THREE.Texture\r\n		size: size, 				// size in pixels (-1 = use texture.width)\r\n		distance: distance, 		// distance (0-1) from light source (0=at light source)\r\n		x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back\r\n		scale: 1, 					// scale\r\n		rotation: 1, 				// rotation\r\n		opacity: opacity,			// opacity\r\n		color: color,				// color\r\n		blending: blending			// blending\r\n	} );\r\n\r\n};\r\n\r\n/*\r\n * Update lens flares update positions on all flares based on the screen position\r\n * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n */\r\n\r\nTHREE.LensFlare.prototype.updateLensFlares = function () {\r\n\r\n	var f, fl = this.lensFlares.length;\r\n	var flare;\r\n	var vecX = - this.positionScreen.x * 2;\r\n	var vecY = - this.positionScreen.y * 2;\r\n\r\n	for( f = 0; f < fl; f ++ ) {\r\n\r\n		flare = this.lensFlares[ f ];\r\n\r\n		flare.x = this.positionScreen.x + vecX * flare.distance;\r\n		flare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n		flare.wantedRotation = flare.x * Math.PI * 0.25;\r\n		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Scene';\r\n\r\n	this.fog = null;\r\n	this.overrideMaterial = null;\r\n\r\n	this.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.clone = function ( object ) {\r\n\r\n	if ( object === undefined ) object = new THREE.Scene();\r\n\r\n	THREE.Object3D.prototype.clone.call( this, object );\r\n\r\n	if ( this.fog !== null ) object.fog = this.fog.clone();\r\n	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();\r\n\r\n	object.autoUpdate = this.autoUpdate;\r\n	object.matrixAutoUpdate = this.matrixAutoUpdate;\r\n\r\n	return object;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n	this.name = '';\r\n\r\n	this.color = new THREE.Color( color );\r\n\r\n	this.near = ( near !== undefined ) ? near : 1;\r\n	this.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n	return new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n	this.name = '';\r\n\r\n	this.color = new THREE.Color( color );\r\n	this.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n	return new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment'] = \"#ifdef ALPHATEST\\n\\n	if ( gl_FragColor.a < ALPHATEST ) discard;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex'] = \"vLightFront = vec3( 0.0 );\\n\\n#ifdef DOUBLE_SIDED\\n\\n	vLightBack = vec3( 0.0 );\\n\\n#endif\\n\\ntransformedNormal = normalize( transformedNormal );\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n	vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\n	vec3 dirVector = normalize( lDirection.xyz );\\n\\n	float dotProduct = dot( transformedNormal, dirVector );\\n	vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n	#ifdef DOUBLE_SIDED\\n\\n		vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n		#ifdef WRAP_AROUND\\n\\n			vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n		#endif\\n\\n	#endif\\n\\n	#ifdef WRAP_AROUND\\n\\n		vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n		directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\\n\\n		#ifdef DOUBLE_SIDED\\n\\n			directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\\n\\n		#endif\\n\\n	#endif\\n\\n	vLightFront += directionalLightColor[ i ] * directionalLightWeighting;\\n\\n	#ifdef DOUBLE_SIDED\\n\\n		vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\\n\\n	#endif\\n\\n}\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n		float lDistance = 1.0;\\n		if ( pointLightDistance[ i ] > 0.0 )\\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\n\\n		lVector = normalize( lVector );\\n		float dotProduct = dot( transformedNormal, lVector );\\n\\n		vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n		#ifdef DOUBLE_SIDED\\n\\n			vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n			#ifdef WRAP_AROUND\\n\\n				vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n			#endif\\n\\n		#endif\\n\\n		#ifdef WRAP_AROUND\\n\\n			vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n			pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\\n\\n			#ifdef DOUBLE_SIDED\\n\\n				pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\\n\\n			#endif\\n\\n		#endif\\n\\n		vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\\n\\n		#ifdef DOUBLE_SIDED\\n\\n			vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\\n\\n		#endif\\n\\n	}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n		vec3 lVector = lPosition.xyz - mvPosition.xyz;\\n\\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\\n\\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n			float lDistance = 1.0;\\n			if ( spotLightDistance[ i ] > 0.0 )\\n				lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\n\\n			lVector = normalize( lVector );\\n\\n			float dotProduct = dot( transformedNormal, lVector );\\n			vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\\n\\n			#ifdef DOUBLE_SIDED\\n\\n				vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\\n\\n				#ifdef WRAP_AROUND\\n\\n					vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\\n\\n				#endif\\n\\n			#endif\\n\\n			#ifdef WRAP_AROUND\\n\\n				vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\\n				spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\\n\\n				#ifdef DOUBLE_SIDED\\n\\n					spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\\n\\n				#endif\\n\\n			#endif\\n\\n			vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\\n\\n			#ifdef DOUBLE_SIDED\\n\\n				vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\\n\\n			#endif\\n\\n		}\\n\\n	}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\n		vec3 lVector = normalize( lDirection.xyz );\\n\\n		float dotProduct = dot( transformedNormal, lVector );\\n\\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n		float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\\n\\n		vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n		#ifdef DOUBLE_SIDED\\n\\n			vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\\n\\n		#endif\\n\\n	}\\n\\n#endif\\n\\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\\n\\n#ifdef DOUBLE_SIDED\\n\\n	vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment'] = \"#ifdef USE_MAP\\n\\n	uniform sampler2D map;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'default_vertex'] = \"#ifdef USE_SKINNING\\n\\n	vec4 mvPosition = modelViewMatrix * skinned;\\n\\n#elif defined( USE_MORPHTARGETS )\\n\\n	vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\\n\\n#else\\n\\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\\n#endif\\n\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n	varying vec2 vUv;\\n\\n#endif\\n\\n#ifdef USE_MAP\\n\\n	uniform sampler2D map;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n	mat4 skinMatrix = mat4( 0.0 );\\n	skinMatrix += skinWeight.x * boneMatX;\\n	skinMatrix += skinWeight.y * boneMatY;\\n	skinMatrix += skinWeight.z * boneMatZ;\\n	skinMatrix += skinWeight.w * boneMatW;\\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\\n	#ifdef USE_MORPHNORMALS\\n\\n	vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\\n\\n	#else\\n\\n	vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		varying float vFragDepth;\\n\\n	#endif\\n\\n	uniform float logDepthBufFC;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n	varying vec2 vUv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment'] = \"vec3 normal = normalize( vNormal );\\nvec3 viewPosition = normalize( vViewPosition );\\n\\n#ifdef DOUBLE_SIDED\\n\\n	normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\\n#endif\\n\\n#ifdef USE_NORMALMAP\\n\\n	normal = perturbNormal2Arb( -vViewPosition, normal );\\n\\n#elif defined( USE_BUMPMAP )\\n\\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	vec3 pointDiffuse = vec3( 0.0 );\\n	vec3 pointSpecular = vec3( 0.0 );\\n\\n	for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n		vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n		float lDistance = 1.0;\\n		if ( pointLightDistance[ i ] > 0.0 )\\n			lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\n\\n		lVector = normalize( lVector );\\n\\n				// diffuse\\n\\n		float dotProduct = dot( normal, lVector );\\n\\n		#ifdef WRAP_AROUND\\n\\n			float pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n			float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n			vec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n		#else\\n\\n			float pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n		#endif\\n\\n		pointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\n\\n				// specular\\n\\n		vec3 pointHalfVector = normalize( lVector + viewPosition );\\n		float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n		float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n		pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n\\n	}\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	vec3 spotDiffuse = vec3( 0.0 );\\n	vec3 spotSpecular = vec3( 0.0 );\\n\\n	for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\\n\\n		vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\\n		vec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n		float lDistance = 1.0;\\n		if ( spotLightDistance[ i ] > 0.0 )\\n			lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\\n\\n		lVector = normalize( lVector );\\n\\n		float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\\n\\n		if ( spotEffect > spotLightAngleCos[ i ] ) {\\n\\n			spotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\\n\\n					// diffuse\\n\\n			float dotProduct = dot( normal, lVector );\\n\\n			#ifdef WRAP_AROUND\\n\\n				float spotDiffuseWeightFull = max( dotProduct, 0.0 );\\n				float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n				vec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\\n\\n			#else\\n\\n				float spotDiffuseWeight = max( dotProduct, 0.0 );\\n\\n			#endif\\n\\n			spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\\n\\n					// specular\\n\\n			vec3 spotHalfVector = normalize( lVector + viewPosition );\\n			float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\\n			float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\\n\\n			float specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n			vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\\n			spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\\n\\n		}\\n\\n	}\\n\\n#endif\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	vec3 dirDiffuse = vec3( 0.0 );\\n	vec3 dirSpecular = vec3( 0.0 );\\n\\n	for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n		vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\n		vec3 dirVector = normalize( lDirection.xyz );\\n\\n				// diffuse\\n\\n		float dotProduct = dot( normal, dirVector );\\n\\n		#ifdef WRAP_AROUND\\n\\n			float dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n			float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n			vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n		#else\\n\\n			float dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n		#endif\\n\\n		dirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n		// specular\\n\\n		vec3 dirHalfVector = normalize( dirVector + viewPosition );\\n		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n		float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n		/*\\n		// fresnel term from skin shader\\n		const float F0 = 0.128;\\n\\n		float base = 1.0 - dot( viewPosition, dirHalfVector );\\n		float exponential = pow( base, 5.0 );\\n\\n		float fresnel = exponential + F0 * ( 1.0 - exponential );\\n		*/\\n\\n		/*\\n		// fresnel term from fresnel shader\\n		const float mFresnelBias = 0.08;\\n		const float mFresnelScale = 0.3;\\n		const float mFresnelPower = 5.0;\\n\\n		float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\\n		*/\\n\\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n		// 		dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\\n\\n		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n		dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\n\\n	}\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	vec3 hemiDiffuse = vec3( 0.0 );\\n	vec3 hemiSpecular = vec3( 0.0 );\\n\\n	for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\\n\\n		vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\\n		vec3 lVector = normalize( lDirection.xyz );\\n\\n		// diffuse\\n\\n		float dotProduct = dot( normal, lVector );\\n		float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\\n\\n		vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\\n\\n		hemiDiffuse += diffuse * hemiColor;\\n\\n		// specular (sky light)\\n\\n		vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\\n		float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\\n		float hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\\n\\n		// specular (ground light)\\n\\n		vec3 lVectorGround = -lVector;\\n\\n		vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\\n		float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\\n		float hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\\n\\n		float dotProductGround = dot( normal, lVectorGround );\\n\\n		float specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n		vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\\n		vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\\n		hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\\n\\n	}\\n\\n#endif\\n\\nvec3 totalDiffuse = vec3( 0.0 );\\nvec3 totalSpecular = vec3( 0.0 );\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	totalDiffuse += dirDiffuse;\\n	totalSpecular += dirSpecular;\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	totalDiffuse += hemiDiffuse;\\n	totalSpecular += hemiSpecular;\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	totalDiffuse += pointDiffuse;\\n	totalSpecular += pointSpecular;\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	totalDiffuse += spotDiffuse;\\n	totalSpecular += spotSpecular;\\n\\n#endif\\n\\n#ifdef METAL\\n\\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\\n\\n#else\\n\\n	gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment'] = \"#ifdef USE_FOG\\n\\n	uniform vec3 fogColor;\\n\\n	#ifdef FOG_EXP2\\n\\n		uniform float fogDensity;\\n\\n	#else\\n\\n		uniform float fogNear;\\n		uniform float fogFar;\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex'] = \"#ifdef USE_MORPHNORMALS\\n\\n	vec3 morphedNormal = vec3( 0.0 );\\n\\n	morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n	morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n	morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n	morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n\\n	morphedNormal += normal;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment'] = \"#ifdef USE_ENVMAP\\n\\n	uniform float reflectivity;\\n	#ifdef ENVMAP_TYPE_CUBE\\n		uniform samplerCube envMap;\\n	#else\\n		uniform sampler2D envMap;\\n	#endif\\n	uniform float flipEnvMap;\\n\\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n		uniform float refractionRatio;\\n\\n	#else\\n\\n		varying vec3 vReflect;\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment'] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment'] = \"#ifdef USE_NORMALMAP\\n\\n	uniform sampler2D normalMap;\\n	uniform vec2 normalScale;\\n\\n			// Per-Pixel Tangent Space Normal Mapping\\n			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\\n\\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\\n		vec3 q0 = dFdx( eye_pos.xyz );\\n		vec3 q1 = dFdy( eye_pos.xyz );\\n		vec2 st0 = dFdx( vUv.st );\\n		vec2 st1 = dFdy( vUv.st );\\n\\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n		vec3 N = normalize( surf_norm );\\n\\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n		mapN.xy = normalScale * mapN.xy;\\n		mat3 tsn = mat3( S, T, N );\\n		return normalize( tsn * mapN );\\n\\n	}\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n	varying vec3 vWorldPosition;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n	varying vec2 vUv2;\\n	uniform sampler2D lightMap;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n		vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\\n\\n	}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_vertex'] = \"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n	vWorldPosition = worldPosition.xyz;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment'] = \"#ifdef USE_MAP\\n\\n	vec4 texelColor = texture2D( map, vUv );\\n\\n	#ifdef GAMMA_INPUT\\n\\n		texelColor.xyz *= texelColor.xyz;\\n\\n	#endif\\n\\n	gl_FragColor = gl_FragColor * texelColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_vertex'] = \"#ifdef USE_LIGHTMAP\\n\\n	vUv2 = uv2;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment'] = \"#ifdef USE_MAP\\n\\n	gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment'] = \"#ifdef USE_COLOR\\n\\n	varying vec3 vColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex'] = \"#ifdef USE_COLOR\\n\\n	#ifdef GAMMA_INPUT\\n\\n		vColor = color * color;\\n\\n	#else\\n\\n		vColor = color;\\n\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex'] = \"#ifdef USE_SKINNING\\n\\n	#ifdef USE_MORPHTARGETS\\n\\n	vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\\n\\n	#else\\n\\n	vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\\n\\n	#endif\\n\\n	vec4 skinned = vec4( 0.0 );\\n	skinned += boneMatX * skinVertex * skinWeight.x;\\n	skinned += boneMatY * skinVertex * skinWeight.y;\\n	skinned += boneMatZ * skinVertex * skinWeight.z;\\n	skinned += boneMatW * skinVertex * skinWeight.w;\\n	skinned  = bindMatrixInverse * skinned;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n	varying vec3 vReflect;\\n\\n	uniform float refractionRatio;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'linear_to_gamma_fragment'] = \"#ifdef GAMMA_OUTPUT\\n\\n	gl_FragColor.xyz = sqrt( gl_FragColor.xyz );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex'] = \"#ifdef USE_COLOR\\n\\n	varying vec3 vColor;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = \"uniform vec3 ambient;\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\n\\nuniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n	uniform vec3 wrapRGB;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n	varying vec2 vUv;\\n	uniform vec4 offsetRepeat;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment'] = \"#ifdef USE_ENVMAP\\n\\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\\n		// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\\n		// Transforming Normal Vectors with the Inverse Transformation\\n\\n		vec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\\n\\n		#ifdef ENVMAP_MODE_REFLECTION\\n\\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\\n		#else\\n\\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n		#endif\\n\\n	#else\\n\\n		vec3 reflectVec = vReflect;\\n\\n	#endif\\n\\n	#ifdef DOUBLE_SIDED\\n		float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n	#else\\n		float flipNormal = 1.0;\\n	#endif\\n\\n	#ifdef ENVMAP_TYPE_CUBE\\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\\n	#elif defined( ENVMAP_TYPE_EQUIREC )\\n		vec2 sampleUV;\\n		sampleUV.y = clamp( flipNormal * reflectVec.y * 0.5 + 0.5, 0.0, 1.0);\\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * 0.15915494309189533576888376337251 + 0.5; // reciprocal( 2 PI ) + 0.5\\n		vec4 envColor = texture2D( envMap, sampleUV );\\n		\\n	#elif defined( ENVMAP_TYPE_SPHERE )\\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n	#endif\\n\\n	#ifdef GAMMA_INPUT\\n\\n		envColor.xyz *= envColor.xyz;\\n\\n	#endif\\n\\n	#ifdef ENVMAP_BLENDING_MULTIPLY\\n\\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * envColor.xyz, specularStrength * reflectivity );\\n\\n	#elif defined( ENVMAP_BLENDING_MIX )\\n\\n		gl_FragColor.xyz = mix( gl_FragColor.xyz, envColor.xyz, specularStrength * reflectivity );\\n\\n	#elif defined( ENVMAP_BLENDING_ADD )\\n\\n		gl_FragColor.xyz += envColor.xyz * specularStrength * reflectivity;\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment'] = \"#ifdef USE_SPECULARMAP\\n\\n	uniform sampler2D specularMap;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n	gl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		vFragDepth = 1.0 + gl_Position.w;\\n\\n#else\\n\\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n	#ifndef USE_MORPHNORMALS\\n\\n	uniform float morphTargetInfluences[ 8 ];\\n\\n	#else\\n\\n	uniform float morphTargetInfluences[ 4 ];\\n\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment'] = \"float specularStrength;\\n\\n#ifdef USE_SPECULARMAP\\n\\n	vec4 texelSpecular = texture2D( specularMap, vUv );\\n	specularStrength = texelSpecular.r;\\n\\n#else\\n\\n	specularStrength = 1.0;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment'] = \"#ifdef USE_FOG\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\\n	#else\\n\\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\\n\\n	#endif\\n\\n	#ifdef FOG_EXP2\\n\\n		const float LOG2 = 1.442695;\\n		float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\\n		fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\\n\\n	#else\\n\\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\\n\\n	#endif\\n	\\n	gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment'] = \"#ifdef USE_BUMPMAP\\n\\n	uniform sampler2D bumpMap;\\n	uniform float bumpScale;\\n\\n			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\\n			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\\n\\n			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\\n\\n	vec2 dHdxy_fwd() {\\n\\n		vec2 dSTdx = dFdx( vUv );\\n		vec2 dSTdy = dFdy( vUv );\\n\\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\\n		return vec2( dBx, dBy );\\n\\n	}\\n\\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\\n		vec3 vSigmaX = dFdx( surf_pos );\\n		vec3 vSigmaY = dFdy( surf_pos );\\n		vec3 vN = surf_norm;		// normalized\\n\\n		vec3 R1 = cross( vSigmaY, vN );\\n		vec3 R2 = cross( vN, vSigmaX );\\n\\n		float fDet = dot( vSigmaX, R1 );\\n\\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n		return normalize( abs( fDet ) * surf_norm - vGrad );\\n\\n	}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex'] = \"#ifdef USE_SKINNING\\n\\n	vec3 objectNormal = skinnedNormal.xyz;\\n\\n#elif defined( USE_MORPHNORMALS )\\n\\n	vec3 objectNormal = morphedNormal;\\n\\n#else\\n\\n	vec3 objectNormal = normal;\\n\\n#endif\\n\\n#ifdef FLIP_SIDED\\n\\n	objectNormal = -objectNormal;\\n\\n#endif\\n\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment'] = \"uniform vec3 ambientLightColor;\\n\\n#if MAX_DIR_LIGHTS > 0\\n\\n	uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\\n	uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_HEMI_LIGHTS > 0\\n\\n	uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\\n	uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_POINT_LIGHTS > 0\\n\\n	uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\\n\\n	uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\\n	uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0\\n\\n	uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\\n	uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\\n	uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\\n\\n	uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\\n\\n#endif\\n\\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\\n\\n	varying vec3 vWorldPosition;\\n\\n#endif\\n\\n#ifdef WRAP_AROUND\\n\\n	uniform vec3 wrapRGB;\\n\\n#endif\\n\\nvarying vec3 vViewPosition;\\nvarying vec3 vNormal;\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex'] = \"#ifdef USE_SKINNING\\n\\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_vertex'] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\\n\\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment'] = \"#ifdef USE_LIGHTMAP\\n\\n	gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex'] = \"#ifdef USE_SHADOWMAP\\n\\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\\n	uniform mat4 shadowMatrix[ MAX_SHADOWS ];\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment'] = \"#ifdef USE_COLOR\\n\\n	gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex'] = \"#ifdef USE_MORPHTARGETS\\n\\n	vec3 morphed = vec3( 0.0 );\\n	morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n	morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n	morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n	morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\\n	#ifndef USE_MORPHNORMALS\\n\\n	morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n	morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n	morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n	morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\\n	#endif\\n\\n	morphed += position;\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex'] = \"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\\n\\n	vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\\n	worldNormal = normalize( worldNormal );\\n\\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\\n	#ifdef ENVMAP_MODE_REFLECTION\\n\\n		vReflect = reflect( cameraToVertex, worldNormal );\\n\\n	#else\\n\\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n	#ifdef SHADOWMAP_DEBUG\\n\\n		vec3 frustumColors[3];\\n		frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\\n		frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\\n		frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\\n\\n	#endif\\n\\n	#ifdef SHADOWMAP_CASCADE\\n\\n		int inFrustumCount = 0;\\n\\n	#endif\\n\\n	float fDepth;\\n	vec3 shadowColor = vec3( 1.0 );\\n\\n	for( int i = 0; i < MAX_SHADOWS; i ++ ) {\\n\\n		vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\\n\\n				// if ( something && something ) breaks ATI OpenGL shader compiler\\n				// if ( all( something, something ) ) using this instead\\n\\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n		bool inFrustum = all( inFrustumVec );\\n\\n				// don't shadow pixels outside of light frustum\\n				// use just first frustum (for cascades)\\n				// don't shadow pixels behind far plane of light frustum\\n\\n		#ifdef SHADOWMAP_CASCADE\\n\\n			inFrustumCount += int( inFrustum );\\n			bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\\n\\n		#else\\n\\n			bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\\n		#endif\\n\\n		bool frustumTest = all( frustumTestVec );\\n\\n		if ( frustumTest ) {\\n\\n			shadowCoord.z += shadowBias[ i ];\\n\\n			#if defined( SHADOWMAP_TYPE_PCF )\\n\\n						// Percentage-close filtering\\n						// (9 pixel kernel)\\n						// http://fabiensanglard.net/shadowmappingPCF/\\n\\n				float shadow = 0.0;\\n\\n		/*\\n						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\\n						// must enroll loop manually\\n\\n				for ( float y = -1.25; y <= 1.25; y += 1.25 )\\n					for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\\n\\n						vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\\n\\n								// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\\n								//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\\n\\n						float fDepth = unpackDepth( rgbaDepth );\\n\\n						if ( fDepth < shadowCoord.z )\\n							shadow += 1.0;\\n\\n				}\\n\\n				shadow /= 9.0;\\n\\n		*/\\n\\n				const float shadowDelta = 1.0 / 9.0;\\n\\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n				float dx0 = -1.25 * xPixelOffset;\\n				float dy0 = -1.25 * yPixelOffset;\\n				float dx1 = 1.25 * xPixelOffset;\\n				float dy1 = 1.25 * yPixelOffset;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n				if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\\n\\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n			#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\\n						// Percentage-close filtering\\n						// (9 pixel kernel)\\n						// http://fabiensanglard.net/shadowmappingPCF/\\n\\n				float shadow = 0.0;\\n\\n				float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\\n				float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\\n\\n				float dx0 = -1.0 * xPixelOffset;\\n				float dy0 = -1.0 * yPixelOffset;\\n				float dx1 = 1.0 * xPixelOffset;\\n				float dy1 = 1.0 * yPixelOffset;\\n\\n				mat3 shadowKernel;\\n				mat3 depthKernel;\\n\\n				depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\\n				depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\\n				depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\\n				depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\\n				depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\\n				depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\\n				depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\\n				depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\\n				depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\\n\\n				vec3 shadowZ = vec3( shadowCoord.z );\\n				shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\\n				shadowKernel[0] *= vec3(0.25);\\n\\n				shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\\n				shadowKernel[1] *= vec3(0.25);\\n\\n				shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\\n				shadowKernel[2] *= vec3(0.25);\\n\\n				vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\\n\\n				shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\\n				shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\\n\\n				vec4 shadowValues;\\n				shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\\n				shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\\n				shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\\n				shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\\n\\n				shadow = dot( shadowValues, vec4( 1.0 ) );\\n\\n				shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\\n\\n			#else\\n\\n				vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\\n				float fDepth = unpackDepth( rgbaDepth );\\n\\n				if ( fDepth < shadowCoord.z )\\n\\n		// spot with multiple shadows is darker\\n\\n					shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\\n\\n		// spot with multiple shadows has the same color as single shadow spot\\n\\n		// 					shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\\n\\n			#endif\\n\\n		}\\n\\n\\n		#ifdef SHADOWMAP_DEBUG\\n\\n			#ifdef SHADOWMAP_CASCADE\\n\\n				if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\\n\\n			#else\\n\\n				if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\\n\\n			#endif\\n\\n		#endif\\n\\n	}\\n\\n	#ifdef GAMMA_OUTPUT\\n\\n		shadowColor *= shadowColor;\\n\\n	#endif\\n\\n	gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex'] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\\n	#ifdef USE_SKINNING\\n\\n		vec4 worldPosition = modelMatrix * skinned;\\n\\n	#elif defined( USE_MORPHTARGETS )\\n\\n		vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\\n\\n	#else\\n\\n		vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment'] = \"#ifdef USE_SHADOWMAP\\n\\n	uniform sampler2D shadowMap[ MAX_SHADOWS ];\\n	uniform vec2 shadowMapSize[ MAX_SHADOWS ];\\n\\n	uniform float shadowDarkness[ MAX_SHADOWS ];\\n	uniform float shadowBias[ MAX_SHADOWS ];\\n\\n	varying vec4 vShadowCoord[ MAX_SHADOWS ];\\n\\n	float unpackDepth( const in vec4 rgba_depth ) {\\n\\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\\n		float depth = dot( rgba_depth, bit_shift );\\n		return depth;\\n\\n	}\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex'] = \"#ifdef USE_SKINNING\\n\\n	uniform mat4 bindMatrix;\\n	uniform mat4 bindMatrixInverse;\\n\\n	#ifdef BONE_TEXTURE\\n\\n		uniform sampler2D boneTexture;\\n		uniform int boneTextureWidth;\\n		uniform int boneTextureHeight;\\n\\n		mat4 getBoneMatrix( const in float i ) {\\n\\n			float j = i * 4.0;\\n			float x = mod( j, float( boneTextureWidth ) );\\n			float y = floor( j / float( boneTextureWidth ) );\\n\\n			float dx = 1.0 / float( boneTextureWidth );\\n			float dy = 1.0 / float( boneTextureHeight );\\n\\n			y = dy * ( y + 0.5 );\\n\\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\\n			mat4 bone = mat4( v1, v2, v3, v4 );\\n\\n			return bone;\\n\\n		}\\n\\n	#else\\n\\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\\n\\n		mat4 getBoneMatrix( const in float i ) {\\n\\n			mat4 bone = boneGlobalMatrices[ int(i) ];\\n			return bone;\\n\\n		}\\n\\n	#endif\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = \"#ifdef USE_LOGDEPTHBUF\\n\\n	uniform float logDepthBufFC;\\n\\n	#ifdef USE_LOGDEPTHBUF_EXT\\n\\n		#extension GL_EXT_frag_depth : enable\\n		varying float vFragDepth;\\n\\n	#endif\\n\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n	gl_FragColor.a *= texture2D( alphaMap, vUv ).g;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment'] = \"#ifdef USE_ALPHAMAP\\n\\n	uniform sampler2D alphaMap;\\n\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n	merge: function ( uniforms ) {\r\n\r\n		var merged = {};\r\n\r\n		for ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n			var tmp = this.clone( uniforms[ u ] );\r\n\r\n			for ( var p in tmp ) {\r\n\r\n				merged[ p ] = tmp[ p ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return merged;\r\n\r\n	},\r\n\r\n	clone: function ( uniforms_src ) {\r\n\r\n		var uniforms_dst = {};\r\n\r\n		for ( var u in uniforms_src ) {\r\n\r\n			uniforms_dst[ u ] = {};\r\n\r\n			for ( var p in uniforms_src[ u ] ) {\r\n\r\n				var parameter_src = uniforms_src[ u ][ p ];\r\n\r\n				if ( parameter_src instanceof THREE.Color ||\r\n					 parameter_src instanceof THREE.Vector2 ||\r\n					 parameter_src instanceof THREE.Vector3 ||\r\n					 parameter_src instanceof THREE.Vector4 ||\r\n					 parameter_src instanceof THREE.Matrix4 ||\r\n					 parameter_src instanceof THREE.Texture ) {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n				} else if ( parameter_src instanceof Array ) {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n				} else {\r\n\r\n					uniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return uniforms_dst;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n	common: {\r\n\r\n		\"diffuse\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n		\"opacity\" : { type: \"f\", value: 1.0 },\r\n\r\n		\"map\" : { type: \"t\", value: null },\r\n		\"offsetRepeat\" : { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n		\"lightMap\" : { type: \"t\", value: null },\r\n		\"specularMap\" : { type: \"t\", value: null },\r\n		\"alphaMap\" : { type: \"t\", value: null },\r\n\r\n		\"envMap\" : { type: \"t\", value: null },\r\n		\"flipEnvMap\" : { type: \"f\", value: - 1 },\r\n		\"reflectivity\" : { type: \"f\", value: 1.0 },\r\n		\"refractionRatio\" : { type: \"f\", value: 0.98 },\r\n\r\n		\"morphTargetInfluences\" : { type: \"f\", value: 0 }\r\n\r\n	},\r\n\r\n	bump: {\r\n\r\n		\"bumpMap\" : { type: \"t\", value: null },\r\n		\"bumpScale\" : { type: \"f\", value: 1 }\r\n\r\n	},\r\n\r\n	normalmap: {\r\n\r\n		\"normalMap\" : { type: \"t\", value: null },\r\n		\"normalScale\" : { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n	},\r\n\r\n	fog : {\r\n\r\n		\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n		\"fogNear\" : { type: \"f\", value: 1 },\r\n		\"fogFar\" : { type: \"f\", value: 2000 },\r\n		\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n	},\r\n\r\n	lights: {\r\n\r\n		\"ambientLightColor\" : { type: \"fv\", value: [] },\r\n\r\n		\"directionalLightDirection\" : { type: \"fv\", value: [] },\r\n		\"directionalLightColor\" : { type: \"fv\", value: [] },\r\n\r\n		\"hemisphereLightDirection\" : { type: \"fv\", value: [] },\r\n		\"hemisphereLightSkyColor\" : { type: \"fv\", value: [] },\r\n		\"hemisphereLightGroundColor\" : { type: \"fv\", value: [] },\r\n\r\n		\"pointLightColor\" : { type: \"fv\", value: [] },\r\n		\"pointLightPosition\" : { type: \"fv\", value: [] },\r\n		\"pointLightDistance\" : { type: \"fv1\", value: [] },\r\n\r\n		\"spotLightColor\" : { type: \"fv\", value: [] },\r\n		\"spotLightPosition\" : { type: \"fv\", value: [] },\r\n		\"spotLightDirection\" : { type: \"fv\", value: [] },\r\n		\"spotLightDistance\" : { type: \"fv1\", value: [] },\r\n		\"spotLightAngleCos\" : { type: \"fv1\", value: [] },\r\n		\"spotLightExponent\" : { type: \"fv1\", value: [] }\r\n\r\n	},\r\n\r\n	particle: {\r\n\r\n		\"psColor\" : { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n		\"opacity\" : { type: \"f\", value: 1.0 },\r\n		\"size\" : { type: \"f\", value: 1.0 },\r\n		\"scale\" : { type: \"f\", value: 1.0 },\r\n		\"map\" : { type: \"t\", value: null },\r\n\r\n		\"fogDensity\" : { type: \"f\", value: 0.00025 },\r\n		\"fogNear\" : { type: \"f\", value: 1 },\r\n		\"fogFar\" : { type: \"f\", value: 2000 },\r\n		\"fogColor\" : { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n	},\r\n\r\n	shadowmap: {\r\n\r\n		\"shadowMap\": { type: \"tv\", value: [] },\r\n		\"shadowMapSize\": { type: \"v2v\", value: [] },\r\n\r\n		\"shadowBias\" : { type: \"fv1\", value: [] },\r\n		\"shadowDarkness\": { type: \"fv1\", value: [] },\r\n\r\n		\"shadowMatrix\" : { type: \"m4v\", value: [] }\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n	'basic': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"map_vertex\" ],\r\n				THREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n\r\n			\"	#ifdef USE_ENVMAP\",\r\n\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n			\"	#endif\",\r\n\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"default_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	'lambert': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"lights\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n			{\r\n				\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n				\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n				\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"#define LAMBERT\",\r\n\r\n			\"varying vec3 vLightFront;\",\r\n\r\n			\"#ifdef DOUBLE_SIDED\",\r\n\r\n			\"	varying vec3 vLightBack;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lights_lambert_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"map_vertex\" ],\r\n				THREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"default_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"lights_lambert_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform float opacity;\",\r\n\r\n			\"varying vec3 vLightFront;\",\r\n\r\n			\"#ifdef DOUBLE_SIDED\",\r\n\r\n			\"	varying vec3 vLightBack;\",\r\n\r\n			\"#endif\",\r\n\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = vec4( vec3( 1.0 ), opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n			\"	#ifdef DOUBLE_SIDED\",\r\n\r\n					//\"float isFront = float( gl_FrontFacing );\",\r\n					//\"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;\",\r\n\r\n			\"		if ( gl_FrontFacing )\",\r\n			\"			gl_FragColor.xyz *= vLightFront;\",\r\n			\"		else\",\r\n			\"			gl_FragColor.xyz *= vLightBack;\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		gl_FragColor.xyz *= vLightFront;\",\r\n\r\n			\"	#endif\",\r\n\r\n				THREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	'phong': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"bump\" ],\r\n			THREE.UniformsLib[ \"normalmap\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n			THREE.UniformsLib[ \"lights\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ],\r\n\r\n			{\r\n				\"ambient\"  : { type: \"c\", value: new THREE.Color( 0xffffff ) },\r\n				\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n				\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n				\"shininess\": { type: \"f\", value: 30 },\r\n				\"wrapRGB\"  : { type: \"v3\", value: new THREE.Vector3( 1, 1, 1 ) }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"#define PHONG\",\r\n\r\n			\"varying vec3 vViewPosition;\",\r\n			\"varying vec3 vNormal;\",\r\n\r\n			THREE.ShaderChunk[ \"map_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"lights_phong_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"map_vertex\" ],\r\n				THREE.ShaderChunk[ \"lightmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n				THREE.ShaderChunk[ \"morphnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinnormal_vertex\" ],\r\n				THREE.ShaderChunk[ \"defaultnormal_vertex\" ],\r\n\r\n			\"	vNormal = normalize( transformedNormal );\",\r\n\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"default_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"	vViewPosition = -mvPosition.xyz;\",\r\n\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"envmap_vertex\" ],\r\n				THREE.ShaderChunk[ \"lights_phong_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"#define PHONG\",\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"uniform vec3 ambient;\",\r\n			\"uniform vec3 emissive;\",\r\n			\"uniform vec3 specular;\",\r\n			\"uniform float shininess;\",\r\n\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"alphamap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lightmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"envmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"lights_phong_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"bumpmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"normalmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"specularmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = vec4( vec3( 1.0 ), opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphamap_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"specularmap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"lights_phong_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"lightmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"envmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"linear_to_gamma_fragment\" ],\r\n\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	'particle_basic': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"particle\" ],\r\n			THREE.UniformsLib[ \"shadowmap\" ]\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"uniform float size;\",\r\n			\"uniform float scale;\",\r\n\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n			\"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n			\"	#ifdef USE_SIZEATTENUATION\",\r\n			\"		gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\r\n			\"	#else\",\r\n			\"		gl_PointSize = size;\",\r\n			\"	#endif\",\r\n\r\n			\"	gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n				THREE.ShaderChunk[ \"worldpos_vertex\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 psColor;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"map_particle_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"shadowmap_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = vec4( psColor, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"map_particle_fragment\" ],\r\n				THREE.ShaderChunk[ \"alphatest_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"shadowmap_fragment\" ],\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	'dashed': {\r\n\r\n		uniforms: THREE.UniformsUtils.merge( [\r\n\r\n			THREE.UniformsLib[ \"common\" ],\r\n			THREE.UniformsLib[ \"fog\" ],\r\n\r\n			{\r\n				\"scale\"    : { type: \"f\", value: 1 },\r\n				\"dashSize\" : { type: \"f\", value: 1 },\r\n				\"totalSize\": { type: \"f\", value: 2 }\r\n			}\r\n\r\n		] ),\r\n\r\n		vertexShader: [\r\n\r\n			\"uniform float scale;\",\r\n			\"attribute float lineDistance;\",\r\n\r\n			\"varying float vLineDistance;\",\r\n\r\n			THREE.ShaderChunk[ \"color_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"color_vertex\" ],\r\n\r\n			\"	vLineDistance = scale * lineDistance;\",\r\n\r\n			\"	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\r\n			\"	gl_Position = projectionMatrix * mvPosition;\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform vec3 diffuse;\",\r\n			\"uniform float opacity;\",\r\n\r\n			\"uniform float dashSize;\",\r\n			\"uniform float totalSize;\",\r\n\r\n			\"varying float vLineDistance;\",\r\n\r\n			THREE.ShaderChunk[ \"color_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"fog_pars_fragment\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	if ( mod( vLineDistance, totalSize ) > dashSize ) {\",\r\n\r\n			\"		discard;\",\r\n\r\n			\"	}\",\r\n\r\n			\"	gl_FragColor = vec4( diffuse, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n				THREE.ShaderChunk[ \"color_fragment\" ],\r\n				THREE.ShaderChunk[ \"fog_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	'depth': {\r\n\r\n		uniforms: {\r\n\r\n			\"mNear\": { type: \"f\", value: 1.0 },\r\n			\"mFar\" : { type: \"f\", value: 2000.0 },\r\n			\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"default_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform float mNear;\",\r\n			\"uniform float mFar;\",\r\n			\"uniform float opacity;\",\r\n\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"	#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n			\"		float depth = gl_FragDepthEXT / gl_FragCoord.w;\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		float depth = gl_FragCoord.z / gl_FragCoord.w;\",\r\n\r\n			\"	#endif\",\r\n\r\n			\"	float color = 1.0 - smoothstep( mNear, mFar, depth );\",\r\n			\"	gl_FragColor = vec4( vec3( color ), opacity );\",\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	'normal': {\r\n\r\n		uniforms: {\r\n\r\n			\"opacity\" : { type: \"f\", value: 1.0 }\r\n\r\n		},\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vNormal;\",\r\n\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vNormal = normalize( normalMatrix * normal );\",\r\n\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"default_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform float opacity;\",\r\n			\"varying vec3 vNormal;\",\r\n\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	/* -------------------------------------------------------------------------\r\n	//	Cube map shader\r\n	 ------------------------------------------------------------------------- */\r\n\r\n	'cube': {\r\n\r\n		uniforms: { \"tCube\": { type: \"t\", value: null },\r\n					\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n			\"	vWorldPosition = worldPosition.xyz;\",\r\n\r\n			\"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform samplerCube tCube;\",\r\n			\"uniform float tFlip;\",\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	/* -------------------------------------------------------------------------\r\n	//	Cube map shader\r\n	 ------------------------------------------------------------------------- */\r\n\r\n	'equirect': {\r\n\r\n		uniforms: { \"tEquirect\": { type: \"t\", value: null },\r\n					\"tFlip\": { type: \"f\", value: - 1 } },\r\n\r\n		vertexShader: [\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n			\"	vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\r\n			\"	vWorldPosition = worldPosition.xyz;\",\r\n\r\n			\"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			\"uniform sampler2D tEquirect;\",\r\n			\"uniform float tFlip;\",\r\n\r\n			\"varying vec3 vWorldPosition;\",\r\n\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				// \"	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\",\r\n				\"vec3 direction = normalize( vWorldPosition );\",\r\n				\"vec2 sampleUV;\",\r\n				\"sampleUV.y = clamp( tFlip * direction.y * -0.5 + 0.5, 0.0, 1.0);\",\r\n				\"sampleUV.x = atan( direction.z, direction.x ) * 0.15915494309189533576888376337251 + 0.5;\", // reciprocal( 2 PI ) + 0.5\r\n				\"gl_FragColor = texture2D( tEquirect, sampleUV );\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	},\r\n\r\n	/* Depth encoding into RGBA texture\r\n	 *\r\n	 * based on SpiderGL shadow map example\r\n	 * http://spidergl.org/example.php?id=6\r\n	 *\r\n	 * originally from\r\n	 * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD\r\n	 *\r\n	 * see also\r\n	 * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n	 */\r\n\r\n	'depthRGBA': {\r\n\r\n		uniforms: {},\r\n\r\n		vertexShader: [\r\n\r\n			THREE.ShaderChunk[ \"morphtarget_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"skinning_pars_vertex\" ],\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_vertex\" ],\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"skinbase_vertex\" ],\r\n				THREE.ShaderChunk[ \"morphtarget_vertex\" ],\r\n				THREE.ShaderChunk[ \"skinning_vertex\" ],\r\n				THREE.ShaderChunk[ \"default_vertex\" ],\r\n				THREE.ShaderChunk[ \"logdepthbuf_vertex\" ],\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\"),\r\n\r\n		fragmentShader: [\r\n\r\n			THREE.ShaderChunk[ \"logdepthbuf_pars_fragment\" ],\r\n\r\n			\"vec4 pack_depth( const in float depth ) {\",\r\n\r\n			\"	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\",\r\n			\"	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\",\r\n			\"	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\", // \"	vec4 res = fract( depth * bit_shift );\",\r\n			\"	res -= res.xxyz * bit_mask;\",\r\n			\"	return res;\",\r\n\r\n			\"}\",\r\n\r\n			\"void main() {\",\r\n\r\n				THREE.ShaderChunk[ \"logdepthbuf_fragment\" ],\r\n\r\n			\"	#ifdef USE_LOGDEPTHBUF_EXT\",\r\n\r\n			\"		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\",\r\n\r\n			\"	#else\",\r\n\r\n			\"		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\",\r\n\r\n			\"	#endif\",\r\n\r\n				//\"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );\",\r\n				//\"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );\",\r\n				//\"gl_FragData[ 0 ] = pack_depth( z );\",\r\n				//\"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );\",\r\n\r\n			\"}\"\r\n\r\n		].join(\"\\n\")\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n	console.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n	parameters = parameters || {};\r\n\r\n	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n	_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n	pixelRatio = 1,\r\n\r\n	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',\r\n\r\n	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n	_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\r\n	_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,\r\n\r\n	_clearColor = new THREE.Color( 0x000000 ),\r\n	_clearAlpha = 0;\r\n\r\n	var lights = [];\r\n\r\n	var _webglObjects = {};\r\n	var _webglObjectsImmediate = [];\r\n\r\n	var opaqueObjects = [];\r\n	var transparentObjects = [];\r\n\r\n	var sprites = [];\r\n	var lensFlares = [];\r\n\r\n	// public properties\r\n\r\n	this.domElement = _canvas;\r\n	this.context = null;\r\n\r\n	// clearing\r\n\r\n	this.autoClear = true;\r\n	this.autoClearColor = true;\r\n	this.autoClearDepth = true;\r\n	this.autoClearStencil = true;\r\n\r\n	// scene graph\r\n\r\n	this.sortObjects = true;\r\n\r\n	// physically based shading\r\n\r\n	this.gammaInput = false;\r\n	this.gammaOutput = false;\r\n\r\n	// shadow map\r\n\r\n	this.shadowMapEnabled = false;\r\n	this.shadowMapType = THREE.PCFShadowMap;\r\n	this.shadowMapCullFace = THREE.CullFaceFront;\r\n	this.shadowMapDebug = false;\r\n	this.shadowMapCascade = false;\r\n\r\n	// morphs\r\n\r\n	this.maxMorphTargets = 8;\r\n	this.maxMorphNormals = 4;\r\n\r\n	// flags\r\n\r\n	this.autoScaleCubemaps = true;\r\n\r\n	// info\r\n\r\n	this.info = {\r\n\r\n		memory: {\r\n\r\n			programs: 0,\r\n			geometries: 0,\r\n			textures: 0\r\n\r\n		},\r\n\r\n		render: {\r\n\r\n			calls: 0,\r\n			vertices: 0,\r\n			faces: 0,\r\n			points: 0\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// internal properties\r\n\r\n	var _this = this,\r\n\r\n	_programs = [],\r\n\r\n	// internal state cache\r\n\r\n	_currentProgram = null,\r\n	_currentFramebuffer = null,\r\n	_currentMaterialId = - 1,\r\n	_currentGeometryProgram = '',\r\n	_currentCamera = null,\r\n\r\n	_usedTextureUnits = 0,\r\n\r\n	// GL state cache\r\n\r\n	_oldDoubleSided = - 1,\r\n	_oldFlipSided = - 1,\r\n\r\n	_oldBlending = - 1,\r\n\r\n	_oldBlendEquation = - 1,\r\n	_oldBlendSrc = - 1,\r\n	_oldBlendDst = - 1,\r\n\r\n	_oldDepthTest = - 1,\r\n	_oldDepthWrite = - 1,\r\n\r\n	_oldPolygonOffset = null,\r\n	_oldPolygonOffsetFactor = null,\r\n	_oldPolygonOffsetUnits = null,\r\n\r\n	_oldLineWidth = null,\r\n\r\n	_viewportX = 0,\r\n	_viewportY = 0,\r\n	_viewportWidth = _canvas.width,\r\n	_viewportHeight = _canvas.height,\r\n	_currentWidth = 0,\r\n	_currentHeight = 0,\r\n\r\n	_newAttributes = new Uint8Array( 16 ),\r\n	_enabledAttributes = new Uint8Array( 16 ),\r\n\r\n	// frustum\r\n\r\n	_frustum = new THREE.Frustum(),\r\n\r\n	 // camera matrices cache\r\n\r\n	_projScreenMatrix = new THREE.Matrix4(),\r\n	_projScreenMatrixPS = new THREE.Matrix4(),\r\n\r\n	_vector3 = new THREE.Vector3(),\r\n\r\n	// light arrays cache\r\n\r\n	_direction = new THREE.Vector3(),\r\n\r\n	_lightsNeedUpdate = true,\r\n\r\n	_lights = {\r\n\r\n		ambient: [ 0, 0, 0 ],\r\n		directional: { length: 0, colors:[], positions: [] },\r\n		point: { length: 0, colors: [], positions: [], distances: [] },\r\n		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },\r\n		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }\r\n\r\n	};\r\n\r\n	// initialize\r\n\r\n	var _gl;\r\n\r\n	try {\r\n\r\n		var attributes = {\r\n			alpha: _alpha,\r\n			depth: _depth,\r\n			stencil: _stencil,\r\n			antialias: _antialias,\r\n			premultipliedAlpha: _premultipliedAlpha,\r\n			preserveDrawingBuffer: _preserveDrawingBuffer\r\n		};\r\n\r\n		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n		if ( _gl === null ) {\r\n\r\n			if ( _canvas.getContext( 'webgl') !== null ) {\r\n\r\n				throw 'Error creating WebGL context with your selected attributes.';\r\n\r\n			} else {\r\n\r\n				throw 'Error creating WebGL context.';\r\n\r\n			}\r\n\r\n		}\r\n\r\n		_canvas.addEventListener( 'webglcontextlost', function ( event ) {\r\n\r\n			event.preventDefault();\r\n\r\n			resetGLState();\r\n			setDefaultGLState();\r\n\r\n			_webglObjects = {};\r\n\r\n		}, false);\r\n\r\n	} catch ( error ) {\r\n\r\n		console.error( error );\r\n\r\n	}\r\n\r\n	if ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n		_gl.getShaderPrecisionFormat = function () {\r\n\r\n			return {\r\n				'rangeMin': 1,\r\n				'rangeMax': 1,\r\n				'precision': 1\r\n			};\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n	extensions.get( 'OES_texture_float' );\r\n	extensions.get( 'OES_texture_float_linear' );\r\n	extensions.get( 'OES_standard_derivatives' );\r\n\r\n	if ( _logarithmicDepthBuffer ) {\r\n\r\n		extensions.get( 'EXT_frag_depth' );\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var setDefaultGLState = function () {\r\n\r\n		_gl.clearColor( 0, 0, 0, 1 );\r\n		_gl.clearDepth( 1 );\r\n		_gl.clearStencil( 0 );\r\n\r\n		_gl.enable( _gl.DEPTH_TEST );\r\n		_gl.depthFunc( _gl.LEQUAL );\r\n\r\n		_gl.frontFace( _gl.CCW );\r\n		_gl.cullFace( _gl.BACK );\r\n		_gl.enable( _gl.CULL_FACE );\r\n\r\n		_gl.enable( _gl.BLEND );\r\n		_gl.blendEquation( _gl.FUNC_ADD );\r\n		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	};\r\n\r\n	var resetGLState = function () {\r\n\r\n		_currentProgram = null;\r\n		_currentCamera = null;\r\n\r\n		_oldBlending = - 1;\r\n		_oldDepthTest = - 1;\r\n		_oldDepthWrite = - 1;\r\n		_oldDoubleSided = - 1;\r\n		_oldFlipSided = - 1;\r\n		_currentGeometryProgram = '';\r\n		_currentMaterialId = - 1;\r\n\r\n		_lightsNeedUpdate = true;\r\n\r\n		for ( var i = 0; i < _enabledAttributes.length; i ++ ) {\r\n\r\n			_enabledAttributes[ i ] = 0;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	setDefaultGLState();\r\n\r\n	this.context = _gl;\r\n\r\n	// GPU capabilities\r\n\r\n	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );\r\n	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );\r\n	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n	var _supportsVertexTextures = _maxVertexTextures > 0;\r\n	var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );\r\n\r\n	//\r\n\r\n	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );\r\n	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );\r\n	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );\r\n\r\n	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );\r\n	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );\r\n	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );\r\n\r\n	var getCompressedTextureFormats = ( function () {\r\n\r\n		var array;\r\n\r\n		return function () {\r\n\r\n			if ( array !== undefined ) {\r\n\r\n				return array;\r\n\r\n			}\r\n\r\n			array = [];\r\n\r\n			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {\r\n\r\n				var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n				for ( var i = 0; i < formats.length; i ++ ){\r\n\r\n					array.push( formats[ i ] );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return array;\r\n\r\n		};\r\n\r\n	} )();\r\n\r\n	// clamp precision to maximum available\r\n\r\n	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;\r\n	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;\r\n\r\n	if ( _precision === 'highp' && ! highpAvailable ) {\r\n\r\n		if ( mediumpAvailable ) {\r\n\r\n			_precision = 'mediump';\r\n			console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );\r\n\r\n		} else {\r\n\r\n			_precision = 'lowp';\r\n			console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	if ( _precision === 'mediump' && ! mediumpAvailable ) {\r\n\r\n		_precision = 'lowp';\r\n		console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );\r\n\r\n	}\r\n\r\n	// Plugins\r\n\r\n	var shadowMapPlugin = new THREE.ShadowMapPlugin( this, lights, _webglObjects, _webglObjectsImmediate );\r\n\r\n	var spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n	// API\r\n\r\n	this.getContext = function () {\r\n\r\n		return _gl;\r\n\r\n	};\r\n\r\n	this.forceContextLoss = function () {\r\n\r\n		extensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n	};\r\n\r\n	this.supportsVertexTextures = function () {\r\n\r\n		return _supportsVertexTextures;\r\n\r\n	};\r\n\r\n	this.supportsFloatTextures = function () {\r\n\r\n		return extensions.get( 'OES_texture_float' );\r\n\r\n	};\r\n\r\n	this.supportsStandardDerivatives = function () {\r\n\r\n		return extensions.get( 'OES_standard_derivatives' );\r\n\r\n	};\r\n\r\n	this.supportsCompressedTextureS3TC = function () {\r\n\r\n		return extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n	};\r\n\r\n	this.supportsCompressedTexturePVRTC = function () {\r\n\r\n		return extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n	};\r\n\r\n	this.supportsBlendMinMax = function () {\r\n\r\n		return extensions.get( 'EXT_blend_minmax' );\r\n\r\n	};\r\n\r\n	this.getMaxAnisotropy = ( function () {\r\n\r\n		var value;\r\n\r\n		return function () {\r\n\r\n			if ( value !== undefined ) {\r\n\r\n				return value;\r\n\r\n			}\r\n\r\n			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n			value = extension !== null ? _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;\r\n\r\n			return value;\r\n\r\n		}\r\n\r\n	} )();\r\n\r\n	this.getPrecision = function () {\r\n\r\n		return _precision;\r\n\r\n	};\r\n\r\n	this.getPixelRatio = function () {\r\n\r\n		return pixelRatio;\r\n\r\n	};\r\n\r\n	this.setPixelRatio = function ( value ) {\r\n\r\n		pixelRatio = value;\r\n\r\n	};\r\n\r\n	this.setSize = function ( width, height, updateStyle ) {\r\n\r\n		_canvas.width = width * pixelRatio;\r\n		_canvas.height = height * pixelRatio;\r\n\r\n		if ( updateStyle !== false ) {\r\n\r\n			_canvas.style.width = width + 'px';\r\n			_canvas.style.height = height + 'px';\r\n\r\n		}\r\n\r\n		this.setViewport( 0, 0, width, height );\r\n\r\n	};\r\n\r\n	this.setViewport = function ( x, y, width, height ) {\r\n\r\n		_viewportX = x * pixelRatio;\r\n		_viewportY = y * pixelRatio;\r\n\r\n		_viewportWidth = width * pixelRatio;\r\n		_viewportHeight = height * pixelRatio;\r\n\r\n		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );\r\n\r\n	};\r\n\r\n	this.setScissor = function ( x, y, width, height ) {\r\n\r\n		_gl.scissor(\r\n			x * pixelRatio,\r\n			y * pixelRatio,\r\n			width * pixelRatio,\r\n			height * pixelRatio\r\n		);\r\n\r\n	};\r\n\r\n	this.enableScissorTest = function ( enable ) {\r\n\r\n		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );\r\n\r\n	};\r\n\r\n	// Clearing\r\n\r\n	this.getClearColor = function () {\r\n\r\n		return _clearColor;\r\n\r\n	};\r\n\r\n	this.setClearColor = function ( color, alpha ) {\r\n\r\n		_clearColor.set( color );\r\n		_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	};\r\n\r\n	this.getClearAlpha = function () {\r\n\r\n		return _clearAlpha;\r\n\r\n	};\r\n\r\n	this.setClearAlpha = function ( alpha ) {\r\n\r\n		_clearAlpha = alpha;\r\n\r\n		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n	};\r\n\r\n	this.clear = function ( color, depth, stencil ) {\r\n\r\n		var bits = 0;\r\n\r\n		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n		_gl.clear( bits );\r\n\r\n	};\r\n\r\n	this.clearColor = function () {\r\n\r\n		_gl.clear( _gl.COLOR_BUFFER_BIT );\r\n\r\n	};\r\n\r\n	this.clearDepth = function () {\r\n\r\n		_gl.clear( _gl.DEPTH_BUFFER_BIT );\r\n\r\n	};\r\n\r\n	this.clearStencil = function () {\r\n\r\n		_gl.clear( _gl.STENCIL_BUFFER_BIT );\r\n\r\n	};\r\n\r\n	this.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n		this.setRenderTarget( renderTarget );\r\n		this.clear( color, depth, stencil );\r\n\r\n	};\r\n\r\n	// Reset\r\n\r\n	this.resetGLState = resetGLState;\r\n\r\n	// Buffer allocation\r\n\r\n	function createParticleBuffers ( geometry ) {\r\n\r\n		geometry.__webglVertexBuffer = _gl.createBuffer();\r\n		geometry.__webglColorBuffer = _gl.createBuffer();\r\n\r\n		_this.info.memory.geometries ++;\r\n\r\n	};\r\n\r\n	function createLineBuffers ( geometry ) {\r\n\r\n		geometry.__webglVertexBuffer = _gl.createBuffer();\r\n		geometry.__webglColorBuffer = _gl.createBuffer();\r\n		geometry.__webglLineDistanceBuffer = _gl.createBuffer();\r\n\r\n		_this.info.memory.geometries ++;\r\n\r\n	};\r\n\r\n	function createMeshBuffers ( geometryGroup ) {\r\n\r\n		geometryGroup.__webglVertexBuffer = _gl.createBuffer();\r\n		geometryGroup.__webglNormalBuffer = _gl.createBuffer();\r\n		geometryGroup.__webglTangentBuffer = _gl.createBuffer();\r\n		geometryGroup.__webglColorBuffer = _gl.createBuffer();\r\n		geometryGroup.__webglUVBuffer = _gl.createBuffer();\r\n		geometryGroup.__webglUV2Buffer = _gl.createBuffer();\r\n\r\n		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();\r\n		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();\r\n\r\n		geometryGroup.__webglFaceBuffer = _gl.createBuffer();\r\n		geometryGroup.__webglLineBuffer = _gl.createBuffer();\r\n\r\n		var numMorphTargets = geometryGroup.numMorphTargets;\r\n\r\n		if ( numMorphTargets ) {\r\n\r\n			geometryGroup.__webglMorphTargetsBuffers = [];\r\n\r\n			for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\r\n				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var numMorphNormals = geometryGroup.numMorphNormals;\r\n\r\n		if ( numMorphNormals ) {\r\n\r\n			geometryGroup.__webglMorphNormalsBuffers = [];\r\n\r\n			for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\r\n				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		_this.info.memory.geometries ++;\r\n\r\n	};\r\n\r\n	// Events\r\n\r\n	var onObjectRemoved = function ( event ) {\r\n\r\n		var object = event.target;\r\n\r\n		object.traverse( function ( child ) {\r\n\r\n			child.removeEventListener( 'remove', onObjectRemoved );\r\n\r\n			removeObject( child );\r\n\r\n		} );\r\n\r\n	};\r\n\r\n	var onGeometryDispose = function ( event ) {\r\n\r\n		var geometry = event.target;\r\n\r\n		geometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n		deallocateGeometry( geometry );\r\n\r\n	};\r\n\r\n	var onTextureDispose = function ( event ) {\r\n\r\n		var texture = event.target;\r\n\r\n		texture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n		deallocateTexture( texture );\r\n\r\n		_this.info.memory.textures --;\r\n\r\n\r\n	};\r\n\r\n	var onRenderTargetDispose = function ( event ) {\r\n\r\n		var renderTarget = event.target;\r\n\r\n		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n		deallocateRenderTarget( renderTarget );\r\n\r\n		_this.info.memory.textures --;\r\n\r\n	};\r\n\r\n	var onMaterialDispose = function ( event ) {\r\n\r\n		var material = event.target;\r\n\r\n		material.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n		deallocateMaterial( material );\r\n\r\n	};\r\n\r\n	// Buffer deallocation\r\n\r\n	var deleteBuffers = function ( geometry ) {\r\n\r\n		var buffers = [\r\n			'__webglVertexBuffer',\r\n			'__webglNormalBuffer',\r\n			'__webglTangentBuffer',\r\n			'__webglColorBuffer',\r\n			'__webglUVBuffer',\r\n			'__webglUV2Buffer',\r\n\r\n			'__webglSkinIndicesBuffer',\r\n			'__webglSkinWeightsBuffer',\r\n\r\n			'__webglFaceBuffer',\r\n			'__webglLineBuffer',\r\n\r\n			'__webglLineDistanceBuffer'\r\n		];\r\n\r\n		for ( var i = 0, l = buffers.length; i < l; i ++ ) {\r\n\r\n			var name = buffers[ i ];\r\n\r\n			if ( geometry[ name ] !== undefined ) {\r\n\r\n				_gl.deleteBuffer( geometry[ name ] );\r\n\r\n				delete geometry[ name ];\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// custom attributes\r\n\r\n		if ( geometry.__webglCustomAttributesList !== undefined ) {\r\n\r\n			for ( var name in geometry.__webglCustomAttributesList ) {\r\n\r\n				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ name ].buffer );\r\n\r\n			}\r\n\r\n			delete geometry.__webglCustomAttributesList;\r\n\r\n		}\r\n\r\n		_this.info.memory.geometries --;\r\n\r\n	};\r\n\r\n	var deallocateGeometry = function ( geometry ) {\r\n\r\n		delete geometry.__webglInit;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			for ( var name in geometry.attributes ) {\r\n\r\n				var attribute = geometry.attributes[ name ];\r\n\r\n				if ( attribute.buffer !== undefined ) {\r\n\r\n					_gl.deleteBuffer( attribute.buffer );\r\n\r\n					delete attribute.buffer;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			_this.info.memory.geometries --;\r\n\r\n		} else {\r\n\r\n			var geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n			if ( geometryGroupsList !== undefined ) {\r\n\r\n				for ( var i = 0, l = geometryGroupsList.length; i < l; i ++ ) {\r\n\r\n					var geometryGroup = geometryGroupsList[ i ];\r\n\r\n					if ( geometryGroup.numMorphTargets !== undefined ) {\r\n\r\n						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {\r\n\r\n							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );\r\n\r\n						}\r\n\r\n						delete geometryGroup.__webglMorphTargetsBuffers;\r\n\r\n					}\r\n\r\n					if ( geometryGroup.numMorphNormals !== undefined ) {\r\n\r\n						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {\r\n\r\n							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );\r\n\r\n						}\r\n\r\n						delete geometryGroup.__webglMorphNormalsBuffers;\r\n\r\n					}\r\n\r\n					deleteBuffers( geometryGroup );\r\n\r\n				}\r\n\r\n				delete geometryGroups[ geometry.id ];\r\n\r\n			} else {\r\n\r\n				deleteBuffers( geometry );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// TOFIX: Workaround for deleted geometry being currently bound\r\n\r\n		_currentGeometryProgram = '';\r\n\r\n	};\r\n\r\n	var deallocateTexture = function ( texture ) {\r\n\r\n		if ( texture.image && texture.image.__webglTextureCube ) {\r\n\r\n			// cube texture\r\n\r\n			_gl.deleteTexture( texture.image.__webglTextureCube );\r\n\r\n			delete texture.image.__webglTextureCube;\r\n\r\n		} else {\r\n\r\n			// 2D texture\r\n\r\n			if ( texture.__webglInit === undefined ) return;\r\n\r\n			_gl.deleteTexture( texture.__webglTexture );\r\n\r\n			delete texture.__webglTexture;\r\n			delete texture.__webglInit;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	var deallocateRenderTarget = function ( renderTarget ) {\r\n\r\n		if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;\r\n\r\n		_gl.deleteTexture( renderTarget.__webglTexture );\r\n\r\n		delete renderTarget.__webglTexture;\r\n\r\n		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n			for ( var i = 0; i < 6; i ++ ) {\r\n\r\n				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );\r\n				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );\r\n			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );\r\n\r\n		}\r\n\r\n		delete renderTarget.__webglFramebuffer;\r\n		delete renderTarget.__webglRenderbuffer;\r\n\r\n	};\r\n\r\n	var deallocateMaterial = function ( material ) {\r\n\r\n		var program = material.program.program;\r\n\r\n		if ( program === undefined ) return;\r\n\r\n		material.program = undefined;\r\n\r\n		// only deallocate GL program if this was the last use of shared program\r\n		// assumed there is only single copy of any program in the _programs list\r\n		// (that's how it's constructed)\r\n\r\n		var i, il, programInfo;\r\n		var deleteProgram = false;\r\n\r\n		for ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n			programInfo = _programs[ i ];\r\n\r\n			if ( programInfo.program === program ) {\r\n\r\n				programInfo.usedTimes --;\r\n\r\n				if ( programInfo.usedTimes === 0 ) {\r\n\r\n					deleteProgram = true;\r\n\r\n				}\r\n\r\n				break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( deleteProgram === true ) {\r\n\r\n			// avoid using array.splice, this is costlier than creating new array from scratch\r\n\r\n			var newPrograms = [];\r\n\r\n			for ( i = 0, il = _programs.length; i < il; i ++ ) {\r\n\r\n				programInfo = _programs[ i ];\r\n\r\n				if ( programInfo.program !== program ) {\r\n\r\n					newPrograms.push( programInfo );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			_programs = newPrograms;\r\n\r\n			_gl.deleteProgram( program );\r\n\r\n			_this.info.memory.programs --;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// Buffer initialization\r\n\r\n	function initCustomAttributes ( object ) {\r\n\r\n		var geometry = object.geometry;\r\n		var material = object.material;\r\n\r\n		var nvertices = geometry.vertices.length;\r\n\r\n		if ( material.attributes ) {\r\n\r\n			if ( geometry.__webglCustomAttributesList === undefined ) {\r\n\r\n				geometry.__webglCustomAttributesList = [];\r\n\r\n			}\r\n\r\n			for ( var name in material.attributes ) {\r\n\r\n				var attribute = material.attributes[ name ];\r\n\r\n				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n					attribute.__webglInitialized = true;\r\n\r\n					var size = 1;   // \"f\" and \"i\"\r\n\r\n					if ( attribute.type === 'v2' ) size = 2;\r\n					else if ( attribute.type === 'v3' ) size = 3;\r\n					else if ( attribute.type === 'v4' ) size = 4;\r\n					else if ( attribute.type === 'c'  ) size = 3;\r\n\r\n					attribute.size = size;\r\n\r\n					attribute.array = new Float32Array( nvertices * size );\r\n\r\n					attribute.buffer = _gl.createBuffer();\r\n					attribute.buffer.belongsToAttribute = name;\r\n\r\n					attribute.needsUpdate = true;\r\n\r\n				}\r\n\r\n				geometry.__webglCustomAttributesList.push( attribute );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function initParticleBuffers ( geometry, object ) {\r\n\r\n		var nvertices = geometry.vertices.length;\r\n\r\n		geometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n		geometry.__colorArray = new Float32Array( nvertices * 3 );\r\n\r\n		geometry.__sortArray = [];\r\n\r\n		geometry.__webglParticleCount = nvertices;\r\n\r\n		initCustomAttributes( object );\r\n\r\n	};\r\n\r\n	function initLineBuffers ( geometry, object ) {\r\n\r\n		var nvertices = geometry.vertices.length;\r\n\r\n		geometry.__vertexArray = new Float32Array( nvertices * 3 );\r\n		geometry.__colorArray = new Float32Array( nvertices * 3 );\r\n		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );\r\n\r\n		geometry.__webglLineCount = nvertices;\r\n\r\n		initCustomAttributes( object );\r\n\r\n	};\r\n\r\n	function initMeshBuffers ( geometryGroup, object ) {\r\n\r\n		var geometry = object.geometry,\r\n			faces3 = geometryGroup.faces3,\r\n\r\n			nvertices = faces3.length * 3,\r\n			ntris     = faces3.length * 1,\r\n			nlines    = faces3.length * 3,\r\n\r\n			material = getBufferMaterial( object, geometryGroup );\r\n\r\n		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );\r\n		geometryGroup.__normalArray = new Float32Array( nvertices * 3 );\r\n		geometryGroup.__colorArray = new Float32Array( nvertices * 3 );\r\n		geometryGroup.__uvArray = new Float32Array( nvertices * 2 );\r\n\r\n		if ( geometry.faceVertexUvs.length > 1 ) {\r\n\r\n			geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );\r\n\r\n		}\r\n\r\n		if ( geometry.hasTangents ) {\r\n\r\n			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );\r\n\r\n		}\r\n\r\n		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {\r\n\r\n			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );\r\n			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );\r\n\r\n		}\r\n\r\n		var UintArray = extensions.get( 'OES_element_index_uint' ) !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3\r\n\r\n		geometryGroup.__typeArray = UintArray;\r\n		geometryGroup.__faceArray = new UintArray( ntris * 3 );\r\n		geometryGroup.__lineArray = new UintArray( nlines * 2 );\r\n\r\n		var numMorphTargets = geometryGroup.numMorphTargets;\r\n\r\n		if ( numMorphTargets ) {\r\n\r\n			geometryGroup.__morphTargetsArrays = [];\r\n\r\n			for ( var m = 0, ml = numMorphTargets; m < ml; m ++ ) {\r\n\r\n				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var numMorphNormals = geometryGroup.numMorphNormals;\r\n\r\n		if ( numMorphNormals ) {\r\n\r\n			geometryGroup.__morphNormalsArrays = [];\r\n\r\n			for ( var m = 0, ml = numMorphNormals; m < ml; m ++ ) {\r\n\r\n				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		geometryGroup.__webglFaceCount = ntris * 3;\r\n		geometryGroup.__webglLineCount = nlines * 2;\r\n\r\n\r\n		// custom attributes\r\n\r\n		if ( material.attributes ) {\r\n\r\n			if ( geometryGroup.__webglCustomAttributesList === undefined ) {\r\n\r\n				geometryGroup.__webglCustomAttributesList = [];\r\n\r\n			}\r\n\r\n			for ( var name in material.attributes ) {\r\n\r\n				// Do a shallow copy of the attribute object so different geometryGroup chunks use different\r\n				// attribute buffers which are correctly indexed in the setMeshBuffers function\r\n\r\n				var originalAttribute = material.attributes[ name ];\r\n\r\n				var attribute = {};\r\n\r\n				for ( var property in originalAttribute ) {\r\n\r\n					attribute[ property ] = originalAttribute[ property ];\r\n\r\n				}\r\n\r\n				if ( ! attribute.__webglInitialized || attribute.createUniqueBuffers ) {\r\n\r\n					attribute.__webglInitialized = true;\r\n\r\n					var size = 1;   // \"f\" and \"i\"\r\n\r\n					if ( attribute.type === 'v2' ) size = 2;\r\n					else if ( attribute.type === 'v3' ) size = 3;\r\n					else if ( attribute.type === 'v4' ) size = 4;\r\n					else if ( attribute.type === 'c'  ) size = 3;\r\n\r\n					attribute.size = size;\r\n\r\n					attribute.array = new Float32Array( nvertices * size );\r\n\r\n					attribute.buffer = _gl.createBuffer();\r\n					attribute.buffer.belongsToAttribute = name;\r\n\r\n					originalAttribute.needsUpdate = true;\r\n					attribute.__original = originalAttribute;\r\n\r\n				}\r\n\r\n				geometryGroup.__webglCustomAttributesList.push( attribute );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		geometryGroup.__inittedArrays = true;\r\n\r\n	};\r\n\r\n	function getBufferMaterial( object, geometryGroup ) {\r\n\r\n		return object.material instanceof THREE.MeshFaceMaterial\r\n			 ? object.material.materials[ geometryGroup.materialIndex ]\r\n			 : object.material;\r\n\r\n	};\r\n\r\n	function materialNeedsSmoothNormals ( material ) {\r\n\r\n		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;\r\n\r\n	};\r\n\r\n	// Buffer setting\r\n\r\n	function setParticleBuffers ( geometry, hint, object ) {\r\n\r\n		var v, c, vertex, offset, index, color,\r\n\r\n		vertices = geometry.vertices,\r\n		vl = vertices.length,\r\n\r\n		colors = geometry.colors,\r\n		cl = colors.length,\r\n\r\n		vertexArray = geometry.__vertexArray,\r\n		colorArray = geometry.__colorArray,\r\n\r\n		sortArray = geometry.__sortArray,\r\n\r\n		dirtyVertices = geometry.verticesNeedUpdate,\r\n		dirtyElements = geometry.elementsNeedUpdate,\r\n		dirtyColors = geometry.colorsNeedUpdate,\r\n\r\n		customAttributes = geometry.__webglCustomAttributesList,\r\n		i, il,\r\n		a, ca, cal, value,\r\n		customAttribute;\r\n\r\n		if ( dirtyVertices ) {\r\n\r\n			for ( v = 0; v < vl; v ++ ) {\r\n\r\n				vertex = vertices[ v ];\r\n\r\n				offset = v * 3;\r\n\r\n				vertexArray[ offset ]     = vertex.x;\r\n				vertexArray[ offset + 1 ] = vertex.y;\r\n				vertexArray[ offset + 2 ] = vertex.z;\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n		}\r\n\r\n		if ( dirtyColors ) {\r\n\r\n			for ( c = 0; c < cl; c ++ ) {\r\n\r\n				color = colors[ c ];\r\n\r\n				offset = c * 3;\r\n\r\n				colorArray[ offset ]     = color.r;\r\n				colorArray[ offset + 1 ] = color.g;\r\n				colorArray[ offset + 2 ] = color.b;\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n		}\r\n\r\n		if ( customAttributes ) {\r\n\r\n			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n				customAttribute = customAttributes[ i ];\r\n\r\n				if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined ||  customAttribute.boundTo === 'vertices' ) ) {\r\n\r\n					cal = customAttribute.value.length;\r\n\r\n					offset = 0;\r\n\r\n					if ( customAttribute.size === 1 ) {\r\n\r\n						for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n							customAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.size === 2 ) {\r\n\r\n						for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n							value = customAttribute.value[ ca ];\r\n\r\n							customAttribute.array[ offset ]   = value.x;\r\n							customAttribute.array[ offset + 1 ] = value.y;\r\n\r\n							offset += 2;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.size === 3 ) {\r\n\r\n						if ( customAttribute.type === 'c' ) {\r\n\r\n							for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n								value = customAttribute.value[ ca ];\r\n\r\n								customAttribute.array[ offset ]   = value.r;\r\n								customAttribute.array[ offset + 1 ] = value.g;\r\n								customAttribute.array[ offset + 2 ] = value.b;\r\n\r\n								offset += 3;\r\n\r\n							}\r\n\r\n						} else {\r\n\r\n							for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n								value = customAttribute.value[ ca ];\r\n\r\n								customAttribute.array[ offset ]   = value.x;\r\n								customAttribute.array[ offset + 1 ] = value.y;\r\n								customAttribute.array[ offset + 2 ] = value.z;\r\n\r\n								offset += 3;\r\n\r\n							}\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.size === 4 ) {\r\n\r\n						for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n							value = customAttribute.value[ ca ];\r\n\r\n							customAttribute.array[ offset ]      = value.x;\r\n							customAttribute.array[ offset + 1  ] = value.y;\r\n							customAttribute.array[ offset + 2  ] = value.z;\r\n							customAttribute.array[ offset + 3  ] = value.w;\r\n\r\n							offset += 4;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n				customAttribute.needsUpdate = false;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setLineBuffers ( geometry, hint ) {\r\n\r\n		var v, c, d, vertex, offset, color,\r\n\r\n		vertices = geometry.vertices,\r\n		colors = geometry.colors,\r\n		lineDistances = geometry.lineDistances,\r\n\r\n		vl = vertices.length,\r\n		cl = colors.length,\r\n		dl = lineDistances.length,\r\n\r\n		vertexArray = geometry.__vertexArray,\r\n		colorArray = geometry.__colorArray,\r\n		lineDistanceArray = geometry.__lineDistanceArray,\r\n\r\n		dirtyVertices = geometry.verticesNeedUpdate,\r\n		dirtyColors = geometry.colorsNeedUpdate,\r\n		dirtyLineDistances = geometry.lineDistancesNeedUpdate,\r\n\r\n		customAttributes = geometry.__webglCustomAttributesList,\r\n\r\n		i, il,\r\n		a, ca, cal, value,\r\n		customAttribute;\r\n\r\n		if ( dirtyVertices ) {\r\n\r\n			for ( v = 0; v < vl; v ++ ) {\r\n\r\n				vertex = vertices[ v ];\r\n\r\n				offset = v * 3;\r\n\r\n				vertexArray[ offset ]     = vertex.x;\r\n				vertexArray[ offset + 1 ] = vertex.y;\r\n				vertexArray[ offset + 2 ] = vertex.z;\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n		}\r\n\r\n		if ( dirtyColors ) {\r\n\r\n			for ( c = 0; c < cl; c ++ ) {\r\n\r\n				color = colors[ c ];\r\n\r\n				offset = c * 3;\r\n\r\n				colorArray[ offset ]     = color.r;\r\n				colorArray[ offset + 1 ] = color.g;\r\n				colorArray[ offset + 2 ] = color.b;\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n		}\r\n\r\n		if ( dirtyLineDistances ) {\r\n\r\n			for ( d = 0; d < dl; d ++ ) {\r\n\r\n				lineDistanceArray[ d ] = lineDistances[ d ];\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );\r\n\r\n		}\r\n\r\n		if ( customAttributes ) {\r\n\r\n			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n				customAttribute = customAttributes[ i ];\r\n\r\n				if ( customAttribute.needsUpdate && ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) ) {\r\n\r\n					offset = 0;\r\n\r\n					cal = customAttribute.value.length;\r\n\r\n					if ( customAttribute.size === 1 ) {\r\n\r\n						for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n							customAttribute.array[ ca ] = customAttribute.value[ ca ];\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.size === 2 ) {\r\n\r\n						for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n							value = customAttribute.value[ ca ];\r\n\r\n							customAttribute.array[ offset ]   = value.x;\r\n							customAttribute.array[ offset + 1 ] = value.y;\r\n\r\n							offset += 2;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.size === 3 ) {\r\n\r\n						if ( customAttribute.type === 'c' ) {\r\n\r\n							for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n								value = customAttribute.value[ ca ];\r\n\r\n								customAttribute.array[ offset ]   = value.r;\r\n								customAttribute.array[ offset + 1 ] = value.g;\r\n								customAttribute.array[ offset + 2 ] = value.b;\r\n\r\n								offset += 3;\r\n\r\n							}\r\n\r\n						} else {\r\n\r\n							for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n								value = customAttribute.value[ ca ];\r\n\r\n								customAttribute.array[ offset ]   = value.x;\r\n								customAttribute.array[ offset + 1 ] = value.y;\r\n								customAttribute.array[ offset + 2 ] = value.z;\r\n\r\n								offset += 3;\r\n\r\n							}\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.size === 4 ) {\r\n\r\n						for ( ca = 0; ca < cal; ca ++ ) {\r\n\r\n							value = customAttribute.value[ ca ];\r\n\r\n							customAttribute.array[ offset ]    = value.x;\r\n							customAttribute.array[ offset + 1  ] = value.y;\r\n							customAttribute.array[ offset + 2  ] = value.z;\r\n							customAttribute.array[ offset + 3  ] = value.w;\r\n\r\n							offset += 4;\r\n\r\n						}\r\n\r\n					}\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n					customAttribute.needsUpdate = false;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {\r\n\r\n		if ( ! geometryGroup.__inittedArrays ) {\r\n\r\n			return;\r\n\r\n		}\r\n\r\n		var needsSmoothNormals = materialNeedsSmoothNormals( material );\r\n\r\n		var f, fl, fi, face,\r\n		vertexNormals, faceNormal, normal,\r\n		vertexColors, faceColor,\r\n		vertexTangents,\r\n		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,\r\n		c1, c2, c3,\r\n		sw1, sw2, sw3, sw4,\r\n		si1, si2, si3, si4,\r\n		sa1, sa2, sa3, sa4,\r\n		sb1, sb2, sb3, sb4,\r\n		m, ml, i, il,\r\n		vn, uvi, uv2i,\r\n		vk, vkl, vka,\r\n		nka, chf, faceVertexNormals,\r\n		a,\r\n\r\n		vertexIndex = 0,\r\n\r\n		offset = 0,\r\n		offset_uv = 0,\r\n		offset_uv2 = 0,\r\n		offset_face = 0,\r\n		offset_normal = 0,\r\n		offset_tangent = 0,\r\n		offset_line = 0,\r\n		offset_color = 0,\r\n		offset_skin = 0,\r\n		offset_morphTarget = 0,\r\n		offset_custom = 0,\r\n		offset_customSrc = 0,\r\n\r\n		value,\r\n\r\n		vertexArray = geometryGroup.__vertexArray,\r\n		uvArray = geometryGroup.__uvArray,\r\n		uv2Array = geometryGroup.__uv2Array,\r\n		normalArray = geometryGroup.__normalArray,\r\n		tangentArray = geometryGroup.__tangentArray,\r\n		colorArray = geometryGroup.__colorArray,\r\n\r\n		skinIndexArray = geometryGroup.__skinIndexArray,\r\n		skinWeightArray = geometryGroup.__skinWeightArray,\r\n\r\n		morphTargetsArrays = geometryGroup.__morphTargetsArrays,\r\n		morphNormalsArrays = geometryGroup.__morphNormalsArrays,\r\n\r\n		customAttributes = geometryGroup.__webglCustomAttributesList,\r\n		customAttribute,\r\n\r\n		faceArray = geometryGroup.__faceArray,\r\n		lineArray = geometryGroup.__lineArray,\r\n\r\n		geometry = object.geometry, // this is shared for all chunks\r\n\r\n		dirtyVertices = geometry.verticesNeedUpdate,\r\n		dirtyElements = geometry.elementsNeedUpdate,\r\n		dirtyUvs = geometry.uvsNeedUpdate,\r\n		dirtyNormals = geometry.normalsNeedUpdate,\r\n		dirtyTangents = geometry.tangentsNeedUpdate,\r\n		dirtyColors = geometry.colorsNeedUpdate,\r\n		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,\r\n\r\n		vertices = geometry.vertices,\r\n		chunk_faces3 = geometryGroup.faces3,\r\n		obj_faces = geometry.faces,\r\n\r\n		obj_uvs  = geometry.faceVertexUvs[ 0 ],\r\n		obj_uvs2 = geometry.faceVertexUvs[ 1 ],\r\n\r\n		obj_colors = geometry.colors,\r\n\r\n		obj_skinIndices = geometry.skinIndices,\r\n		obj_skinWeights = geometry.skinWeights,\r\n\r\n		morphTargets = geometry.morphTargets,\r\n		morphNormals = geometry.morphNormals;\r\n\r\n		if ( dirtyVertices ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n				v1 = vertices[ face.a ];\r\n				v2 = vertices[ face.b ];\r\n				v3 = vertices[ face.c ];\r\n\r\n				vertexArray[ offset ]     = v1.x;\r\n				vertexArray[ offset + 1 ] = v1.y;\r\n				vertexArray[ offset + 2 ] = v1.z;\r\n\r\n				vertexArray[ offset + 3 ] = v2.x;\r\n				vertexArray[ offset + 4 ] = v2.y;\r\n				vertexArray[ offset + 5 ] = v2.z;\r\n\r\n				vertexArray[ offset + 6 ] = v3.x;\r\n				vertexArray[ offset + 7 ] = v3.y;\r\n				vertexArray[ offset + 8 ] = v3.z;\r\n\r\n				offset += 9;\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );\r\n\r\n		}\r\n\r\n		if ( dirtyMorphTargets ) {\r\n\r\n			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {\r\n\r\n				offset_morphTarget = 0;\r\n\r\n				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n					chf = chunk_faces3[ f ];\r\n					face = obj_faces[ chf ];\r\n\r\n					// morph positions\r\n\r\n					v1 = morphTargets[ vk ].vertices[ face.a ];\r\n					v2 = morphTargets[ vk ].vertices[ face.b ];\r\n					v3 = morphTargets[ vk ].vertices[ face.c ];\r\n\r\n					vka = morphTargetsArrays[ vk ];\r\n\r\n					vka[ offset_morphTarget ]     = v1.x;\r\n					vka[ offset_morphTarget + 1 ] = v1.y;\r\n					vka[ offset_morphTarget + 2 ] = v1.z;\r\n\r\n					vka[ offset_morphTarget + 3 ] = v2.x;\r\n					vka[ offset_morphTarget + 4 ] = v2.y;\r\n					vka[ offset_morphTarget + 5 ] = v2.z;\r\n\r\n					vka[ offset_morphTarget + 6 ] = v3.x;\r\n					vka[ offset_morphTarget + 7 ] = v3.y;\r\n					vka[ offset_morphTarget + 8 ] = v3.z;\r\n\r\n					// morph normals\r\n\r\n					if ( material.morphNormals ) {\r\n\r\n						if ( needsSmoothNormals ) {\r\n\r\n							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];\r\n\r\n							n1 = faceVertexNormals.a;\r\n							n2 = faceVertexNormals.b;\r\n							n3 = faceVertexNormals.c;\r\n\r\n						} else {\r\n\r\n							n1 = morphNormals[ vk ].faceNormals[ chf ];\r\n							n2 = n1;\r\n							n3 = n1;\r\n\r\n						}\r\n\r\n						nka = morphNormalsArrays[ vk ];\r\n\r\n						nka[ offset_morphTarget ]     = n1.x;\r\n						nka[ offset_morphTarget + 1 ] = n1.y;\r\n						nka[ offset_morphTarget + 2 ] = n1.z;\r\n\r\n						nka[ offset_morphTarget + 3 ] = n2.x;\r\n						nka[ offset_morphTarget + 4 ] = n2.y;\r\n						nka[ offset_morphTarget + 5 ] = n2.z;\r\n\r\n						nka[ offset_morphTarget + 6 ] = n3.x;\r\n						nka[ offset_morphTarget + 7 ] = n3.y;\r\n						nka[ offset_morphTarget + 8 ] = n3.z;\r\n\r\n					}\r\n\r\n					//\r\n\r\n					offset_morphTarget += 9;\r\n\r\n				}\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );\r\n\r\n				if ( material.morphNormals ) {\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );\r\n					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( obj_skinWeights.length ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n				// weights\r\n\r\n				sw1 = obj_skinWeights[ face.a ];\r\n				sw2 = obj_skinWeights[ face.b ];\r\n				sw3 = obj_skinWeights[ face.c ];\r\n\r\n				skinWeightArray[ offset_skin ]     = sw1.x;\r\n				skinWeightArray[ offset_skin + 1 ] = sw1.y;\r\n				skinWeightArray[ offset_skin + 2 ] = sw1.z;\r\n				skinWeightArray[ offset_skin + 3 ] = sw1.w;\r\n\r\n				skinWeightArray[ offset_skin + 4 ] = sw2.x;\r\n				skinWeightArray[ offset_skin + 5 ] = sw2.y;\r\n				skinWeightArray[ offset_skin + 6 ] = sw2.z;\r\n				skinWeightArray[ offset_skin + 7 ] = sw2.w;\r\n\r\n				skinWeightArray[ offset_skin + 8 ]  = sw3.x;\r\n				skinWeightArray[ offset_skin + 9 ]  = sw3.y;\r\n				skinWeightArray[ offset_skin + 10 ] = sw3.z;\r\n				skinWeightArray[ offset_skin + 11 ] = sw3.w;\r\n\r\n				// indices\r\n\r\n				si1 = obj_skinIndices[ face.a ];\r\n				si2 = obj_skinIndices[ face.b ];\r\n				si3 = obj_skinIndices[ face.c ];\r\n\r\n				skinIndexArray[ offset_skin ]     = si1.x;\r\n				skinIndexArray[ offset_skin + 1 ] = si1.y;\r\n				skinIndexArray[ offset_skin + 2 ] = si1.z;\r\n				skinIndexArray[ offset_skin + 3 ] = si1.w;\r\n\r\n				skinIndexArray[ offset_skin + 4 ] = si2.x;\r\n				skinIndexArray[ offset_skin + 5 ] = si2.y;\r\n				skinIndexArray[ offset_skin + 6 ] = si2.z;\r\n				skinIndexArray[ offset_skin + 7 ] = si2.w;\r\n\r\n				skinIndexArray[ offset_skin + 8 ]  = si3.x;\r\n				skinIndexArray[ offset_skin + 9 ]  = si3.y;\r\n				skinIndexArray[ offset_skin + 10 ] = si3.z;\r\n				skinIndexArray[ offset_skin + 11 ] = si3.w;\r\n\r\n				offset_skin += 12;\r\n\r\n			}\r\n\r\n			if ( offset_skin > 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( dirtyColors ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n				vertexColors = face.vertexColors;\r\n				faceColor = face.color;\r\n\r\n				if ( vertexColors.length === 3 && material.vertexColors === THREE.VertexColors ) {\r\n\r\n					c1 = vertexColors[ 0 ];\r\n					c2 = vertexColors[ 1 ];\r\n					c3 = vertexColors[ 2 ];\r\n\r\n				} else {\r\n\r\n					c1 = faceColor;\r\n					c2 = faceColor;\r\n					c3 = faceColor;\r\n\r\n				}\r\n\r\n				colorArray[ offset_color ]     = c1.r;\r\n				colorArray[ offset_color + 1 ] = c1.g;\r\n				colorArray[ offset_color + 2 ] = c1.b;\r\n\r\n				colorArray[ offset_color + 3 ] = c2.r;\r\n				colorArray[ offset_color + 4 ] = c2.g;\r\n				colorArray[ offset_color + 5 ] = c2.b;\r\n\r\n				colorArray[ offset_color + 6 ] = c3.r;\r\n				colorArray[ offset_color + 7 ] = c3.g;\r\n				colorArray[ offset_color + 8 ] = c3.b;\r\n\r\n				offset_color += 9;\r\n\r\n			}\r\n\r\n			if ( offset_color > 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( dirtyTangents && geometry.hasTangents ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n				vertexTangents = face.vertexTangents;\r\n\r\n				t1 = vertexTangents[ 0 ];\r\n				t2 = vertexTangents[ 1 ];\r\n				t3 = vertexTangents[ 2 ];\r\n\r\n				tangentArray[ offset_tangent ]     = t1.x;\r\n				tangentArray[ offset_tangent + 1 ] = t1.y;\r\n				tangentArray[ offset_tangent + 2 ] = t1.z;\r\n				tangentArray[ offset_tangent + 3 ] = t1.w;\r\n\r\n				tangentArray[ offset_tangent + 4 ] = t2.x;\r\n				tangentArray[ offset_tangent + 5 ] = t2.y;\r\n				tangentArray[ offset_tangent + 6 ] = t2.z;\r\n				tangentArray[ offset_tangent + 7 ] = t2.w;\r\n\r\n				tangentArray[ offset_tangent + 8 ]  = t3.x;\r\n				tangentArray[ offset_tangent + 9 ]  = t3.y;\r\n				tangentArray[ offset_tangent + 10 ] = t3.z;\r\n				tangentArray[ offset_tangent + 11 ] = t3.w;\r\n\r\n				offset_tangent += 12;\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );\r\n\r\n		}\r\n\r\n		if ( dirtyNormals ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n				vertexNormals = face.vertexNormals;\r\n				faceNormal = face.normal;\r\n\r\n				if ( vertexNormals.length === 3 && needsSmoothNormals ) {\r\n\r\n					for ( i = 0; i < 3; i ++ ) {\r\n\r\n						vn = vertexNormals[ i ];\r\n\r\n						normalArray[ offset_normal ]     = vn.x;\r\n						normalArray[ offset_normal + 1 ] = vn.y;\r\n						normalArray[ offset_normal + 2 ] = vn.z;\r\n\r\n						offset_normal += 3;\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					for ( i = 0; i < 3; i ++ ) {\r\n\r\n						normalArray[ offset_normal ]     = faceNormal.x;\r\n						normalArray[ offset_normal + 1 ] = faceNormal.y;\r\n						normalArray[ offset_normal + 2 ] = faceNormal.z;\r\n\r\n						offset_normal += 3;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );\r\n\r\n		}\r\n\r\n		if ( dirtyUvs && obj_uvs ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				fi = chunk_faces3[ f ];\r\n\r\n				uv = obj_uvs[ fi ];\r\n\r\n				if ( uv === undefined ) continue;\r\n\r\n				for ( i = 0; i < 3; i ++ ) {\r\n\r\n					uvi = uv[ i ];\r\n\r\n					uvArray[ offset_uv ]     = uvi.x;\r\n					uvArray[ offset_uv + 1 ] = uvi.y;\r\n\r\n					offset_uv += 2;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( offset_uv > 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( dirtyUvs && obj_uvs2 ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				fi = chunk_faces3[ f ];\r\n\r\n				uv2 = obj_uvs2[ fi ];\r\n\r\n				if ( uv2 === undefined ) continue;\r\n\r\n				for ( i = 0; i < 3; i ++ ) {\r\n\r\n					uv2i = uv2[ i ];\r\n\r\n					uv2Array[ offset_uv2 ]     = uv2i.x;\r\n					uv2Array[ offset_uv2 + 1 ] = uv2i.y;\r\n\r\n					offset_uv2 += 2;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( offset_uv2 > 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( dirtyElements ) {\r\n\r\n			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n				faceArray[ offset_face ]   = vertexIndex;\r\n				faceArray[ offset_face + 1 ] = vertexIndex + 1;\r\n				faceArray[ offset_face + 2 ] = vertexIndex + 2;\r\n\r\n				offset_face += 3;\r\n\r\n				lineArray[ offset_line ]     = vertexIndex;\r\n				lineArray[ offset_line + 1 ] = vertexIndex + 1;\r\n\r\n				lineArray[ offset_line + 2 ] = vertexIndex;\r\n				lineArray[ offset_line + 3 ] = vertexIndex + 2;\r\n\r\n				lineArray[ offset_line + 4 ] = vertexIndex + 1;\r\n				lineArray[ offset_line + 5 ] = vertexIndex + 2;\r\n\r\n				offset_line += 6;\r\n\r\n				vertexIndex += 3;\r\n\r\n			}\r\n\r\n			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );\r\n\r\n			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );\r\n\r\n		}\r\n\r\n		if ( customAttributes ) {\r\n\r\n			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {\r\n\r\n				customAttribute = customAttributes[ i ];\r\n\r\n				if ( ! customAttribute.__original.needsUpdate ) continue;\r\n\r\n				offset_custom = 0;\r\n				offset_customSrc = 0;\r\n\r\n				if ( customAttribute.size === 1 ) {\r\n\r\n					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n							customAttribute.array[ offset_custom ]     = customAttribute.value[ face.a ];\r\n							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];\r\n							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];\r\n\r\n							offset_custom += 3;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							value = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n							customAttribute.array[ offset_custom ]     = value;\r\n							customAttribute.array[ offset_custom + 1 ] = value;\r\n							customAttribute.array[ offset_custom + 2 ] = value;\r\n\r\n							offset_custom += 3;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else if ( customAttribute.size === 2 ) {\r\n\r\n					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n							v1 = customAttribute.value[ face.a ];\r\n							v2 = customAttribute.value[ face.b ];\r\n							v3 = customAttribute.value[ face.c ];\r\n\r\n							customAttribute.array[ offset_custom ]     = v1.x;\r\n							customAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n							customAttribute.array[ offset_custom + 2 ] = v2.x;\r\n							customAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n							customAttribute.array[ offset_custom + 4 ] = v3.x;\r\n							customAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n							offset_custom += 6;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							value = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n							v1 = value;\r\n							v2 = value;\r\n							v3 = value;\r\n\r\n							customAttribute.array[ offset_custom ]     = v1.x;\r\n							customAttribute.array[ offset_custom + 1 ] = v1.y;\r\n\r\n							customAttribute.array[ offset_custom + 2 ] = v2.x;\r\n							customAttribute.array[ offset_custom + 3 ] = v2.y;\r\n\r\n							customAttribute.array[ offset_custom + 4 ] = v3.x;\r\n							customAttribute.array[ offset_custom + 5 ] = v3.y;\r\n\r\n							offset_custom += 6;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else if ( customAttribute.size === 3 ) {\r\n\r\n					var pp;\r\n\r\n					if ( customAttribute.type === 'c' ) {\r\n\r\n						pp = [ 'r', 'g', 'b' ];\r\n\r\n					} else {\r\n\r\n						pp = [ 'x', 'y', 'z' ];\r\n\r\n					}\r\n\r\n					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n							v1 = customAttribute.value[ face.a ];\r\n							v2 = customAttribute.value[ face.b ];\r\n							v3 = customAttribute.value[ face.c ];\r\n\r\n							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n							offset_custom += 9;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							value = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n							v1 = value;\r\n							v2 = value;\r\n							v3 = value;\r\n\r\n							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n							offset_custom += 9;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							value = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n							v1 = value[ 0 ];\r\n							v2 = value[ 1 ];\r\n							v3 = value[ 2 ];\r\n\r\n							customAttribute.array[ offset_custom ]     = v1[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];\r\n\r\n							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];\r\n\r\n							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];\r\n							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];\r\n							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];\r\n\r\n							offset_custom += 9;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else if ( customAttribute.size === 4 ) {\r\n\r\n					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === 'vertices' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							face = obj_faces[ chunk_faces3[ f ] ];\r\n\r\n							v1 = customAttribute.value[ face.a ];\r\n							v2 = customAttribute.value[ face.b ];\r\n							v3 = customAttribute.value[ face.c ];\r\n\r\n							customAttribute.array[ offset_custom  ]   = v1.x;\r\n							customAttribute.array[ offset_custom + 1  ] = v1.y;\r\n							customAttribute.array[ offset_custom + 2  ] = v1.z;\r\n							customAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n							customAttribute.array[ offset_custom + 4  ] = v2.x;\r\n							customAttribute.array[ offset_custom + 5  ] = v2.y;\r\n							customAttribute.array[ offset_custom + 6  ] = v2.z;\r\n							customAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n							customAttribute.array[ offset_custom + 8  ] = v3.x;\r\n							customAttribute.array[ offset_custom + 9  ] = v3.y;\r\n							customAttribute.array[ offset_custom + 10 ] = v3.z;\r\n							customAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n							offset_custom += 12;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.boundTo === 'faces' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							value = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n							v1 = value;\r\n							v2 = value;\r\n							v3 = value;\r\n\r\n							customAttribute.array[ offset_custom  ]   = v1.x;\r\n							customAttribute.array[ offset_custom + 1  ] = v1.y;\r\n							customAttribute.array[ offset_custom + 2  ] = v1.z;\r\n							customAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n							customAttribute.array[ offset_custom + 4  ] = v2.x;\r\n							customAttribute.array[ offset_custom + 5  ] = v2.y;\r\n							customAttribute.array[ offset_custom + 6  ] = v2.z;\r\n							customAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n							customAttribute.array[ offset_custom + 8  ] = v3.x;\r\n							customAttribute.array[ offset_custom + 9  ] = v3.y;\r\n							customAttribute.array[ offset_custom + 10 ] = v3.z;\r\n							customAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n							offset_custom += 12;\r\n\r\n						}\r\n\r\n					} else if ( customAttribute.boundTo === 'faceVertices' ) {\r\n\r\n						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {\r\n\r\n							value = customAttribute.value[ chunk_faces3[ f ] ];\r\n\r\n							v1 = value[ 0 ];\r\n							v2 = value[ 1 ];\r\n							v3 = value[ 2 ];\r\n\r\n							customAttribute.array[ offset_custom  ]   = v1.x;\r\n							customAttribute.array[ offset_custom + 1  ] = v1.y;\r\n							customAttribute.array[ offset_custom + 2  ] = v1.z;\r\n							customAttribute.array[ offset_custom + 3  ] = v1.w;\r\n\r\n							customAttribute.array[ offset_custom + 4  ] = v2.x;\r\n							customAttribute.array[ offset_custom + 5  ] = v2.y;\r\n							customAttribute.array[ offset_custom + 6  ] = v2.z;\r\n							customAttribute.array[ offset_custom + 7  ] = v2.w;\r\n\r\n							customAttribute.array[ offset_custom + 8  ] = v3.x;\r\n							customAttribute.array[ offset_custom + 9  ] = v3.y;\r\n							customAttribute.array[ offset_custom + 10 ] = v3.z;\r\n							customAttribute.array[ offset_custom + 11 ] = v3.w;\r\n\r\n							offset_custom += 12;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );\r\n				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( dispose ) {\r\n\r\n			delete geometryGroup.__inittedArrays;\r\n			delete geometryGroup.__colorArray;\r\n			delete geometryGroup.__normalArray;\r\n			delete geometryGroup.__tangentArray;\r\n			delete geometryGroup.__uvArray;\r\n			delete geometryGroup.__uv2Array;\r\n			delete geometryGroup.__faceArray;\r\n			delete geometryGroup.__vertexArray;\r\n			delete geometryGroup.__lineArray;\r\n			delete geometryGroup.__skinIndexArray;\r\n			delete geometryGroup.__skinWeightArray;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// Buffer rendering\r\n\r\n	this.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n		initAttributes();\r\n\r\n		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();\r\n		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();\r\n		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();\r\n		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();\r\n\r\n		if ( object.hasPositions ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n			enableAttribute( program.attributes.position );\r\n			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasNormals ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );\r\n\r\n			if ( material.shading === THREE.FlatShading ) {\r\n\r\n				var nx, ny, nz,\r\n					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,\r\n					normalArray,\r\n					i, il = object.count * 3;\r\n\r\n				for ( i = 0; i < il; i += 9 ) {\r\n\r\n					normalArray = object.normalArray;\r\n\r\n					nax  = normalArray[ i ];\r\n					nay  = normalArray[ i + 1 ];\r\n					naz  = normalArray[ i + 2 ];\r\n\r\n					nbx  = normalArray[ i + 3 ];\r\n					nby  = normalArray[ i + 4 ];\r\n					nbz  = normalArray[ i + 5 ];\r\n\r\n					ncx  = normalArray[ i + 6 ];\r\n					ncy  = normalArray[ i + 7 ];\r\n					ncz  = normalArray[ i + 8 ];\r\n\r\n					nx = ( nax + nbx + ncx ) / 3;\r\n					ny = ( nay + nby + ncy ) / 3;\r\n					nz = ( naz + nbz + ncz ) / 3;\r\n\r\n					normalArray[ i ]   = nx;\r\n					normalArray[ i + 1 ] = ny;\r\n					normalArray[ i + 2 ] = nz;\r\n\r\n					normalArray[ i + 3 ] = nx;\r\n					normalArray[ i + 4 ] = ny;\r\n					normalArray[ i + 5 ] = nz;\r\n\r\n					normalArray[ i + 6 ] = nx;\r\n					normalArray[ i + 7 ] = ny;\r\n					normalArray[ i + 8 ] = nz;\r\n\r\n				}\r\n\r\n			}\r\n\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n			enableAttribute( program.attributes.normal );\r\n			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasUvs && material.map ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n			enableAttribute( program.attributes.uv );\r\n			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );\r\n			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n			enableAttribute( program.attributes.color );\r\n			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		disableUnusedAttributes();\r\n\r\n		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n		object.count = 0;\r\n\r\n	};\r\n\r\n	function setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n		var geometryAttributes = geometry.attributes;\r\n\r\n		var programAttributes = program.attributes;\r\n		var programAttributesKeys = program.attributesKeys;\r\n\r\n		for ( var i = 0, l = programAttributesKeys.length; i < l; i ++ ) {\r\n\r\n			var key = programAttributesKeys[ i ];\r\n			var programAttribute = programAttributes[ key ];\r\n\r\n			if ( programAttribute >= 0 ) {\r\n\r\n				var geometryAttribute = geometryAttributes[ key ];\r\n\r\n				if ( geometryAttribute !== undefined ) {\r\n\r\n					var size = geometryAttribute.itemSize;\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );\r\n\r\n					enableAttribute( programAttribute );\r\n\r\n					_gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32\r\n\r\n				} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n					if ( material.defaultAttributeValues[ key ].length === 2 ) {\r\n\r\n						_gl.vertexAttrib2fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\r\n					} else if ( material.defaultAttributeValues[ key ].length === 3 ) {\r\n\r\n						_gl.vertexAttrib3fv( programAttribute, material.defaultAttributeValues[ key ] );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		disableUnusedAttributes();\r\n\r\n	}\r\n\r\n	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {\r\n\r\n		if ( material.visible === false ) return;\r\n\r\n		updateObject( object );\r\n\r\n		var program = setProgram( camera, lights, fog, material, object );\r\n\r\n		var updateBuffers = false,\r\n			wireframeBit = material.wireframe ? 1 : 0,\r\n			geometryProgram = 'direct_' + geometry.id + '_' + program.id + '_' + wireframeBit;\r\n\r\n		if ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n			_currentGeometryProgram = geometryProgram;\r\n			updateBuffers = true;\r\n\r\n		}\r\n\r\n		if ( updateBuffers ) {\r\n\r\n			initAttributes();\r\n\r\n		}\r\n\r\n		// render mesh\r\n\r\n		if ( object instanceof THREE.Mesh ) {\r\n\r\n			var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;\r\n\r\n			var index = geometry.attributes.index;\r\n\r\n			if ( index ) {\r\n\r\n				// indexed triangles\r\n\r\n				var type, size;\r\n\r\n				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n					type = _gl.UNSIGNED_INT;\r\n					size = 4;\r\n\r\n				} else {\r\n\r\n					type = _gl.UNSIGNED_SHORT;\r\n					size = 2;\r\n\r\n				}\r\n\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					if ( updateBuffers ) {\r\n\r\n						setupVertexAttributes( material, program, geometry, 0 );\r\n						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n					}\r\n\r\n					_gl.drawElements( mode, index.array.length, type, 0 );\r\n\r\n					_this.info.render.calls ++;\r\n					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n					_this.info.render.faces += index.array.length / 3;\r\n\r\n				} else {\r\n\r\n					// if there is more than 1 chunk\r\n					// must set attribute pointers to use new offsets for each chunk\r\n					// even if geometry and materials didn't change\r\n\r\n					updateBuffers = true;\r\n\r\n					for ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n						var startIndex = offsets[ i ].index;\r\n\r\n						if ( updateBuffers ) {\r\n\r\n							setupVertexAttributes( material, program, geometry, startIndex );\r\n							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n						}\r\n\r\n						// render indexed triangles\r\n\r\n						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\r\n						_this.info.render.calls ++;\r\n						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n						_this.info.render.faces += offsets[ i ].count / 3;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// non-indexed triangles\r\n\r\n				if ( updateBuffers ) {\r\n\r\n					setupVertexAttributes( material, program, geometry, 0 );\r\n\r\n				}\r\n\r\n				var position = geometry.attributes[ 'position' ];\r\n\r\n				// render non-indexed triangles\r\n\r\n				_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\r\n				_this.info.render.calls ++;\r\n				_this.info.render.vertices += position.array.length / 3;\r\n				_this.info.render.faces += position.array.length / 9;\r\n\r\n			}\r\n\r\n		} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n			// render particles\r\n\r\n			var mode = _gl.POINTS;\r\n\r\n			var index = geometry.attributes.index;\r\n\r\n			if ( index ) {\r\n\r\n				// indexed points\r\n\r\n				var type, size;\r\n\r\n				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n					type = _gl.UNSIGNED_INT;\r\n					size = 4;\r\n\r\n				} else {\r\n\r\n					type = _gl.UNSIGNED_SHORT;\r\n					size = 2;\r\n\r\n				}\r\n\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					if ( updateBuffers ) {\r\n\r\n						setupVertexAttributes( material, program, geometry, 0 );\r\n						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n					}\r\n\r\n					_gl.drawElements( mode, index.array.length, type, 0);\r\n\r\n					_this.info.render.calls ++;\r\n					_this.info.render.points += index.array.length;\r\n\r\n				} else {\r\n\r\n					// if there is more than 1 chunk\r\n					// must set attribute pointers to use new offsets for each chunk\r\n					// even if geometry and materials didn't change\r\n\r\n					if ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n					for ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n						var startIndex = offsets[ i ].index;\r\n\r\n						if ( updateBuffers ) {\r\n\r\n							setupVertexAttributes( material, program, geometry, startIndex );\r\n							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n						}\r\n\r\n						// render indexed points\r\n\r\n						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );\r\n\r\n						_this.info.render.calls ++;\r\n						_this.info.render.points += offsets[ i ].count;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// non-indexed points\r\n\r\n				if ( updateBuffers ) {\r\n\r\n					setupVertexAttributes( material, program, geometry, 0 );\r\n\r\n				}\r\n\r\n				var position = geometry.attributes.position;\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\r\n					_this.info.render.calls ++;\r\n					_this.info.render.points += position.array.length / 3;\r\n\r\n				} else {\r\n\r\n					for ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n						_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\r\n						_this.info.render.calls ++;\r\n						_this.info.render.points += offsets[ i ].count;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( object instanceof THREE.Line ) {\r\n\r\n			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n			setLineWidth( material.linewidth );\r\n\r\n			var index = geometry.attributes.index;\r\n\r\n			if ( index ) {\r\n\r\n				// indexed lines\r\n\r\n				var type, size;\r\n\r\n				if ( index.array instanceof Uint32Array ) {\r\n\r\n					type = _gl.UNSIGNED_INT;\r\n					size = 4;\r\n\r\n				} else {\r\n\r\n					type = _gl.UNSIGNED_SHORT;\r\n					size = 2;\r\n\r\n				}\r\n\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					if ( updateBuffers ) {\r\n\r\n						setupVertexAttributes( material, program, geometry, 0 );\r\n						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n					}\r\n\r\n					_gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array\r\n\r\n					_this.info.render.calls ++;\r\n					_this.info.render.vertices += index.array.length; // not really true, here vertices can be shared\r\n\r\n				} else {\r\n\r\n					// if there is more than 1 chunk\r\n					// must set attribute pointers to use new offsets for each chunk\r\n					// even if geometry and materials didn't change\r\n\r\n					if ( offsets.length > 1 ) updateBuffers = true;\r\n\r\n					for ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n						var startIndex = offsets[ i ].index;\r\n\r\n						if ( updateBuffers ) {\r\n\r\n							setupVertexAttributes( material, program, geometry, startIndex );\r\n							_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );\r\n\r\n						}\r\n\r\n						// render indexed lines\r\n\r\n						_gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array\r\n\r\n						_this.info.render.calls ++;\r\n						_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				// non-indexed lines\r\n\r\n				if ( updateBuffers ) {\r\n\r\n					setupVertexAttributes( material, program, geometry, 0 );\r\n\r\n				}\r\n\r\n				var position = geometry.attributes.position;\r\n				var offsets = geometry.offsets;\r\n\r\n				if ( offsets.length === 0 ) {\r\n\r\n					_gl.drawArrays( mode, 0, position.array.length / 3 );\r\n\r\n					_this.info.render.calls ++;\r\n					_this.info.render.vertices += position.array.length / 3;\r\n\r\n				} else {\r\n\r\n					for ( var i = 0, il = offsets.length; i < il; i ++ ) {\r\n\r\n						_gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );\r\n\r\n						_this.info.render.calls ++;\r\n						_this.info.render.vertices += offsets[ i ].count;\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {\r\n\r\n		if ( material.visible === false ) return;\r\n\r\n		updateObject( object );\r\n\r\n		var program = setProgram( camera, lights, fog, material, object );\r\n\r\n		var attributes = program.attributes;\r\n\r\n		var updateBuffers = false,\r\n			wireframeBit = material.wireframe ? 1 : 0,\r\n			geometryProgram = geometryGroup.id + '_' + program.id + '_' + wireframeBit;\r\n\r\n		if ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n			_currentGeometryProgram = geometryProgram;\r\n			updateBuffers = true;\r\n\r\n		}\r\n\r\n		if ( updateBuffers ) {\r\n\r\n			initAttributes();\r\n\r\n		}\r\n\r\n		// vertices\r\n\r\n		if ( ! material.morphTargets && attributes.position >= 0 ) {\r\n\r\n			if ( updateBuffers ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n				enableAttribute( attributes.position );\r\n				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			if ( object.morphTargetBase ) {\r\n\r\n				setupMorphTargets( material, geometryGroup, object );\r\n\r\n			}\r\n\r\n		}\r\n\r\n\r\n		if ( updateBuffers ) {\r\n\r\n			// custom attributes\r\n\r\n			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers\r\n\r\n			if ( geometryGroup.__webglCustomAttributesList ) {\r\n\r\n				for ( var i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {\r\n\r\n					var attribute = geometryGroup.__webglCustomAttributesList[ i ];\r\n\r\n					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {\r\n\r\n						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );\r\n						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );\r\n						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n\r\n			// colors\r\n\r\n			if ( attributes.color >= 0 ) {\r\n\r\n				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );\r\n					enableAttribute( attributes.color );\r\n					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n				} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// normals\r\n\r\n			if ( attributes.normal >= 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );\r\n				enableAttribute( attributes.normal );\r\n				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n			}\r\n\r\n			// tangents\r\n\r\n			if ( attributes.tangent >= 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );\r\n				enableAttribute( attributes.tangent );\r\n				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n			}\r\n\r\n			// uvs\r\n\r\n			if ( attributes.uv >= 0 ) {\r\n\r\n				if ( object.geometry.faceVertexUvs[ 0 ] ) {\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );\r\n					enableAttribute( attributes.uv );\r\n					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n				} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( attributes.uv2 >= 0 ) {\r\n\r\n				if ( object.geometry.faceVertexUvs[ 1 ] ) {\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );\r\n					enableAttribute( attributes.uv2 );\r\n					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n				} else if ( material.defaultAttributeValues !== undefined ) {\r\n\r\n\r\n					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( material.skinning &&\r\n				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );\r\n				enableAttribute( attributes.skinIndex );\r\n				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );\r\n				enableAttribute( attributes.skinWeight );\r\n				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );\r\n\r\n			}\r\n\r\n			// line distances\r\n\r\n			if ( attributes.lineDistance >= 0 ) {\r\n\r\n				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );\r\n				enableAttribute( attributes.lineDistance );\r\n				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		disableUnusedAttributes();\r\n\r\n		// render mesh\r\n\r\n		if ( object instanceof THREE.Mesh ) {\r\n\r\n			var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;\r\n\r\n			// wireframe\r\n\r\n			if ( material.wireframe ) {\r\n\r\n				setLineWidth( material.wireframeLinewidth );\r\n				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );\r\n				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );\r\n\r\n			// triangles\r\n\r\n			} else {\r\n\r\n				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );\r\n				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );\r\n\r\n			}\r\n\r\n			_this.info.render.calls ++;\r\n			_this.info.render.vertices += geometryGroup.__webglFaceCount;\r\n			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;\r\n\r\n		// render lines\r\n\r\n		} else if ( object instanceof THREE.Line ) {\r\n\r\n			var mode = ( object.mode === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;\r\n\r\n			setLineWidth( material.linewidth );\r\n\r\n			_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );\r\n\r\n			_this.info.render.calls ++;\r\n\r\n		// render particles\r\n\r\n		} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );\r\n\r\n			_this.info.render.calls ++;\r\n			_this.info.render.points += geometryGroup.__webglParticleCount;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function initAttributes() {\r\n\r\n		for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {\r\n\r\n			_newAttributes[ i ] = 0;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function enableAttribute( attribute ) {\r\n\r\n		_newAttributes[ attribute ] = 1;\r\n\r\n		if ( _enabledAttributes[ attribute ] === 0 ) {\r\n\r\n			_gl.enableVertexAttribArray( attribute );\r\n			_enabledAttributes[ attribute ] = 1;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function disableUnusedAttributes() {\r\n\r\n		for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {\r\n\r\n			if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {\r\n\r\n				_gl.disableVertexAttribArray( i );\r\n				_enabledAttributes[ i ] = 0;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setupMorphTargets ( material, geometryGroup, object ) {\r\n\r\n		// set base\r\n\r\n		var attributes = material.program.attributes;\r\n\r\n		if ( object.morphTargetBase !== - 1 && attributes.position >= 0 ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );\r\n			enableAttribute( attributes.position );\r\n			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		} else if ( attributes.position >= 0 ) {\r\n\r\n			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );\r\n			enableAttribute( attributes.position );\r\n			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n		}\r\n\r\n		if ( object.morphTargetForcedOrder.length ) {\r\n\r\n			// set forced order\r\n\r\n			var m = 0;\r\n			var order = object.morphTargetForcedOrder;\r\n			var influences = object.morphTargetInfluences;\r\n\r\n			var attribute;\r\n\r\n			while ( m < material.numSupportedMorphTargets && m < order.length ) {\r\n\r\n				attribute = attributes[ 'morphTarget' + m ];\r\n\r\n				if ( attribute >= 0 ) {\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );\r\n					enableAttribute( attribute );\r\n					_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n				}\r\n\r\n				attribute = attributes[ 'morphNormal' + m ];\r\n\r\n				if ( attribute >= 0 && material.morphNormals ) {\r\n\r\n					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );\r\n					enableAttribute( attribute );\r\n					_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n				}\r\n\r\n				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];\r\n\r\n				m ++;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// find the most influencing\r\n\r\n			var activeInfluenceIndices = [];\r\n			var influences = object.morphTargetInfluences;\r\n\r\n			for ( var i = 0, il = influences.length; i < il; i ++ ) {\r\n\r\n				var influence = influences[ i ];\r\n\r\n				activeInfluenceIndices.push( [ influence, i ] );\r\n\r\n			}\r\n\r\n			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {\r\n\r\n				activeInfluenceIndices.sort( numericalSort );\r\n				activeInfluenceIndices.length = material.numSupportedMorphTargets;\r\n\r\n			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {\r\n\r\n				activeInfluenceIndices.sort( numericalSort );\r\n\r\n			} else if ( activeInfluenceIndices.length === 0 ) {\r\n\r\n				activeInfluenceIndices.push( [ 0, 0 ] );\r\n\r\n			}\r\n\r\n			var attribute;\r\n\r\n			for ( var m = 0, ml = material.numSupportedMorphTargets; m < ml; m ++ ) {\r\n\r\n				if ( activeInfluenceIndices[ m ] ) {\r\n\r\n					var influenceIndex = activeInfluenceIndices[ m ][ 1 ];\r\n\r\n					attribute = attributes[ 'morphTarget' + m ];\r\n\r\n					if ( attribute >= 0 ) {\r\n\r\n						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );\r\n						enableAttribute( attribute );\r\n						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n					}\r\n\r\n					attribute = attributes[ 'morphNormal' + m ];\r\n\r\n					if ( attribute >= 0 && material.morphNormals ) {\r\n\r\n						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );\r\n						enableAttribute( attribute );\r\n						_gl.vertexAttribPointer( attribute, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\r\n					}\r\n\r\n					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];\r\n\r\n				} else {\r\n\r\n					/*\r\n					_gl.vertexAttribPointer( attributes[ \"morphTarget\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n					if ( material.morphNormals ) {\r\n\r\n						_gl.vertexAttribPointer( attributes[ \"morphNormal\" + m ], 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n					}\r\n					*/\r\n\r\n					object.__webglMorphTargetInfluences[ m ] = 0;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// load updated influences uniform\r\n\r\n		if ( material.program.uniforms.morphTargetInfluences !== null ) {\r\n\r\n			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Sorting\r\n\r\n	function painterSortStable ( a, b ) {\r\n\r\n		if ( a.material.id !== b.material.id ) {\r\n\r\n			return a.material.id - b.material.id;\r\n\r\n		} else if ( a.z !== b.z ) {\r\n\r\n			return a.z - b.z;\r\n\r\n		} else {\r\n\r\n			return a.id - b.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function reversePainterSortStable ( a, b ) {\r\n\r\n		if ( a.z !== b.z ) {\r\n\r\n			return b.z - a.z;\r\n\r\n		} else {\r\n\r\n			return a.id - b.id;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function numericalSort ( a, b ) {\r\n\r\n		return b[ 0 ] - a[ 0 ];\r\n\r\n	}\r\n\r\n	// Rendering\r\n\r\n	this.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n		if ( camera instanceof THREE.Camera === false ) {\r\n\r\n			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n			return;\r\n\r\n		}\r\n\r\n		var fog = scene.fog;\r\n\r\n		// reset caching for this frame\r\n\r\n		_currentGeometryProgram = '';\r\n		_currentMaterialId = - 1;\r\n		_currentCamera = null;\r\n		_lightsNeedUpdate = true;\r\n\r\n		// update scene graph\r\n\r\n		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n		// update camera matrices and frustum\r\n\r\n		if ( camera.parent === undefined ) camera.updateMatrixWorld();\r\n\r\n		// update Skeleton objects\r\n\r\n		scene.traverse( function ( object ) {\r\n\r\n			if ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n				object.skeleton.update();\r\n\r\n			}\r\n\r\n		} );\r\n\r\n		camera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n		_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n		lights.length = 0;\r\n		opaqueObjects.length = 0;\r\n		transparentObjects.length = 0;\r\n\r\n		sprites.length = 0;\r\n		lensFlares.length = 0;\r\n\r\n		projectObject( scene );\r\n\r\n		if ( _this.sortObjects === true ) {\r\n\r\n			opaqueObjects.sort( painterSortStable );\r\n			transparentObjects.sort( reversePainterSortStable );\r\n\r\n		}\r\n\r\n		// custom render plugins (pre pass)\r\n\r\n		shadowMapPlugin.render( scene, camera );\r\n\r\n		//\r\n\r\n		_this.info.render.calls = 0;\r\n		_this.info.render.vertices = 0;\r\n		_this.info.render.faces = 0;\r\n		_this.info.render.points = 0;\r\n\r\n		this.setRenderTarget( renderTarget );\r\n\r\n		if ( this.autoClear || forceClear ) {\r\n\r\n			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n		}\r\n\r\n		// set matrices for immediate objects\r\n\r\n		for ( var i = 0, il = _webglObjectsImmediate.length; i < il; i ++ ) {\r\n\r\n			var webglObject = _webglObjectsImmediate[ i ];\r\n			var object = webglObject.object;\r\n\r\n			if ( object.visible ) {\r\n\r\n				setupMatrices( object, camera );\r\n\r\n				unrollImmediateBufferMaterial( webglObject );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( scene.overrideMaterial ) {\r\n\r\n			var material = scene.overrideMaterial;\r\n\r\n			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n			this.setDepthTest( material.depthTest );\r\n			this.setDepthWrite( material.depthWrite );\r\n			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n			renderObjects( opaqueObjects, camera, lights, fog, true, material );\r\n			renderObjects( transparentObjects, camera, lights, fog, true, material );\r\n			renderObjectsImmediate( _webglObjectsImmediate, '', camera, lights, fog, false, material );\r\n\r\n		} else {\r\n\r\n			var material = null;\r\n\r\n			// opaque pass (front-to-back order)\r\n\r\n			this.setBlending( THREE.NoBlending );\r\n\r\n			renderObjects( opaqueObjects, camera, lights, fog, false, material );\r\n			renderObjectsImmediate( _webglObjectsImmediate, 'opaque', camera, lights, fog, false, material );\r\n\r\n			// transparent pass (back-to-front order)\r\n\r\n			renderObjects( transparentObjects, camera, lights, fog, true, material );\r\n			renderObjectsImmediate( _webglObjectsImmediate, 'transparent', camera, lights, fog, true, material );\r\n\r\n		}\r\n\r\n		// custom render plugins (post pass)\r\n\r\n		spritePlugin.render( scene, camera );\r\n		lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );\r\n\r\n		// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {\r\n\r\n			updateRenderTargetMipmap( renderTarget );\r\n\r\n		}\r\n\r\n		// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n		this.setDepthTest( true );\r\n		this.setDepthWrite( true );\r\n\r\n		// _gl.finish();\r\n\r\n	};\r\n\r\n	function projectObject( object ) {\r\n\r\n		if ( object.visible === false ) return;\r\n\r\n		if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {\r\n\r\n			// skip\r\n\r\n		} else {\r\n\r\n			initObject( object );\r\n\r\n			if ( object instanceof THREE.Light ) {\r\n\r\n				lights.push( object );\r\n\r\n			} else if ( object instanceof THREE.Sprite ) {\r\n\r\n				sprites.push( object );\r\n\r\n			} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n				lensFlares.push( object );\r\n\r\n			} else {\r\n\r\n				var webglObjects = _webglObjects[ object.id ];\r\n\r\n				if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n					for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\r\n						var webglObject = webglObjects[i];\r\n\r\n						unrollBufferMaterial( webglObject );\r\n\r\n						webglObject.render = true;\r\n\r\n						if ( _this.sortObjects === true ) {\r\n\r\n							_vector3.setFromMatrixPosition( object.matrixWorld );\r\n							_vector3.applyProjection( _projScreenMatrix );\r\n\r\n							webglObject.z = _vector3.z;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n			projectObject( object.children[ i ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n		var material;\r\n\r\n		for ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n			var webglObject = renderList[ i ];\r\n\r\n			var object = webglObject.object;\r\n			var buffer = webglObject.buffer;\r\n\r\n			setupMatrices( object, camera );\r\n\r\n			if ( overrideMaterial ) {\r\n\r\n				material = overrideMaterial;\r\n\r\n			} else {\r\n\r\n				material = webglObject.material;\r\n\r\n				if ( ! material ) continue;\r\n\r\n				if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n				_this.setDepthTest( material.depthTest );\r\n				_this.setDepthWrite( material.depthWrite );\r\n				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n			}\r\n\r\n			_this.setMaterialFaces( material );\r\n\r\n			if ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n				_this.renderBufferDirect( camera, lights, fog, material, buffer, object );\r\n\r\n			} else {\r\n\r\n				_this.renderBuffer( camera, lights, fog, material, buffer, object );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {\r\n\r\n		var material;\r\n\r\n		for ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n			var webglObject = renderList[ i ];\r\n			var object = webglObject.object;\r\n\r\n			if ( object.visible ) {\r\n\r\n				if ( overrideMaterial ) {\r\n\r\n					material = overrideMaterial;\r\n\r\n				} else {\r\n\r\n					material = webglObject[ materialType ];\r\n\r\n					if ( ! material ) continue;\r\n\r\n					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\r\n					_this.setDepthTest( material.depthTest );\r\n					_this.setDepthWrite( material.depthWrite );\r\n					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n				}\r\n\r\n				_this.renderImmediateObject( camera, lights, fog, material, object );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {\r\n\r\n		var program = setProgram( camera, lights, fog, material, object );\r\n\r\n		_currentGeometryProgram = '';\r\n\r\n		_this.setMaterialFaces( material );\r\n\r\n		if ( object.immediateRenderCallback ) {\r\n\r\n			object.immediateRenderCallback( program, _gl, _frustum );\r\n\r\n		} else {\r\n\r\n			object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function unrollImmediateBufferMaterial ( globject ) {\r\n\r\n		var object = globject.object,\r\n			material = object.material;\r\n\r\n		if ( material.transparent ) {\r\n\r\n			globject.transparent = material;\r\n			globject.opaque = null;\r\n\r\n		} else {\r\n\r\n			globject.opaque = material;\r\n			globject.transparent = null;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function unrollBufferMaterial ( globject ) {\r\n\r\n		var object = globject.object;\r\n		var buffer = globject.buffer;\r\n\r\n		var geometry = object.geometry;\r\n		var material = object.material;\r\n\r\n		if ( material instanceof THREE.MeshFaceMaterial ) {\r\n\r\n			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;\r\n\r\n			material = material.materials[ materialIndex ];\r\n\r\n			globject.material = material;\r\n\r\n			if ( material.transparent ) {\r\n\r\n				transparentObjects.push( globject );\r\n\r\n			} else {\r\n\r\n				opaqueObjects.push( globject );\r\n\r\n			}\r\n\r\n		} else if ( material ) {\r\n\r\n			globject.material = material;\r\n\r\n			if ( material.transparent ) {\r\n\r\n				transparentObjects.push( globject );\r\n\r\n			} else {\r\n\r\n				opaqueObjects.push( globject );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function initObject( object ) {\r\n\r\n		if ( object.__webglInit === undefined ) {\r\n\r\n			object.__webglInit = true;\r\n			object._modelViewMatrix = new THREE.Matrix4();\r\n			object._normalMatrix = new THREE.Matrix3();\r\n\r\n			object.addEventListener( 'removed', onObjectRemoved );\r\n\r\n		}\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( geometry === undefined ) {\r\n\r\n			// ImmediateRenderObject\r\n\r\n		} else if ( geometry.__webglInit === undefined ) {\r\n\r\n			geometry.__webglInit = true;\r\n			geometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n			if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n				_this.info.memory.geometries ++;\r\n\r\n			} else if ( object instanceof THREE.Mesh ) {\r\n\r\n				initGeometryGroups( object, geometry );\r\n\r\n			} else if ( object instanceof THREE.Line ) {\r\n\r\n				if ( geometry.__webglVertexBuffer === undefined ) {\r\n\r\n					createLineBuffers( geometry );\r\n					initLineBuffers( geometry, object );\r\n\r\n					geometry.verticesNeedUpdate = true;\r\n					geometry.colorsNeedUpdate = true;\r\n					geometry.lineDistancesNeedUpdate = true;\r\n\r\n				}\r\n\r\n			} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n				if ( geometry.__webglVertexBuffer === undefined ) {\r\n\r\n					createParticleBuffers( geometry );\r\n					initParticleBuffers( geometry, object );\r\n\r\n					geometry.verticesNeedUpdate = true;\r\n					geometry.colorsNeedUpdate = true;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( object.__webglActive === undefined) {\r\n\r\n			object.__webglActive = true;\r\n\r\n			if ( object instanceof THREE.Mesh ) {\r\n\r\n				if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n					addBuffer( _webglObjects, geometry, object );\r\n\r\n				} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n					var geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n					for ( var i = 0,l = geometryGroupsList.length; i < l; i ++ ) {\r\n\r\n						addBuffer( _webglObjects, geometryGroupsList[ i ], object );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			} else if ( object instanceof THREE.Line || object instanceof THREE.PointCloud ) {\r\n\r\n				addBuffer( _webglObjects, geometry, object );\r\n\r\n			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n				addBufferImmediate( _webglObjectsImmediate, object );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Geometry splitting\r\n\r\n	var geometryGroups = {};\r\n	var geometryGroupCounter = 0;\r\n\r\n	function makeGroups( geometry, usesFaceMaterial ) {\r\n\r\n		var maxVerticesInGroup = extensions.get( 'OES_element_index_uint' ) ? 4294967296 : 65535;\r\n\r\n		var groupHash, hash_map = {};\r\n\r\n		var numMorphTargets = geometry.morphTargets.length;\r\n		var numMorphNormals = geometry.morphNormals.length;\r\n\r\n		var group;\r\n		var groups = {};\r\n		var groupsList = [];\r\n\r\n		for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {\r\n\r\n			var face = geometry.faces[ f ];\r\n			var materialIndex = usesFaceMaterial ? face.materialIndex : 0;\r\n\r\n			if ( ! ( materialIndex in hash_map ) ) {\r\n\r\n				hash_map[ materialIndex ] = { hash: materialIndex, counter: 0 };\r\n\r\n			}\r\n\r\n			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n			if ( ! ( groupHash in groups ) ) {\r\n\r\n				group = {\r\n					id: geometryGroupCounter ++,\r\n					faces3: [],\r\n					materialIndex: materialIndex,\r\n					vertices: 0,\r\n					numMorphTargets: numMorphTargets,\r\n					numMorphNormals: numMorphNormals\r\n				};\r\n\r\n				groups[ groupHash ] = group;\r\n				groupsList.push( group );\r\n\r\n			}\r\n\r\n			if ( groups[ groupHash ].vertices + 3 > maxVerticesInGroup ) {\r\n\r\n				hash_map[ materialIndex ].counter += 1;\r\n				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;\r\n\r\n				if ( ! ( groupHash in groups ) ) {\r\n\r\n					group = {\r\n						id: geometryGroupCounter ++,\r\n						faces3: [],\r\n						materialIndex: materialIndex,\r\n						vertices: 0,\r\n						numMorphTargets: numMorphTargets,\r\n						numMorphNormals: numMorphNormals\r\n					};\r\n\r\n					groups[ groupHash ] = group;\r\n					groupsList.push( group );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			groups[ groupHash ].faces3.push( f );\r\n			groups[ groupHash ].vertices += 3;\r\n\r\n		}\r\n\r\n		return groupsList;\r\n\r\n	}\r\n\r\n	function initGeometryGroups( object, geometry ) {\r\n\r\n		var material = object.material, addBuffers = false;\r\n\r\n		if ( geometryGroups[ geometry.id ] === undefined || geometry.groupsNeedUpdate === true ) {\r\n\r\n			delete _webglObjects[ object.id ];\r\n\r\n			geometryGroups[ geometry.id ] = makeGroups( geometry, material instanceof THREE.MeshFaceMaterial );\r\n\r\n			geometry.groupsNeedUpdate = false;\r\n\r\n		}\r\n\r\n		var geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n		// create separate VBOs per geometry chunk\r\n\r\n		for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n			var geometryGroup = geometryGroupsList[ i ];\r\n\r\n			// initialise VBO on the first access\r\n\r\n			if ( geometryGroup.__webglVertexBuffer === undefined ) {\r\n\r\n				createMeshBuffers( geometryGroup );\r\n				initMeshBuffers( geometryGroup, object );\r\n\r\n				geometry.verticesNeedUpdate = true;\r\n				geometry.morphTargetsNeedUpdate = true;\r\n				geometry.elementsNeedUpdate = true;\r\n				geometry.uvsNeedUpdate = true;\r\n				geometry.normalsNeedUpdate = true;\r\n				geometry.tangentsNeedUpdate = true;\r\n				geometry.colorsNeedUpdate = true;\r\n\r\n				addBuffers = true;\r\n\r\n			} else {\r\n\r\n				addBuffers = false;\r\n\r\n			}\r\n\r\n			if ( addBuffers || object.__webglActive === undefined ) {\r\n\r\n				addBuffer( _webglObjects, geometryGroup, object );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		object.__webglActive = true;\r\n\r\n	}\r\n\r\n	function addBuffer( objlist, buffer, object ) {\r\n\r\n		var id = object.id;\r\n		objlist[id] = objlist[id] || [];\r\n		objlist[id].push(\r\n			{\r\n				id: id,\r\n				buffer: buffer,\r\n				object: object,\r\n				material: null,\r\n				z: 0\r\n			}\r\n		);\r\n\r\n	};\r\n\r\n	function addBufferImmediate( objlist, object ) {\r\n\r\n		objlist.push(\r\n			{\r\n				id: null,\r\n				object: object,\r\n				opaque: null,\r\n				transparent: null,\r\n				z: 0\r\n			}\r\n		);\r\n\r\n	};\r\n\r\n	// Objects updates\r\n\r\n	function updateObject( object ) {\r\n\r\n		var geometry = object.geometry;\r\n\r\n		if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n			var attributes = geometry.attributes;\r\n			var attributesKeys = geometry.attributesKeys;\r\n\r\n			for ( var i = 0, l = attributesKeys.length; i < l; i ++ ) {\r\n\r\n				var key = attributesKeys[ i ];\r\n				var attribute = attributes[ key ];\r\n\r\n				if ( attribute.buffer === undefined ) {\r\n\r\n					attribute.buffer = _gl.createBuffer();\r\n					attribute.needsUpdate = true;\r\n\r\n				}\r\n\r\n				if ( attribute.needsUpdate === true ) {\r\n\r\n					var bufferType = ( key === 'index' ) ? _gl.ELEMENT_ARRAY_BUFFER : _gl.ARRAY_BUFFER;\r\n\r\n					_gl.bindBuffer( bufferType, attribute.buffer );\r\n					_gl.bufferData( bufferType, attribute.array, _gl.STATIC_DRAW );\r\n\r\n					attribute.needsUpdate = false;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else if ( object instanceof THREE.Mesh ) {\r\n\r\n			// check all geometry groups\r\n\r\n			if ( geometry.groupsNeedUpdate === true ) {\r\n\r\n				initGeometryGroups( object, geometry );\r\n\r\n			}\r\n\r\n			var geometryGroupsList = geometryGroups[ geometry.id ];\r\n\r\n			for ( var i = 0, il = geometryGroupsList.length; i < il; i ++ ) {\r\n\r\n				var geometryGroup = geometryGroupsList[ i ];\r\n				var material = getBufferMaterial( object, geometryGroup );\r\n\r\n				if ( geometry.groupsNeedUpdate === true ) {\r\n\r\n					initMeshBuffers( geometryGroup, object );\r\n\r\n				}\r\n\r\n				var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||\r\n					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||\r\n					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {\r\n\r\n					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			geometry.verticesNeedUpdate = false;\r\n			geometry.morphTargetsNeedUpdate = false;\r\n			geometry.elementsNeedUpdate = false;\r\n			geometry.uvsNeedUpdate = false;\r\n			geometry.normalsNeedUpdate = false;\r\n			geometry.colorsNeedUpdate = false;\r\n			geometry.tangentsNeedUpdate = false;\r\n\r\n			material.attributes && clearCustomAttributes( material );\r\n\r\n		} else if ( object instanceof THREE.Line ) {\r\n\r\n			var material = getBufferMaterial( object, geometry );\r\n			var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {\r\n\r\n				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );\r\n\r\n			}\r\n\r\n			geometry.verticesNeedUpdate = false;\r\n			geometry.colorsNeedUpdate = false;\r\n			geometry.lineDistancesNeedUpdate = false;\r\n\r\n			material.attributes && clearCustomAttributes( material );\r\n\r\n		} else if ( object instanceof THREE.PointCloud ) {\r\n\r\n			var material = getBufferMaterial( object, geometry );\r\n			var customAttributesDirty = material.attributes && areCustomAttributesDirty( material );\r\n\r\n			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || customAttributesDirty ) {\r\n\r\n				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );\r\n\r\n			}\r\n\r\n			geometry.verticesNeedUpdate = false;\r\n			geometry.colorsNeedUpdate = false;\r\n\r\n			material.attributes && clearCustomAttributes( material );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Objects updates - custom attributes check\r\n\r\n	function areCustomAttributesDirty( material ) {\r\n\r\n		for ( var name in material.attributes ) {\r\n\r\n			if ( material.attributes[ name ].needsUpdate ) return true;\r\n\r\n		}\r\n\r\n		return false;\r\n\r\n	}\r\n\r\n	function clearCustomAttributes( material ) {\r\n\r\n		for ( var name in material.attributes ) {\r\n\r\n			material.attributes[ name ].needsUpdate = false;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Objects removal\r\n\r\n	function removeObject( object ) {\r\n\r\n		if ( object instanceof THREE.Mesh  ||\r\n			 object instanceof THREE.PointCloud ||\r\n			 object instanceof THREE.Line ) {\r\n\r\n			delete _webglObjects[ object.id ];\r\n\r\n		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {\r\n\r\n			removeInstances( _webglObjectsImmediate, object );\r\n\r\n		}\r\n\r\n		delete object.__webglInit;\r\n		delete object._modelViewMatrix;\r\n		delete object._normalMatrix;\r\n\r\n		delete object.__webglActive;\r\n\r\n	}\r\n\r\n	function removeInstances( objlist, object ) {\r\n\r\n		for ( var o = objlist.length - 1; o >= 0; o -- ) {\r\n\r\n			if ( objlist[ o ].object === object ) {\r\n\r\n				objlist.splice( o, 1 );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Materials\r\n\r\n	var shaderIDs = {\r\n		MeshDepthMaterial: 'depth',\r\n		MeshNormalMaterial: 'normal',\r\n		MeshBasicMaterial: 'basic',\r\n		MeshLambertMaterial: 'lambert',\r\n		MeshPhongMaterial: 'phong',\r\n		LineBasicMaterial: 'basic',\r\n		LineDashedMaterial: 'dashed',\r\n		PointCloudMaterial: 'particle_basic'\r\n	};\r\n\r\n	function initMaterial( material, lights, fog, object ) {\r\n\r\n		material.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n		var shaderID = shaderIDs[ material.type ];\r\n\r\n		if ( shaderID ) {\r\n\r\n			var shader = THREE.ShaderLib[ shaderID ];\r\n\r\n			material.__webglShader = {\r\n				uniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n				vertexShader: shader.vertexShader,\r\n				fragmentShader: shader.fragmentShader\r\n			}\r\n\r\n		} else {\r\n\r\n			material.__webglShader = {\r\n				uniforms: material.uniforms,\r\n				vertexShader: material.vertexShader,\r\n				fragmentShader: material.fragmentShader\r\n			}\r\n\r\n		}\r\n\r\n		// heuristics to create shader parameters according to lights in the scene\r\n		// (not to blow over maxLights budget)\r\n\r\n		var maxLightCount = allocateLights( lights );\r\n		var maxShadows = allocateShadows( lights );\r\n		var maxBones = allocateBones( object );\r\n\r\n		var parameters = {\r\n\r\n			precision: _precision,\r\n			supportsVertexTextures: _supportsVertexTextures,\r\n\r\n			map: !! material.map,\r\n			envMap: !! material.envMap,\r\n			envMapMode: material.envMap && material.envMap.mapping,\r\n			lightMap: !! material.lightMap,\r\n			bumpMap: !! material.bumpMap,\r\n			normalMap: !! material.normalMap,\r\n			specularMap: !! material.specularMap,\r\n			alphaMap: !! material.alphaMap,\r\n\r\n			combine: material.combine,\r\n\r\n			vertexColors: material.vertexColors,\r\n\r\n			fog: fog,\r\n			useFog: material.fog,\r\n			fogExp: fog instanceof THREE.FogExp2,\r\n\r\n			sizeAttenuation: material.sizeAttenuation,\r\n			logarithmicDepthBuffer: _logarithmicDepthBuffer,\r\n\r\n			skinning: material.skinning,\r\n			maxBones: maxBones,\r\n			useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n			morphTargets: material.morphTargets,\r\n			morphNormals: material.morphNormals,\r\n			maxMorphTargets: _this.maxMorphTargets,\r\n			maxMorphNormals: _this.maxMorphNormals,\r\n\r\n			maxDirLights: maxLightCount.directional,\r\n			maxPointLights: maxLightCount.point,\r\n			maxSpotLights: maxLightCount.spot,\r\n			maxHemiLights: maxLightCount.hemi,\r\n\r\n			maxShadows: maxShadows,\r\n			shadowMapEnabled: _this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,\r\n			shadowMapType: _this.shadowMapType,\r\n			shadowMapDebug: _this.shadowMapDebug,\r\n			shadowMapCascade: _this.shadowMapCascade,\r\n\r\n			alphaTest: material.alphaTest,\r\n			metal: material.metal,\r\n			wrapAround: material.wrapAround,\r\n			doubleSided: material.side === THREE.DoubleSide,\r\n			flipSided: material.side === THREE.BackSide\r\n\r\n		};\r\n\r\n		// Generate code\r\n\r\n		var chunks = [];\r\n\r\n		if ( shaderID ) {\r\n\r\n			chunks.push( shaderID );\r\n\r\n		} else {\r\n\r\n			chunks.push( material.fragmentShader );\r\n			chunks.push( material.vertexShader );\r\n\r\n		}\r\n\r\n		if ( material.defines !== undefined ) {\r\n\r\n			for ( var name in material.defines ) {\r\n\r\n				chunks.push( name );\r\n				chunks.push( material.defines[ name ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( var name in parameters ) {\r\n\r\n			chunks.push( name );\r\n			chunks.push( parameters[ name ] );\r\n\r\n		}\r\n\r\n		var code = chunks.join();\r\n\r\n		var program;\r\n\r\n		// Check if code has been already compiled\r\n\r\n		for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {\r\n\r\n			var programInfo = _programs[ p ];\r\n\r\n			if ( programInfo.code === code ) {\r\n\r\n				program = programInfo;\r\n				program.usedTimes ++;\r\n\r\n				break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( program === undefined ) {\r\n\r\n			program = new THREE.WebGLProgram( _this, code, material, parameters );\r\n			_programs.push( program );\r\n\r\n			_this.info.memory.programs = _programs.length;\r\n\r\n		}\r\n\r\n		material.program = program;\r\n\r\n		var attributes = program.attributes;\r\n\r\n		if ( material.morphTargets ) {\r\n\r\n			material.numSupportedMorphTargets = 0;\r\n\r\n			var id, base = 'morphTarget';\r\n\r\n			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n				id = base + i;\r\n\r\n				if ( attributes[ id ] >= 0 ) {\r\n\r\n					material.numSupportedMorphTargets ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( material.morphNormals ) {\r\n\r\n			material.numSupportedMorphNormals = 0;\r\n\r\n			var id, base = 'morphNormal';\r\n\r\n			for ( i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n				id = base + i;\r\n\r\n				if ( attributes[ id ] >= 0 ) {\r\n\r\n					material.numSupportedMorphNormals ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		material.uniformsList = [];\r\n\r\n		for ( var u in material.__webglShader.uniforms ) {\r\n\r\n			var location = material.program.uniforms[ u ];\r\n\r\n			if ( location ) {\r\n				material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setProgram( camera, lights, fog, material, object ) {\r\n\r\n		_usedTextureUnits = 0;\r\n\r\n		if ( material.needsUpdate ) {\r\n\r\n			if ( material.program ) deallocateMaterial( material );\r\n\r\n			initMaterial( material, lights, fog, object );\r\n			material.needsUpdate = false;\r\n\r\n		}\r\n\r\n		if ( material.morphTargets ) {\r\n\r\n			if ( ! object.__webglMorphTargetInfluences ) {\r\n\r\n				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var refreshProgram = false;\r\n		var refreshMaterial = false;\r\n		var refreshLights = false;\r\n\r\n		var program = material.program,\r\n			p_uniforms = program.uniforms,\r\n			m_uniforms = material.__webglShader.uniforms;\r\n\r\n		if ( program.id !== _currentProgram ) {\r\n\r\n			_gl.useProgram( program.program );\r\n			_currentProgram = program.id;\r\n\r\n			refreshProgram = true;\r\n			refreshMaterial = true;\r\n			refreshLights = true;\r\n\r\n		}\r\n\r\n		if ( material.id !== _currentMaterialId ) {\r\n\r\n			if ( _currentMaterialId === -1 ) refreshLights = true;\r\n			_currentMaterialId = material.id;\r\n\r\n			refreshMaterial = true;\r\n\r\n		}\r\n\r\n		if ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n			if ( _logarithmicDepthBuffer ) {\r\n\r\n				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n			}\r\n\r\n\r\n			if ( camera !== _currentCamera ) _currentCamera = camera;\r\n\r\n			// load material specific uniforms\r\n			// (shader material also gets them for the sake of genericity)\r\n\r\n			if ( material instanceof THREE.ShaderMaterial ||\r\n				 material instanceof THREE.MeshPhongMaterial ||\r\n				 material.envMap ) {\r\n\r\n				if ( p_uniforms.cameraPosition !== null ) {\r\n\r\n					_vector3.setFromMatrixPosition( camera.matrixWorld );\r\n					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material instanceof THREE.MeshBasicMaterial ||\r\n				 material instanceof THREE.ShaderMaterial ||\r\n				 material.skinning ) {\r\n\r\n				if ( p_uniforms.viewMatrix !== null ) {\r\n\r\n					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// skinning uniforms must be set even if material didn't change\r\n		// auto-setting of texture unit for bone texture must go before other textures\r\n		// not sure why, but otherwise weird things happen\r\n\r\n		if ( material.skinning ) {\r\n\r\n			if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {\r\n\r\n				_gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );\r\n\r\n			}\r\n\r\n			if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {\r\n\r\n				_gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );\r\n\r\n			}\r\n\r\n			if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n				if ( p_uniforms.boneTexture !== null ) {\r\n\r\n					var textureUnit = getTextureUnit();\r\n\r\n					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );\r\n					_this.setTexture( object.skeleton.boneTexture, textureUnit );\r\n\r\n				}\r\n\r\n				if ( p_uniforms.boneTextureWidth !== null ) {\r\n\r\n					_gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );\r\n\r\n				}\r\n\r\n				if ( p_uniforms.boneTextureHeight !== null ) {\r\n\r\n					_gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );\r\n\r\n				}\r\n\r\n			} else if ( object.skeleton && object.skeleton.boneMatrices ) {\r\n\r\n				if ( p_uniforms.boneGlobalMatrices !== null ) {\r\n\r\n					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( refreshMaterial ) {\r\n\r\n			// refresh uniforms common to several materials\r\n\r\n			if ( fog && material.fog ) {\r\n\r\n				refreshUniformsFog( m_uniforms, fog );\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshPhongMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material.lights ) {\r\n\r\n				if ( _lightsNeedUpdate ) {\r\n\r\n					refreshLights = true;\r\n					setupLights( lights );\r\n					_lightsNeedUpdate = false;\r\n				}\r\n\r\n				if ( refreshLights ) {\r\n					refreshUniformsLights( m_uniforms, _lights );\r\n					markUniformsLightsNeedsUpdate( m_uniforms, true );\r\n				} else {\r\n					markUniformsLightsNeedsUpdate( m_uniforms, false );\r\n				}\r\n\r\n			}\r\n\r\n			if ( material instanceof THREE.MeshBasicMaterial ||\r\n				 material instanceof THREE.MeshLambertMaterial ||\r\n				 material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n				refreshUniformsCommon( m_uniforms, material );\r\n\r\n			}\r\n\r\n			// refresh single material specific uniforms\r\n\r\n			if ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n				refreshUniformsLine( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n				refreshUniformsLine( m_uniforms, material );\r\n				refreshUniformsDash( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.PointCloudMaterial ) {\r\n\r\n				refreshUniformsParticle( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n				refreshUniformsPhong( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n				refreshUniformsLambert( m_uniforms, material );\r\n\r\n			} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n				m_uniforms.mNear.value = camera.near;\r\n				m_uniforms.mFar.value = camera.far;\r\n				m_uniforms.opacity.value = material.opacity;\r\n\r\n			} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n				m_uniforms.opacity.value = material.opacity;\r\n\r\n			}\r\n\r\n			if ( object.receiveShadow && ! material._shadowPass ) {\r\n\r\n				refreshUniformsShadow( m_uniforms, lights );\r\n\r\n			}\r\n\r\n			// load common uniforms\r\n\r\n			loadUniformsGeneric( material.uniformsList );\r\n\r\n		}\r\n\r\n		loadUniformsMatrices( p_uniforms, object );\r\n\r\n		if ( p_uniforms.modelMatrix !== null ) {\r\n\r\n			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );\r\n\r\n		}\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n	// Uniforms (refresh uniforms objects)\r\n\r\n	function refreshUniformsCommon ( uniforms, material ) {\r\n\r\n		uniforms.opacity.value = material.opacity;\r\n\r\n		if ( _this.gammaInput ) {\r\n\r\n			uniforms.diffuse.value.copyGammaToLinear( material.color );\r\n\r\n		} else {\r\n\r\n			uniforms.diffuse.value = material.color;\r\n\r\n		}\r\n\r\n		uniforms.map.value = material.map;\r\n		uniforms.lightMap.value = material.lightMap;\r\n		uniforms.specularMap.value = material.specularMap;\r\n		uniforms.alphaMap.value = material.alphaMap;\r\n\r\n		if ( material.bumpMap ) {\r\n\r\n			uniforms.bumpMap.value = material.bumpMap;\r\n			uniforms.bumpScale.value = material.bumpScale;\r\n\r\n		}\r\n\r\n		if ( material.normalMap ) {\r\n\r\n			uniforms.normalMap.value = material.normalMap;\r\n			uniforms.normalScale.value.copy( material.normalScale );\r\n\r\n		}\r\n\r\n		// uv repeat and offset setting priorities\r\n		//  1. color map\r\n		//  2. specular map\r\n		//  3. normal map\r\n		//  4. bump map\r\n		//  5. alpha map\r\n\r\n		var uvScaleMap;\r\n\r\n		if ( material.map ) {\r\n\r\n			uvScaleMap = material.map;\r\n\r\n		} else if ( material.specularMap ) {\r\n\r\n			uvScaleMap = material.specularMap;\r\n\r\n		} else if ( material.normalMap ) {\r\n\r\n			uvScaleMap = material.normalMap;\r\n\r\n		} else if ( material.bumpMap ) {\r\n\r\n			uvScaleMap = material.bumpMap;\r\n\r\n		} else if ( material.alphaMap ) {\r\n\r\n			uvScaleMap = material.alphaMap;\r\n\r\n		}\r\n\r\n		if ( uvScaleMap !== undefined ) {\r\n\r\n			var offset = uvScaleMap.offset;\r\n			var repeat = uvScaleMap.repeat;\r\n\r\n			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n		}\r\n\r\n		uniforms.envMap.value = material.envMap;\r\n		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;\r\n\r\n		if ( _this.gammaInput ) {\r\n\r\n			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;\r\n			uniforms.reflectivity.value = material.reflectivity;\r\n\r\n		} else {\r\n\r\n			uniforms.reflectivity.value = material.reflectivity;\r\n\r\n		}\r\n\r\n		uniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n	}\r\n\r\n	function refreshUniformsLine ( uniforms, material ) {\r\n\r\n		uniforms.diffuse.value = material.color;\r\n		uniforms.opacity.value = material.opacity;\r\n\r\n	}\r\n\r\n	function refreshUniformsDash ( uniforms, material ) {\r\n\r\n		uniforms.dashSize.value = material.dashSize;\r\n		uniforms.totalSize.value = material.dashSize + material.gapSize;\r\n		uniforms.scale.value = material.scale;\r\n\r\n	}\r\n\r\n	function refreshUniformsParticle ( uniforms, material ) {\r\n\r\n		uniforms.psColor.value = material.color;\r\n		uniforms.opacity.value = material.opacity;\r\n		uniforms.size.value = material.size;\r\n		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.\r\n\r\n		uniforms.map.value = material.map;\r\n\r\n	}\r\n\r\n	function refreshUniformsFog ( uniforms, fog ) {\r\n\r\n		uniforms.fogColor.value = fog.color;\r\n\r\n		if ( fog instanceof THREE.Fog ) {\r\n\r\n			uniforms.fogNear.value = fog.near;\r\n			uniforms.fogFar.value = fog.far;\r\n\r\n		} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n			uniforms.fogDensity.value = fog.density;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsPhong ( uniforms, material ) {\r\n\r\n		uniforms.shininess.value = material.shininess;\r\n\r\n		if ( _this.gammaInput ) {\r\n\r\n			uniforms.ambient.value.copyGammaToLinear( material.ambient );\r\n			uniforms.emissive.value.copyGammaToLinear( material.emissive );\r\n			uniforms.specular.value.copyGammaToLinear( material.specular );\r\n\r\n		} else {\r\n\r\n			uniforms.ambient.value = material.ambient;\r\n			uniforms.emissive.value = material.emissive;\r\n			uniforms.specular.value = material.specular;\r\n\r\n		}\r\n\r\n		if ( material.wrapAround ) {\r\n\r\n			uniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsLambert ( uniforms, material ) {\r\n\r\n		if ( _this.gammaInput ) {\r\n\r\n			uniforms.ambient.value.copyGammaToLinear( material.ambient );\r\n			uniforms.emissive.value.copyGammaToLinear( material.emissive );\r\n\r\n		} else {\r\n\r\n			uniforms.ambient.value = material.ambient;\r\n			uniforms.emissive.value = material.emissive;\r\n\r\n		}\r\n\r\n		if ( material.wrapAround ) {\r\n\r\n			uniforms.wrapRGB.value.copy( material.wrapRGB );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function refreshUniformsLights ( uniforms, lights ) {\r\n\r\n		uniforms.ambientLightColor.value = lights.ambient;\r\n\r\n		uniforms.directionalLightColor.value = lights.directional.colors;\r\n		uniforms.directionalLightDirection.value = lights.directional.positions;\r\n\r\n		uniforms.pointLightColor.value = lights.point.colors;\r\n		uniforms.pointLightPosition.value = lights.point.positions;\r\n		uniforms.pointLightDistance.value = lights.point.distances;\r\n\r\n		uniforms.spotLightColor.value = lights.spot.colors;\r\n		uniforms.spotLightPosition.value = lights.spot.positions;\r\n		uniforms.spotLightDistance.value = lights.spot.distances;\r\n		uniforms.spotLightDirection.value = lights.spot.directions;\r\n		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;\r\n		uniforms.spotLightExponent.value = lights.spot.exponents;\r\n\r\n		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;\r\n		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;\r\n		uniforms.hemisphereLightDirection.value = lights.hemi.positions;\r\n\r\n	}\r\n\r\n	// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n	function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {\r\n\r\n		uniforms.ambientLightColor.needsUpdate = boolean;\r\n\r\n		uniforms.directionalLightColor.needsUpdate = boolean;\r\n		uniforms.directionalLightDirection.needsUpdate = boolean;\r\n\r\n		uniforms.pointLightColor.needsUpdate = boolean;\r\n		uniforms.pointLightPosition.needsUpdate = boolean;\r\n		uniforms.pointLightDistance.needsUpdate = boolean;\r\n\r\n		uniforms.spotLightColor.needsUpdate = boolean;\r\n		uniforms.spotLightPosition.needsUpdate = boolean;\r\n		uniforms.spotLightDistance.needsUpdate = boolean;\r\n		uniforms.spotLightDirection.needsUpdate = boolean;\r\n		uniforms.spotLightAngleCos.needsUpdate = boolean;\r\n		uniforms.spotLightExponent.needsUpdate = boolean;\r\n\r\n		uniforms.hemisphereLightSkyColor.needsUpdate = boolean;\r\n		uniforms.hemisphereLightGroundColor.needsUpdate = boolean;\r\n		uniforms.hemisphereLightDirection.needsUpdate = boolean;\r\n\r\n	}\r\n\r\n	function refreshUniformsShadow ( uniforms, lights ) {\r\n\r\n		if ( uniforms.shadowMatrix ) {\r\n\r\n			var j = 0;\r\n\r\n			for ( var i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n				var light = lights[ i ];\r\n\r\n				if ( ! light.castShadow ) continue;\r\n\r\n				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {\r\n\r\n					uniforms.shadowMap.value[ j ] = light.shadowMap;\r\n					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;\r\n\r\n					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;\r\n\r\n					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;\r\n					uniforms.shadowBias.value[ j ] = light.shadowBias;\r\n\r\n					j ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Uniforms (load to GPU)\r\n\r\n	function loadUniformsMatrices ( uniforms, object ) {\r\n\r\n		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );\r\n\r\n		if ( uniforms.normalMatrix ) {\r\n\r\n			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function getTextureUnit() {\r\n\r\n		var textureUnit = _usedTextureUnits;\r\n\r\n		if ( textureUnit >= _maxTextures ) {\r\n\r\n			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );\r\n\r\n		}\r\n\r\n		_usedTextureUnits += 1;\r\n\r\n		return textureUnit;\r\n\r\n	}\r\n\r\n	function loadUniformsGeneric ( uniforms ) {\r\n\r\n		var texture, textureUnit, offset;\r\n\r\n		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {\r\n\r\n			var uniform = uniforms[ j ][ 0 ];\r\n\r\n			// needsUpdate property is not added to all uniforms.\r\n			if ( uniform.needsUpdate === false ) continue;\r\n\r\n			var type = uniform.type;\r\n			var value = uniform.value;\r\n			var location = uniforms[ j ][ 1 ];\r\n\r\n			switch ( type ) {\r\n\r\n				case '1i':\r\n					_gl.uniform1i( location, value );\r\n					break;\r\n\r\n				case '1f':\r\n					_gl.uniform1f( location, value );\r\n					break;\r\n\r\n				case '2f':\r\n					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );\r\n					break;\r\n\r\n				case '3f':\r\n					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );\r\n					break;\r\n\r\n				case '4f':\r\n					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );\r\n					break;\r\n\r\n				case '1iv':\r\n					_gl.uniform1iv( location, value );\r\n					break;\r\n\r\n				case '3iv':\r\n					_gl.uniform3iv( location, value );\r\n					break;\r\n\r\n				case '1fv':\r\n					_gl.uniform1fv( location, value );\r\n					break;\r\n\r\n				case '2fv':\r\n					_gl.uniform2fv( location, value );\r\n					break;\r\n\r\n				case '3fv':\r\n					_gl.uniform3fv( location, value );\r\n					break;\r\n\r\n				case '4fv':\r\n					_gl.uniform4fv( location, value );\r\n					break;\r\n\r\n				case 'Matrix3fv':\r\n					_gl.uniformMatrix3fv( location, false, value );\r\n					break;\r\n\r\n				case 'Matrix4fv':\r\n					_gl.uniformMatrix4fv( location, false, value );\r\n					break;\r\n\r\n				//\r\n\r\n				case 'i':\r\n\r\n					// single integer\r\n					_gl.uniform1i( location, value );\r\n\r\n					break;\r\n\r\n				case 'f':\r\n\r\n					// single float\r\n					_gl.uniform1f( location, value );\r\n\r\n					break;\r\n\r\n				case 'v2':\r\n\r\n					// single THREE.Vector2\r\n					_gl.uniform2f( location, value.x, value.y );\r\n\r\n					break;\r\n\r\n				case 'v3':\r\n\r\n					// single THREE.Vector3\r\n					_gl.uniform3f( location, value.x, value.y, value.z );\r\n\r\n					break;\r\n\r\n				case 'v4':\r\n\r\n					// single THREE.Vector4\r\n					_gl.uniform4f( location, value.x, value.y, value.z, value.w );\r\n\r\n					break;\r\n\r\n				case 'c':\r\n\r\n					// single THREE.Color\r\n					_gl.uniform3f( location, value.r, value.g, value.b );\r\n\r\n					break;\r\n\r\n				case 'iv1':\r\n\r\n					// flat array of integers (JS or typed array)\r\n					_gl.uniform1iv( location, value );\r\n\r\n					break;\r\n\r\n				case 'iv':\r\n\r\n					// flat array of integers with 3 x N size (JS or typed array)\r\n					_gl.uniform3iv( location, value );\r\n\r\n					break;\r\n\r\n				case 'fv1':\r\n\r\n					// flat array of floats (JS or typed array)\r\n					_gl.uniform1fv( location, value );\r\n\r\n					break;\r\n\r\n				case 'fv':\r\n\r\n					// flat array of floats with 3 x N size (JS or typed array)\r\n					_gl.uniform3fv( location, value );\r\n\r\n					break;\r\n\r\n				case 'v2v':\r\n\r\n					// array of THREE.Vector2\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 2 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						offset = i * 2;\r\n\r\n						uniform._array[ offset ]   = value[ i ].x;\r\n						uniform._array[ offset + 1 ] = value[ i ].y;\r\n\r\n					}\r\n\r\n					_gl.uniform2fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'v3v':\r\n\r\n					// array of THREE.Vector3\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 3 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						offset = i * 3;\r\n\r\n						uniform._array[ offset ]   = value[ i ].x;\r\n						uniform._array[ offset + 1 ] = value[ i ].y;\r\n						uniform._array[ offset + 2 ] = value[ i ].z;\r\n\r\n					}\r\n\r\n					_gl.uniform3fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'v4v':\r\n\r\n					// array of THREE.Vector4\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 4 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						offset = i * 4;\r\n\r\n						uniform._array[ offset ]   = value[ i ].x;\r\n						uniform._array[ offset + 1 ] = value[ i ].y;\r\n						uniform._array[ offset + 2 ] = value[ i ].z;\r\n						uniform._array[ offset + 3 ] = value[ i ].w;\r\n\r\n					}\r\n\r\n					_gl.uniform4fv( location, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'm3':\r\n\r\n					// single THREE.Matrix3\r\n					_gl.uniformMatrix3fv( location, false, value.elements );\r\n\r\n					break;\r\n\r\n				case 'm3v':\r\n\r\n					// array of THREE.Matrix3\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 9 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );\r\n\r\n					}\r\n\r\n					_gl.uniformMatrix3fv( location, false, uniform._array );\r\n\r\n					break;\r\n\r\n				case 'm4':\r\n\r\n					// single THREE.Matrix4\r\n					_gl.uniformMatrix4fv( location, false, value.elements );\r\n\r\n					break;\r\n\r\n				case 'm4v':\r\n\r\n					// array of THREE.Matrix4\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = new Float32Array( 16 * value.length );\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = value.length; i < il; i ++ ) {\r\n\r\n						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );\r\n\r\n					}\r\n\r\n					_gl.uniformMatrix4fv( location, false, uniform._array );\r\n\r\n					break;\r\n\r\n				case 't':\r\n\r\n					// single THREE.Texture (2d or cube)\r\n\r\n					texture = value;\r\n					textureUnit = getTextureUnit();\r\n\r\n					_gl.uniform1i( location, textureUnit );\r\n\r\n					if ( ! texture ) continue;\r\n\r\n					if ( texture instanceof THREE.CubeTexture ||\r\n					   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/\r\n\r\n						setCubeTexture( texture, textureUnit );\r\n\r\n					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n						setCubeTextureDynamic( texture, textureUnit );\r\n\r\n					} else {\r\n\r\n						_this.setTexture( texture, textureUnit );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				case 'tv':\r\n\r\n					// array of THREE.Texture (2d)\r\n\r\n					if ( uniform._array === undefined ) {\r\n\r\n						uniform._array = [];\r\n\r\n					}\r\n\r\n					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n						uniform._array[ i ] = getTextureUnit();\r\n\r\n					}\r\n\r\n					_gl.uniform1iv( location, uniform._array );\r\n\r\n					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {\r\n\r\n						texture = uniform.value[ i ];\r\n						textureUnit = uniform._array[ i ];\r\n\r\n						if ( ! texture ) continue;\r\n\r\n						_this.setTexture( texture, textureUnit );\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				default:\r\n\r\n					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setupMatrices ( object, camera ) {\r\n\r\n		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );\r\n\r\n	}\r\n\r\n	//\r\n\r\n	function setColorGamma( array, offset, color, intensitySq ) {\r\n\r\n		array[ offset ]     = color.r * color.r * intensitySq;\r\n		array[ offset + 1 ] = color.g * color.g * intensitySq;\r\n		array[ offset + 2 ] = color.b * color.b * intensitySq;\r\n\r\n	}\r\n\r\n	function setColorLinear( array, offset, color, intensity ) {\r\n\r\n		array[ offset ]     = color.r * intensity;\r\n		array[ offset + 1 ] = color.g * intensity;\r\n		array[ offset + 2 ] = color.b * intensity;\r\n\r\n	}\r\n\r\n	function setupLights ( lights ) {\r\n\r\n		var l, ll, light, n,\r\n		r = 0, g = 0, b = 0,\r\n		color, skyColor, groundColor,\r\n		intensity,  intensitySq,\r\n		position,\r\n		distance,\r\n\r\n		zlights = _lights,\r\n\r\n		dirColors = zlights.directional.colors,\r\n		dirPositions = zlights.directional.positions,\r\n\r\n		pointColors = zlights.point.colors,\r\n		pointPositions = zlights.point.positions,\r\n		pointDistances = zlights.point.distances,\r\n\r\n		spotColors = zlights.spot.colors,\r\n		spotPositions = zlights.spot.positions,\r\n		spotDistances = zlights.spot.distances,\r\n		spotDirections = zlights.spot.directions,\r\n		spotAnglesCos = zlights.spot.anglesCos,\r\n		spotExponents = zlights.spot.exponents,\r\n\r\n		hemiSkyColors = zlights.hemi.skyColors,\r\n		hemiGroundColors = zlights.hemi.groundColors,\r\n		hemiPositions = zlights.hemi.positions,\r\n\r\n		dirLength = 0,\r\n		pointLength = 0,\r\n		spotLength = 0,\r\n		hemiLength = 0,\r\n\r\n		dirCount = 0,\r\n		pointCount = 0,\r\n		spotCount = 0,\r\n		hemiCount = 0,\r\n\r\n		dirOffset = 0,\r\n		pointOffset = 0,\r\n		spotOffset = 0,\r\n		hemiOffset = 0;\r\n\r\n		for ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n			light = lights[ l ];\r\n\r\n			if ( light.onlyShadow ) continue;\r\n\r\n			color = light.color;\r\n			intensity = light.intensity;\r\n			distance = light.distance;\r\n\r\n			if ( light instanceof THREE.AmbientLight ) {\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				if ( _this.gammaInput ) {\r\n\r\n					r += color.r * color.r;\r\n					g += color.g * color.g;\r\n					b += color.b * color.b;\r\n\r\n				} else {\r\n\r\n					r += color.r;\r\n					g += color.g;\r\n					b += color.b;\r\n\r\n				}\r\n\r\n			} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n				dirCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				_direction.setFromMatrixPosition( light.matrixWorld );\r\n				_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n				_direction.sub( _vector3 );\r\n				_direction.normalize();\r\n\r\n				dirOffset = dirLength * 3;\r\n\r\n				dirPositions[ dirOffset ]     = _direction.x;\r\n				dirPositions[ dirOffset + 1 ] = _direction.y;\r\n				dirPositions[ dirOffset + 2 ] = _direction.z;\r\n\r\n				if ( _this.gammaInput ) {\r\n\r\n					setColorGamma( dirColors, dirOffset, color, intensity * intensity );\r\n\r\n				} else {\r\n\r\n					setColorLinear( dirColors, dirOffset, color, intensity );\r\n\r\n				}\r\n\r\n				dirLength += 1;\r\n\r\n			} else if ( light instanceof THREE.PointLight ) {\r\n\r\n				pointCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				pointOffset = pointLength * 3;\r\n\r\n				if ( _this.gammaInput ) {\r\n\r\n					setColorGamma( pointColors, pointOffset, color, intensity * intensity );\r\n\r\n				} else {\r\n\r\n					setColorLinear( pointColors, pointOffset, color, intensity );\r\n\r\n				}\r\n\r\n				_vector3.setFromMatrixPosition( light.matrixWorld );\r\n\r\n				pointPositions[ pointOffset ]     = _vector3.x;\r\n				pointPositions[ pointOffset + 1 ] = _vector3.y;\r\n				pointPositions[ pointOffset + 2 ] = _vector3.z;\r\n\r\n				pointDistances[ pointLength ] = distance;\r\n\r\n				pointLength += 1;\r\n\r\n			} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n				spotCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				spotOffset = spotLength * 3;\r\n\r\n				if ( _this.gammaInput ) {\r\n\r\n					setColorGamma( spotColors, spotOffset, color, intensity * intensity );\r\n\r\n				} else {\r\n\r\n					setColorLinear( spotColors, spotOffset, color, intensity );\r\n\r\n				}\r\n\r\n				_direction.setFromMatrixPosition( light.matrixWorld );\r\n\r\n				spotPositions[ spotOffset ]     = _direction.x;\r\n				spotPositions[ spotOffset + 1 ] = _direction.y;\r\n				spotPositions[ spotOffset + 2 ] = _direction.z;\r\n\r\n				spotDistances[ spotLength ] = distance;\r\n\r\n				_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n				_direction.sub( _vector3 );\r\n				_direction.normalize();\r\n\r\n				spotDirections[ spotOffset ]     = _direction.x;\r\n				spotDirections[ spotOffset + 1 ] = _direction.y;\r\n				spotDirections[ spotOffset + 2 ] = _direction.z;\r\n\r\n				spotAnglesCos[ spotLength ] = Math.cos( light.angle );\r\n				spotExponents[ spotLength ] = light.exponent;\r\n\r\n				spotLength += 1;\r\n\r\n			} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n				hemiCount += 1;\r\n\r\n				if ( ! light.visible ) continue;\r\n\r\n				_direction.setFromMatrixPosition( light.matrixWorld );\r\n				_direction.normalize();\r\n\r\n				hemiOffset = hemiLength * 3;\r\n\r\n				hemiPositions[ hemiOffset ]     = _direction.x;\r\n				hemiPositions[ hemiOffset + 1 ] = _direction.y;\r\n				hemiPositions[ hemiOffset + 2 ] = _direction.z;\r\n\r\n				skyColor = light.color;\r\n				groundColor = light.groundColor;\r\n\r\n				if ( _this.gammaInput ) {\r\n\r\n					intensitySq = intensity * intensity;\r\n\r\n					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );\r\n					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );\r\n\r\n				} else {\r\n\r\n					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );\r\n					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );\r\n\r\n				}\r\n\r\n				hemiLength += 1;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// null eventual remains from removed lights\r\n		// (this is to avoid if in shader)\r\n\r\n		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;\r\n		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;\r\n		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;\r\n		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;\r\n		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;\r\n\r\n		zlights.directional.length = dirLength;\r\n		zlights.point.length = pointLength;\r\n		zlights.spot.length = spotLength;\r\n		zlights.hemi.length = hemiLength;\r\n\r\n		zlights.ambient[ 0 ] = r;\r\n		zlights.ambient[ 1 ] = g;\r\n		zlights.ambient[ 2 ] = b;\r\n\r\n	}\r\n\r\n	// GL state setting\r\n\r\n	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n		if ( cullFace === THREE.CullFaceNone ) {\r\n\r\n			_gl.disable( _gl.CULL_FACE );\r\n\r\n		} else {\r\n\r\n			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {\r\n\r\n				_gl.frontFace( _gl.CW );\r\n\r\n			} else {\r\n\r\n				_gl.frontFace( _gl.CCW );\r\n\r\n			}\r\n\r\n			if ( cullFace === THREE.CullFaceBack ) {\r\n\r\n				_gl.cullFace( _gl.BACK );\r\n\r\n			} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n				_gl.cullFace( _gl.FRONT );\r\n\r\n			} else {\r\n\r\n				_gl.cullFace( _gl.FRONT_AND_BACK );\r\n\r\n			}\r\n\r\n			_gl.enable( _gl.CULL_FACE );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setMaterialFaces = function ( material ) {\r\n\r\n		var doubleSided = material.side === THREE.DoubleSide;\r\n		var flipSided = material.side === THREE.BackSide;\r\n\r\n		if ( _oldDoubleSided !== doubleSided ) {\r\n\r\n			if ( doubleSided ) {\r\n\r\n				_gl.disable( _gl.CULL_FACE );\r\n\r\n			} else {\r\n\r\n				_gl.enable( _gl.CULL_FACE );\r\n\r\n			}\r\n\r\n			_oldDoubleSided = doubleSided;\r\n\r\n		}\r\n\r\n		if ( _oldFlipSided !== flipSided ) {\r\n\r\n			if ( flipSided ) {\r\n\r\n				_gl.frontFace( _gl.CW );\r\n\r\n			} else {\r\n\r\n				_gl.frontFace( _gl.CCW );\r\n\r\n			}\r\n\r\n			_oldFlipSided = flipSided;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthTest = function ( depthTest ) {\r\n\r\n		if ( _oldDepthTest !== depthTest ) {\r\n\r\n			if ( depthTest ) {\r\n\r\n				_gl.enable( _gl.DEPTH_TEST );\r\n\r\n			} else {\r\n\r\n				_gl.disable( _gl.DEPTH_TEST );\r\n\r\n			}\r\n\r\n			_oldDepthTest = depthTest;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	this.setDepthWrite = function ( depthWrite ) {\r\n\r\n		if ( _oldDepthWrite !== depthWrite ) {\r\n\r\n			_gl.depthMask( depthWrite );\r\n			_oldDepthWrite = depthWrite;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function setLineWidth ( width ) {\r\n\r\n		width *= pixelRatio;\r\n\r\n		if ( width !== _oldLineWidth ) {\r\n\r\n			_gl.lineWidth( width );\r\n\r\n			_oldLineWidth = width;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setPolygonOffset ( polygonoffset, factor, units ) {\r\n\r\n		if ( _oldPolygonOffset !== polygonoffset ) {\r\n\r\n			if ( polygonoffset ) {\r\n\r\n				_gl.enable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n			} else {\r\n\r\n				_gl.disable( _gl.POLYGON_OFFSET_FILL );\r\n\r\n			}\r\n\r\n			_oldPolygonOffset = polygonoffset;\r\n\r\n		}\r\n\r\n		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {\r\n\r\n			_gl.polygonOffset( factor, units );\r\n\r\n			_oldPolygonOffsetFactor = factor;\r\n			_oldPolygonOffsetUnits = units;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {\r\n\r\n		if ( blending !== _oldBlending ) {\r\n\r\n			if ( blending === THREE.NoBlending ) {\r\n\r\n				_gl.disable( _gl.BLEND );\r\n\r\n			} else if ( blending === THREE.AdditiveBlending ) {\r\n\r\n				_gl.enable( _gl.BLEND );\r\n				_gl.blendEquation( _gl.FUNC_ADD );\r\n				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );\r\n\r\n			} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n				// TODO: Find blendFuncSeparate() combination\r\n				_gl.enable( _gl.BLEND );\r\n				_gl.blendEquation( _gl.FUNC_ADD );\r\n				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );\r\n\r\n			} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n				// TODO: Find blendFuncSeparate() combination\r\n				_gl.enable( _gl.BLEND );\r\n				_gl.blendEquation( _gl.FUNC_ADD );\r\n				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );\r\n\r\n			} else if ( blending === THREE.CustomBlending ) {\r\n\r\n				_gl.enable( _gl.BLEND );\r\n\r\n			} else {\r\n\r\n				_gl.enable( _gl.BLEND );\r\n				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );\r\n				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n			}\r\n\r\n			_oldBlending = blending;\r\n\r\n		}\r\n\r\n		if ( blending === THREE.CustomBlending ) {\r\n\r\n			if ( blendEquation !== _oldBlendEquation ) {\r\n\r\n				_gl.blendEquation( paramThreeToGL( blendEquation ) );\r\n\r\n				_oldBlendEquation = blendEquation;\r\n\r\n			}\r\n\r\n			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {\r\n\r\n				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );\r\n\r\n				_oldBlendSrc = blendSrc;\r\n				_oldBlendDst = blendDst;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			_oldBlendEquation = null;\r\n			_oldBlendSrc = null;\r\n			_oldBlendDst = null;\r\n\r\n		}\r\n\r\n	};\r\n\r\n	// Textures\r\n\r\n	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {\r\n\r\n		var extension;\r\n\r\n		if ( isImagePowerOfTwo ) {\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n		} else {\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT is set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );\r\n\r\n			}\r\n\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter is set to THREE.LinearFilter or THREE.NearestFilter. ( ' + texture.sourceFile + ' )' );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n		if ( extension && texture.type !== THREE.FloatType ) {\r\n\r\n			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {\r\n\r\n				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n				texture.__oldAnisotropy = texture.anisotropy;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.uploadTexture = function ( texture ) {\r\n\r\n		if ( texture.__webglInit === undefined ) {\r\n\r\n			texture.__webglInit = true;\r\n\r\n			texture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n			texture.__webglTexture = _gl.createTexture();\r\n\r\n			_this.info.memory.textures ++;\r\n\r\n		}\r\n\r\n		_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n		texture.image = clampToMaxSize( texture.image, _maxTextureSize );\r\n\r\n		var image = texture.image,\r\n		isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n		glFormat = paramThreeToGL( texture.format ),\r\n		glType = paramThreeToGL( texture.type );\r\n\r\n		setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );\r\n\r\n		var mipmap, mipmaps = texture.mipmaps;\r\n\r\n		if ( texture instanceof THREE.DataTexture ) {\r\n\r\n			// use manually created mipmaps if available\r\n			// if there are no manual mipmaps\r\n			// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n					mipmap = mipmaps[ i ];\r\n					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n				}\r\n\r\n				texture.generateMipmaps = false;\r\n\r\n			} else {\r\n\r\n				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n			}\r\n\r\n		} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n				mipmap = mipmaps[ i ];\r\n\r\n				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n					if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\r\n						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n					} else {\r\n\r\n						console.warn( \"Attempt to load unsupported compressed texture format\" );\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else { // regular Texture (image, video, canvas)\r\n\r\n			// use manually created mipmaps if available\r\n			// if there are no manual mipmaps\r\n			// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n			if ( mipmaps.length > 0 && isImagePowerOfTwo ) {\r\n\r\n				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n					mipmap = mipmaps[ i ];\r\n					_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n				}\r\n\r\n				texture.generateMipmaps = false;\r\n\r\n			} else {\r\n\r\n				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n		texture.needsUpdate = false;\r\n\r\n		if ( texture.onUpdate ) texture.onUpdate();\r\n\r\n	};\r\n\r\n	this.setTexture = function ( texture, slot ) {\r\n\r\n		_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n\r\n		if ( texture.needsUpdate ) {\r\n\r\n			_this.uploadTexture( texture );\r\n\r\n		} else {\r\n\r\n			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );\r\n\r\n		}\r\n\r\n	};\r\n\r\n	function clampToMaxSize ( image, maxSize ) {\r\n\r\n		if ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n			// Warning: Scaling through the canvas will only work with images that use\r\n			// premultiplied alpha.\r\n\r\n			var scale = maxSize / Math.max( image.width, image.height );\r\n\r\n			var canvas = document.createElement( 'canvas' );\r\n			canvas.width = Math.floor( image.width * scale );\r\n			canvas.height = Math.floor( image.height * scale );\r\n\r\n			var context = canvas.getContext( '2d' );\r\n			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n			console.log( 'THREE.WebGLRenderer:', image, 'is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height + '.' );\r\n\r\n			return canvas;\r\n\r\n		}\r\n\r\n		return image;\r\n\r\n	}\r\n\r\n	function setCubeTexture ( texture, slot ) {\r\n\r\n		if ( texture.image.length === 6 ) {\r\n\r\n			if ( texture.needsUpdate ) {\r\n\r\n				if ( ! texture.image.__webglTextureCube ) {\r\n\r\n					texture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n					texture.image.__webglTextureCube = _gl.createTexture();\r\n\r\n					_this.info.memory.textures ++;\r\n\r\n				}\r\n\r\n				_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n				var isCompressed = texture instanceof THREE.CompressedTexture;\r\n				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n				var cubeImage = [];\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );\r\n\r\n					} else {\r\n\r\n						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n					}\r\n\r\n				}\r\n\r\n				var image = cubeImage[ 0 ],\r\n				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),\r\n				glFormat = paramThreeToGL( texture.format ),\r\n				glType = paramThreeToGL( texture.type );\r\n\r\n				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					if ( ! isCompressed ) {\r\n\r\n						if ( isDataTexture ) {\r\n\r\n							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n						} else {\r\n\r\n							_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n						}\r\n\r\n					} else {\r\n\r\n						var mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n							mipmap = mipmaps[ j ];\r\n\r\n							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n								if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {\r\n\r\n									_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n								} else {\r\n\r\n									console.warn( \"Attempt to load unsupported compressed texture format\" );\r\n\r\n								}\r\n\r\n							} else {\r\n\r\n								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n							}\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n				if ( texture.generateMipmaps && isImagePowerOfTwo ) {\r\n\r\n					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n				}\r\n\r\n				texture.needsUpdate = false;\r\n\r\n				if ( texture.onUpdate ) texture.onUpdate();\r\n\r\n			} else {\r\n\r\n				_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function setCubeTextureDynamic ( texture, slot ) {\r\n\r\n		_gl.activeTexture( _gl.TEXTURE0 + slot );\r\n		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );\r\n\r\n	}\r\n\r\n	// Render targets\r\n\r\n	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {\r\n\r\n		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );\r\n\r\n	}\r\n\r\n	function setupRenderBuffer ( renderbuffer, renderTarget  ) {\r\n\r\n		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		/* For some reason this is not working. Defaulting to RGBA4.\r\n		} else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n		*/\r\n		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n		} else {\r\n\r\n			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.setRenderTarget = function ( renderTarget ) {\r\n\r\n		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n		if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {\r\n\r\n			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;\r\n			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;\r\n\r\n			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n			renderTarget.__webglTexture = _gl.createTexture();\r\n\r\n			_this.info.memory.textures ++;\r\n\r\n			// Setup texture, create render and frame buffers\r\n\r\n			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),\r\n				glFormat = paramThreeToGL( renderTarget.format ),\r\n				glType = paramThreeToGL( renderTarget.type );\r\n\r\n			if ( isCube ) {\r\n\r\n				renderTarget.__webglFramebuffer = [];\r\n				renderTarget.__webglRenderbuffer = [];\r\n\r\n				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );\r\n\r\n				for ( var i = 0; i < 6; i ++ ) {\r\n\r\n					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();\r\n\r\n					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );\r\n\r\n				}\r\n\r\n				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n			} else {\r\n\r\n				renderTarget.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n				if ( renderTarget.shareDepthFrom ) {\r\n\r\n					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;\r\n\r\n				} else {\r\n\r\n					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();\r\n\r\n				}\r\n\r\n				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );\r\n\r\n				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\r\n				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );\r\n\r\n				if ( renderTarget.shareDepthFrom ) {\r\n\r\n					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );\r\n\r\n					}\r\n\r\n				} else {\r\n\r\n					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );\r\n\r\n				}\r\n\r\n				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n			}\r\n\r\n			// Release everything\r\n\r\n			if ( isCube ) {\r\n\r\n				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n			} else {\r\n\r\n				_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n			}\r\n\r\n			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n		}\r\n\r\n		var framebuffer, width, height, vx, vy;\r\n\r\n		if ( renderTarget ) {\r\n\r\n			if ( isCube ) {\r\n\r\n				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n			} else {\r\n\r\n				framebuffer = renderTarget.__webglFramebuffer;\r\n\r\n			}\r\n\r\n			width = renderTarget.width;\r\n			height = renderTarget.height;\r\n\r\n			vx = 0;\r\n			vy = 0;\r\n\r\n		} else {\r\n\r\n			framebuffer = null;\r\n\r\n			width = _viewportWidth;\r\n			height = _viewportHeight;\r\n\r\n			vx = _viewportX;\r\n			vy = _viewportY;\r\n\r\n		}\r\n\r\n		if ( framebuffer !== _currentFramebuffer ) {\r\n\r\n			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n			_gl.viewport( vx, vy, width, height );\r\n\r\n			_currentFramebuffer = framebuffer;\r\n\r\n		}\r\n\r\n		_currentWidth = width;\r\n		_currentHeight = height;\r\n\r\n	};\r\n\r\n	function updateRenderTargetMipmap ( renderTarget ) {\r\n\r\n		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );\r\n			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n		} else {\r\n\r\n			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );\r\n			_gl.generateMipmap( _gl.TEXTURE_2D );\r\n			_gl.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Fallback filters for non-power-of-2 textures\r\n\r\n	function filterFallback ( f ) {\r\n\r\n		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n			return _gl.NEAREST;\r\n\r\n		}\r\n\r\n		return _gl.LINEAR;\r\n\r\n	}\r\n\r\n	// Map three.js constants to WebGL constants\r\n\r\n	function paramThreeToGL ( p ) {\r\n\r\n		var extension;\r\n\r\n		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n		if ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n		if ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n		if ( p === THREE.ByteType ) return _gl.BYTE;\r\n		if ( p === THREE.ShortType ) return _gl.SHORT;\r\n		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n		if ( p === THREE.IntType ) return _gl.INT;\r\n		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n		if ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n		if ( p === THREE.RGBFormat ) return _gl.RGB;\r\n		if ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\r\n		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n		if ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n		if ( p === THREE.OneFactor ) return _gl.ONE;\r\n		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n		}\r\n\r\n		extension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n		if ( extension !== null ) {\r\n\r\n			if ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n		}\r\n\r\n		return 0;\r\n\r\n	}\r\n\r\n	// Allocations\r\n\r\n	function allocateBones ( object ) {\r\n\r\n		if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n			return 1024;\r\n\r\n		} else {\r\n\r\n			// default for when object is not specified\r\n			// ( for example when prebuilding shader\r\n			//   to be used with multiple objects )\r\n			//\r\n			//  - leave some extra space for other uniforms\r\n			//  - limit here is ANGLE's 254 max uniform vectors\r\n			//    (up to 54 should be safe)\r\n\r\n			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n			var maxBones = nVertexMatrices;\r\n\r\n			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n				maxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n				if ( maxBones < object.skeleton.bones.length ) {\r\n\r\n					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			return maxBones;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function allocateLights( lights ) {\r\n\r\n		var dirLights = 0;\r\n		var pointLights = 0;\r\n		var spotLights = 0;\r\n		var hemiLights = 0;\r\n\r\n		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n			var light = lights[ l ];\r\n\r\n			if ( light.onlyShadow || light.visible === false ) continue;\r\n\r\n			if ( light instanceof THREE.DirectionalLight ) dirLights ++;\r\n			if ( light instanceof THREE.PointLight ) pointLights ++;\r\n			if ( light instanceof THREE.SpotLight ) spotLights ++;\r\n			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;\r\n\r\n		}\r\n\r\n		return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };\r\n\r\n	}\r\n\r\n	function allocateShadows( lights ) {\r\n\r\n		var maxShadows = 0;\r\n\r\n		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n			var light = lights[ l ];\r\n\r\n			if ( ! light.castShadow ) continue;\r\n\r\n			if ( light instanceof THREE.SpotLight ) maxShadows ++;\r\n			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;\r\n\r\n		}\r\n\r\n		return maxShadows;\r\n\r\n	}\r\n\r\n	// DEPRECATED\r\n\r\n	this.initMaterial = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\r\n	};\r\n\r\n	this.addPrePlugin = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\r\n	};\r\n\r\n	this.addPostPlugin = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\r\n	};\r\n\r\n	this.updateShadowMap = function () {\r\n\r\n		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n	this.width = width;\r\n	this.height = height;\r\n\r\n	options = options || {};\r\n\r\n	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;\r\n	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;\r\n	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;\r\n\r\n	this.offset = new THREE.Vector2( 0, 0 );\r\n	this.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;\r\n	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;\r\n\r\n	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\r\n	this.generateMipmaps = true;\r\n\r\n	this.shareDepthFrom = null;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTarget.prototype = {\r\n\r\n	constructor: THREE.WebGLRenderTarget,\r\n\r\n	setSize: function ( width, height ) {\r\n\r\n		this.width = width;\r\n		this.height = height;\r\n\r\n	},\r\n\r\n	clone: function () {\r\n\r\n		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );\r\n\r\n		tmp.wrapS = this.wrapS;\r\n		tmp.wrapT = this.wrapT;\r\n\r\n		tmp.magFilter = this.magFilter;\r\n		tmp.minFilter = this.minFilter;\r\n\r\n		tmp.anisotropy = this.anisotropy;\r\n\r\n		tmp.offset.copy( this.offset );\r\n		tmp.repeat.copy( this.repeat );\r\n\r\n		tmp.format = this.format;\r\n		tmp.type = this.type;\r\n\r\n		tmp.depthBuffer = this.depthBuffer;\r\n		tmp.stencilBuffer = this.stencilBuffer;\r\n\r\n		tmp.generateMipmaps = this.generateMipmaps;\r\n\r\n		tmp.shareDepthFrom = this.shareDepthFrom;\r\n\r\n		return tmp;\r\n\r\n	},\r\n\r\n	dispose: function () {\r\n\r\n		this.dispatchEvent( { type: 'dispose' } );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n	THREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n	var extensions = {};\r\n\r\n	this.get = function ( name ) {\r\n\r\n		if ( extensions[ name ] !== undefined ) {\r\n\r\n			return extensions[ name ];\r\n\r\n		}\r\n\r\n		var extension;\r\n\r\n		switch ( name ) {\r\n\r\n			case 'EXT_texture_filter_anisotropic':\r\n				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n				break;\r\n\r\n			case 'WEBGL_compressed_texture_s3tc':\r\n				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n				break;\r\n\r\n			case 'WEBGL_compressed_texture_pvrtc':\r\n				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n				break;\r\n\r\n			default:\r\n				extension = gl.getExtension( name );\r\n\r\n		}\r\n\r\n		if ( extension === null ) {\r\n\r\n			console.log( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n		}\r\n\r\n		extensions[ name ] = extension;\r\n\r\n		return extension;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n	var programIdCount = 0;\r\n\r\n	var generateDefines = function ( defines ) {\r\n\r\n		var value, chunk, chunks = [];\r\n\r\n		for ( var d in defines ) {\r\n\r\n			value = defines[ d ];\r\n			if ( value === false ) continue;\r\n\r\n			chunk = '#define ' + d + ' ' + value;\r\n			chunks.push( chunk );\r\n\r\n		}\r\n\r\n		return chunks.join( '\\n' );\r\n\r\n	};\r\n\r\n	var cacheUniformLocations = function ( gl, program, identifiers ) {\r\n\r\n		var uniforms = {};\r\n\r\n		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n			var id = identifiers[ i ];\r\n			uniforms[ id ] = gl.getUniformLocation( program, id );\r\n\r\n		}\r\n\r\n		return uniforms;\r\n\r\n	};\r\n\r\n	var cacheAttributeLocations = function ( gl, program, identifiers ) {\r\n\r\n		var attributes = {};\r\n\r\n		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {\r\n\r\n			var id = identifiers[ i ];\r\n			attributes[ id ] = gl.getAttribLocation( program, id );\r\n\r\n		}\r\n\r\n		return attributes;\r\n\r\n	};\r\n\r\n	return function ( renderer, code, material, parameters ) {\r\n\r\n		var _this = renderer;\r\n		var _gl = _this.context;\r\n\r\n		var defines = material.defines;\r\n		var uniforms = material.__webglShader.uniforms;\r\n		var attributes = material.attributes;\r\n\r\n		var vertexShader = material.__webglShader.vertexShader;\r\n		var fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n		var index0AttributeName = material.index0AttributeName;\r\n\r\n		if ( index0AttributeName === undefined && parameters.morphTargets === true ) {\r\n\r\n			// programs with morphTargets displace position out of attribute 0\r\n\r\n			index0AttributeName = 'position';\r\n\r\n		}\r\n\r\n		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n		}\r\n\r\n		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n		if ( parameters.envMap ) {\r\n\r\n			switch ( material.envMap.mapping ) {\r\n\r\n				case THREE.CubeReflectionMapping:\r\n				case THREE.CubeRefractionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n					break;\r\n\r\n				case THREE.EquirectangularReflectionMapping:\r\n				case THREE.EquirectangularRefractionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n					break;\r\n\r\n				case THREE.SphericalReflectionMapping:\r\n					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n					break;\r\n\r\n			}\r\n\r\n			switch ( material.envMap.mapping ) {\r\n\r\n				case THREE.CubeRefractionMapping:\r\n				case THREE.EquirectangularRefractionMapping:\r\n					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n					break;\r\n\r\n			}\r\n\r\n			switch ( material.combine ) {\r\n\r\n				case THREE.MultiplyOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n					break;\r\n\r\n				case THREE.MixOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n					break;\r\n\r\n				case THREE.AddOperation:\r\n					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n					break;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// console.log( 'building new program ' );\r\n\r\n		//\r\n\r\n		var customDefines = generateDefines( defines );\r\n\r\n		//\r\n\r\n		var program = _gl.createProgram();\r\n\r\n		var prefix_vertex, prefix_fragment;\r\n\r\n		if ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n			prefix_vertex = '';\r\n			prefix_fragment = '';\r\n\r\n		} else {\r\n\r\n			prefix_vertex = [\r\n\r\n				'precision ' + parameters.precision + ' float;',\r\n				'precision ' + parameters.precision + ' int;',\r\n\r\n				customDefines,\r\n\r\n				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n				_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n				_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\r\n				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n				'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n				'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n				parameters.map ? '#define USE_MAP' : '',\r\n				parameters.envMap ? '#define USE_ENVMAP' : '',\r\n				parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n				parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n				parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n				parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n				parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n				parameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n				parameters.skinning ? '#define USE_SKINNING' : '',\r\n				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n				parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',\r\n				parameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n				parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n				parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\r\n				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n				//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\r\n				'uniform mat4 modelMatrix;',\r\n				'uniform mat4 modelViewMatrix;',\r\n				'uniform mat4 projectionMatrix;',\r\n				'uniform mat4 viewMatrix;',\r\n				'uniform mat3 normalMatrix;',\r\n				'uniform vec3 cameraPosition;',\r\n\r\n				'attribute vec3 position;',\r\n				'attribute vec3 normal;',\r\n				'attribute vec2 uv;',\r\n				'attribute vec2 uv2;',\r\n\r\n				'#ifdef USE_COLOR',\r\n\r\n				'	attribute vec3 color;',\r\n\r\n				'#endif',\r\n\r\n				'#ifdef USE_MORPHTARGETS',\r\n\r\n				'	attribute vec3 morphTarget0;',\r\n				'	attribute vec3 morphTarget1;',\r\n				'	attribute vec3 morphTarget2;',\r\n				'	attribute vec3 morphTarget3;',\r\n\r\n				'	#ifdef USE_MORPHNORMALS',\r\n\r\n				'		attribute vec3 morphNormal0;',\r\n				'		attribute vec3 morphNormal1;',\r\n				'		attribute vec3 morphNormal2;',\r\n				'		attribute vec3 morphNormal3;',\r\n\r\n				'	#else',\r\n\r\n				'		attribute vec3 morphTarget4;',\r\n				'		attribute vec3 morphTarget5;',\r\n				'		attribute vec3 morphTarget6;',\r\n				'		attribute vec3 morphTarget7;',\r\n\r\n				'	#endif',\r\n\r\n				'#endif',\r\n\r\n				'#ifdef USE_SKINNING',\r\n\r\n				'	attribute vec4 skinIndex;',\r\n				'	attribute vec4 skinWeight;',\r\n\r\n				'#endif',\r\n\r\n				''\r\n\r\n			].join( '\\n' );\r\n\r\n			prefix_fragment = [\r\n\r\n				'precision ' + parameters.precision + ' float;',\r\n				'precision ' + parameters.precision + ' int;',\r\n\r\n				( parameters.bumpMap || parameters.normalMap ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\r\n				customDefines,\r\n\r\n				'#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,\r\n				'#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,\r\n				'#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,\r\n				'#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,\r\n\r\n				'#define MAX_SHADOWS ' + parameters.maxShadows,\r\n\r\n				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest: '',\r\n\r\n				_this.gammaInput ? '#define GAMMA_INPUT' : '',\r\n				_this.gammaOutput ? '#define GAMMA_OUTPUT' : '',\r\n\r\n				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n				parameters.map ? '#define USE_MAP' : '',\r\n				parameters.envMap ? '#define USE_ENVMAP' : '',\r\n				parameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n				parameters.envMap ? '#define ' + envMapModeDefine : '',\r\n				parameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n				parameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n				parameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n				parameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n				parameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n				parameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n				parameters.metal ? '#define METAL' : '',\r\n				parameters.wrapAround ? '#define WRAP_AROUND' : '',\r\n				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n				parameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n				parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',\r\n				parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',\r\n\r\n				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n				//_this._glExtensionFragDepth ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n				'uniform mat4 viewMatrix;',\r\n				'uniform vec3 cameraPosition;',\r\n				''\r\n\r\n			].join( '\\n' );\r\n\r\n		}\r\n\r\n		var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );\r\n		var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );\r\n\r\n		_gl.attachShader( program, glVertexShader );\r\n		_gl.attachShader( program, glFragmentShader );\r\n\r\n		if ( index0AttributeName !== undefined ) {\r\n\r\n			// Force a particular attribute to index 0.\r\n			// because potentially expensive emulation is done by browser if attribute 0 is disabled.\r\n			// And, color, for example is often automatically bound to index 0 so disabling it\r\n\r\n			_gl.bindAttribLocation( program, 0, index0AttributeName );\r\n\r\n		}\r\n\r\n		_gl.linkProgram( program );\r\n\r\n		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {\r\n\r\n			console.error( 'THREE.WebGLProgram: Could not initialise shader.' );\r\n			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );\r\n			console.error( 'gl.getError()', _gl.getError() );\r\n\r\n		}\r\n\r\n		if ( _gl.getProgramInfoLog( program ) !== '' ) {\r\n\r\n			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );\r\n			// console.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n			// console.warn( _gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n		}\r\n\r\n		// clean up\r\n\r\n		_gl.deleteShader( glVertexShader );\r\n		_gl.deleteShader( glFragmentShader );\r\n\r\n		// cache uniform locations\r\n\r\n		var identifiers = [\r\n\r\n			'viewMatrix',\r\n			'modelViewMatrix',\r\n			'projectionMatrix',\r\n			'normalMatrix',\r\n			'modelMatrix',\r\n			'cameraPosition',\r\n			'morphTargetInfluences',\r\n			'bindMatrix',\r\n			'bindMatrixInverse'\r\n\r\n		];\r\n\r\n		if ( parameters.useVertexTexture ) {\r\n\r\n			identifiers.push( 'boneTexture' );\r\n			identifiers.push( 'boneTextureWidth' );\r\n			identifiers.push( 'boneTextureHeight' );\r\n\r\n		} else {\r\n\r\n			identifiers.push( 'boneGlobalMatrices' );\r\n\r\n		}\r\n\r\n		if ( parameters.logarithmicDepthBuffer ) {\r\n\r\n			identifiers.push('logDepthBufFC');\r\n\r\n		}\r\n\r\n\r\n		for ( var u in uniforms ) {\r\n\r\n			identifiers.push( u );\r\n\r\n		}\r\n\r\n		this.uniforms = cacheUniformLocations( _gl, program, identifiers );\r\n\r\n		// cache attributes locations\r\n\r\n		identifiers = [\r\n\r\n			'position',\r\n			'normal',\r\n			'uv',\r\n			'uv2',\r\n			'tangent',\r\n			'color',\r\n			'skinIndex',\r\n			'skinWeight',\r\n			'lineDistance'\r\n\r\n		];\r\n\r\n		for ( var i = 0; i < parameters.maxMorphTargets; i ++ ) {\r\n\r\n			identifiers.push( 'morphTarget' + i );\r\n\r\n		}\r\n\r\n		for ( var i = 0; i < parameters.maxMorphNormals; i ++ ) {\r\n\r\n			identifiers.push( 'morphNormal' + i );\r\n\r\n		}\r\n\r\n		for ( var a in attributes ) {\r\n\r\n			identifiers.push( a );\r\n\r\n		}\r\n\r\n		this.attributes = cacheAttributeLocations( _gl, program, identifiers );\r\n		this.attributesKeys = Object.keys( this.attributes );\r\n\r\n		//\r\n\r\n		this.id = programIdCount ++;\r\n		this.code = code;\r\n		this.usedTimes = 1;\r\n		this.program = program;\r\n		this.vertexShader = glVertexShader;\r\n		this.fragmentShader = glFragmentShader;\r\n\r\n		return this;\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n	var addLineNumbers = function ( string ) {\r\n\r\n		var lines = string.split( '\\n' );\r\n\r\n		for ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n		}\r\n\r\n		return lines.join( '\\n' );\r\n\r\n	};\r\n\r\n	return function ( gl, type, string ) {\r\n\r\n		var shader = gl.createShader( type ); \r\n\r\n		gl.shaderSource( shader, string );\r\n		gl.compileShader( shader );\r\n\r\n		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n			console.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n		}\r\n\r\n		if ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', gl.getShaderInfoLog( shader ) );\r\n			console.warn( addLineNumbers( string ) );\r\n\r\n		}\r\n\r\n		// --enable-privileged-webgl-extension\r\n		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n		return shader;\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n	var gl = renderer.context;\r\n\r\n	var vertexBuffer, elementBuffer;\r\n	var program, attributes, uniforms;\r\n	var hasVertexTexture;\r\n\r\n	var tempTexture, occlusionTexture;\r\n\r\n	var init = function () {\r\n\r\n		var vertices = new Float32Array( [\r\n			-1, -1,  0, 0,\r\n			 1, -1,  1, 0,\r\n			 1,  1,  1, 1,\r\n			-1,  1,  0, 1\r\n		] );\r\n\r\n		var faces = new Uint16Array( [\r\n			0, 1, 2,\r\n			0, 2, 3\r\n		] );\r\n\r\n		// buffers\r\n\r\n		vertexBuffer     = gl.createBuffer();\r\n		elementBuffer    = gl.createBuffer();\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n		// textures\r\n\r\n		tempTexture      = gl.createTexture();\r\n		occlusionTexture = gl.createTexture();\r\n\r\n		gl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n		gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n		hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;\r\n\r\n		var shader;\r\n\r\n		if ( hasVertexTexture ) {\r\n\r\n			shader = {\r\n\r\n				vertexShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform vec3 screenPosition;\",\r\n					\"uniform vec2 scale;\",\r\n					\"uniform float rotation;\",\r\n\r\n					\"uniform sampler2D occlusionMap;\",\r\n\r\n					\"attribute vec2 position;\",\r\n					\"attribute vec2 uv;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n					\"varying float vVisibility;\",\r\n\r\n					\"void main() {\",\r\n\r\n						\"vUV = uv;\",\r\n\r\n						\"vec2 pos = position;\",\r\n\r\n						\"if( renderType == 2 ) {\",\r\n\r\n							\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n							\"vVisibility =        visibility.r / 9.0;\",\r\n							\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n							\"vVisibility *=       visibility.b / 9.0;\",\r\n							\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n							\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n							\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n						\"}\",\r\n\r\n						\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" ),\r\n\r\n				fragmentShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform sampler2D map;\",\r\n					\"uniform float opacity;\",\r\n					\"uniform vec3 color;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n					\"varying float vVisibility;\",\r\n\r\n					\"void main() {\",\r\n\r\n						// pink square\r\n\r\n						\"if( renderType == 0 ) {\",\r\n\r\n							\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n						// restore\r\n\r\n						\"} else if( renderType == 1 ) {\",\r\n\r\n							\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n						// flare\r\n\r\n						\"} else {\",\r\n\r\n							\"vec4 texture = texture2D( map, vUV );\",\r\n							\"texture.a *= opacity * vVisibility;\",\r\n							\"gl_FragColor = texture;\",\r\n							\"gl_FragColor.rgb *= color;\",\r\n\r\n						\"}\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" )\r\n\r\n			};\r\n\r\n		} else {\r\n\r\n			shader = {\r\n\r\n				vertexShader: [\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform vec3 screenPosition;\",\r\n					\"uniform vec2 scale;\",\r\n					\"uniform float rotation;\",\r\n\r\n					\"attribute vec2 position;\",\r\n					\"attribute vec2 uv;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n\r\n					\"void main() {\",\r\n\r\n						\"vUV = uv;\",\r\n\r\n						\"vec2 pos = position;\",\r\n\r\n						\"if( renderType == 2 ) {\",\r\n\r\n							\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n							\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n						\"}\",\r\n\r\n						\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" ),\r\n\r\n				fragmentShader: [\r\n\r\n					\"precision mediump float;\",\r\n\r\n					\"uniform lowp int renderType;\",\r\n\r\n					\"uniform sampler2D map;\",\r\n					\"uniform sampler2D occlusionMap;\",\r\n					\"uniform float opacity;\",\r\n					\"uniform vec3 color;\",\r\n\r\n					\"varying vec2 vUV;\",\r\n\r\n					\"void main() {\",\r\n\r\n						// pink square\r\n\r\n						\"if( renderType == 0 ) {\",\r\n\r\n							\"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\",\r\n\r\n						// restore\r\n\r\n						\"} else if( renderType == 1 ) {\",\r\n\r\n							\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n						// flare\r\n\r\n						\"} else {\",\r\n\r\n							\"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\",\r\n							\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\",\r\n							\"visibility = ( 1.0 - visibility / 4.0 );\",\r\n\r\n							\"vec4 texture = texture2D( map, vUV );\",\r\n							\"texture.a *= opacity * visibility;\",\r\n							\"gl_FragColor = texture;\",\r\n							\"gl_FragColor.rgb *= color;\",\r\n\r\n						\"}\",\r\n\r\n					\"}\"\r\n\r\n				].join( \"\\n\" )\r\n\r\n			};\r\n\r\n		}\r\n\r\n		program = createProgram( shader );\r\n\r\n		attributes = {\r\n			vertex: gl.getAttribLocation ( program, \"position\" ),\r\n			uv:     gl.getAttribLocation ( program, \"uv\" )\r\n		}\r\n\r\n		uniforms = {\r\n			renderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n			map:            gl.getUniformLocation( program, \"map\" ),\r\n			occlusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n			opacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n			color:          gl.getUniformLocation( program, \"color\" ),\r\n			scale:          gl.getUniformLocation( program, \"scale\" ),\r\n			rotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n			screenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n		};\r\n\r\n	};\r\n\r\n	/*\r\n	 * Render lens flares\r\n	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n	 *         reads these back and calculates occlusion.\r\n	 */\r\n\r\n	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {\r\n\r\n		if ( flares.length === 0 ) return;\r\n\r\n		var tempPosition = new THREE.Vector3();\r\n\r\n		var invAspect = viewportHeight / viewportWidth,\r\n			halfViewportWidth = viewportWidth * 0.5,\r\n			halfViewportHeight = viewportHeight * 0.5;\r\n\r\n		var size = 16 / viewportHeight,\r\n			scale = new THREE.Vector2( size * invAspect, size );\r\n\r\n		var screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n			screenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n		if ( program === undefined ) {\r\n\r\n			init();\r\n\r\n		}\r\n\r\n		gl.useProgram( program );\r\n\r\n		gl.enableVertexAttribArray( attributes.vertex );\r\n		gl.enableVertexAttribArray( attributes.uv );\r\n\r\n		// loop through all lens flares to update their occlusion and positions\r\n		// setup gl and common used attribs/unforms\r\n\r\n		gl.uniform1i( uniforms.occlusionMap, 0 );\r\n		gl.uniform1i( uniforms.map, 1 );\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n		gl.disable( gl.CULL_FACE );\r\n		gl.depthMask( false );\r\n\r\n		for ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n			size = 16 / viewportHeight;\r\n			scale.set( size * invAspect, size );\r\n\r\n			// calc object screen position\r\n\r\n			var flare = flares[ i ];\r\n			\r\n			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );\r\n\r\n			tempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n			tempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n			// setup arrays for gl programs\r\n\r\n			screenPosition.copy( tempPosition )\r\n\r\n			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;\r\n			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;\r\n\r\n			// screen cull\r\n\r\n			if ( hasVertexTexture || (\r\n				screenPositionPixels.x > 0 &&\r\n				screenPositionPixels.x < viewportWidth &&\r\n				screenPositionPixels.y > 0 &&\r\n				screenPositionPixels.y < viewportHeight ) ) {\r\n\r\n				// save current RGB to temp texture\r\n\r\n				gl.activeTexture( gl.TEXTURE1 );\r\n				gl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n				// render pink quad\r\n\r\n				gl.uniform1i( uniforms.renderType, 0 );\r\n				gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n				gl.disable( gl.BLEND );\r\n				gl.enable( gl.DEPTH_TEST );\r\n\r\n				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n				// copy result to occlusionMap\r\n\r\n				gl.activeTexture( gl.TEXTURE0 );\r\n				gl.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );\r\n\r\n\r\n				// restore graphics\r\n\r\n				gl.uniform1i( uniforms.renderType, 1 );\r\n				gl.disable( gl.DEPTH_TEST );\r\n\r\n				gl.activeTexture( gl.TEXTURE1 );\r\n				gl.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n				// update object positions\r\n\r\n				flare.positionScreen.copy( screenPosition )\r\n\r\n				if ( flare.customUpdateCallback ) {\r\n\r\n					flare.customUpdateCallback( flare );\r\n\r\n				} else {\r\n\r\n					flare.updateLensFlares();\r\n\r\n				}\r\n\r\n				// render flares\r\n\r\n				gl.uniform1i( uniforms.renderType, 2 );\r\n				gl.enable( gl.BLEND );\r\n\r\n				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n					var sprite = flare.lensFlares[ j ];\r\n\r\n					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n						screenPosition.x = sprite.x;\r\n						screenPosition.y = sprite.y;\r\n						screenPosition.z = sprite.z;\r\n\r\n						size = sprite.size * sprite.scale / viewportHeight;\r\n\r\n						scale.x = size * invAspect;\r\n						scale.y = size;\r\n\r\n						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n						gl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n						gl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n						gl.uniform1f( uniforms.opacity, sprite.opacity );\r\n						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n						renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n						renderer.setTexture( sprite.texture, 1 );\r\n\r\n						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore gl\r\n\r\n		gl.enable( gl.CULL_FACE );\r\n		gl.enable( gl.DEPTH_TEST );\r\n		gl.depthMask( true );\r\n\r\n		renderer.resetGLState();\r\n\r\n	};\r\n\r\n	function createProgram ( shader ) {\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n		var vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n		var prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n		gl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n		gl.compileShader( fragmentShader );\r\n		gl.compileShader( vertexShader );\r\n\r\n		gl.attachShader( program, fragmentShader );\r\n		gl.attachShader( program, vertexShader );\r\n\r\n		gl.linkProgram( program );\r\n\r\n		return program;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/ShadowMapPlugin.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ShadowMapPlugin = function ( _renderer, _lights, _webglObjects, _webglObjectsImmediate ) {\r\n\r\n	var _gl = _renderer.context;\r\n\r\n	var _depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,\r\n\r\n	_frustum = new THREE.Frustum(),\r\n	_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n	_min = new THREE.Vector3(),\r\n	_max = new THREE.Vector3(),\r\n\r\n	_matrixPosition = new THREE.Vector3(),\r\n	\r\n	_renderList = [];\r\n\r\n	// init\r\n\r\n	var depthShader = THREE.ShaderLib[ \"depthRGBA\" ];\r\n	var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );\r\n\r\n	_depthMaterial = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader\r\n	 } );\r\n\r\n	_depthMaterialMorph = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader,\r\n		morphTargets: true\r\n	} );\r\n\r\n	_depthMaterialSkin = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader,\r\n		skinning: true\r\n	} );\r\n\r\n	_depthMaterialMorphSkin = new THREE.ShaderMaterial( {\r\n		uniforms: depthUniforms,\r\n		vertexShader: depthShader.vertexShader,\r\n		fragmentShader: depthShader.fragmentShader,\r\n		morphTargets: true,\r\n		skinning: true\r\n	} );\r\n\r\n	_depthMaterial._shadowPass = true;\r\n	_depthMaterialMorph._shadowPass = true;\r\n	_depthMaterialSkin._shadowPass = true;\r\n	_depthMaterialMorphSkin._shadowPass = true;\r\n\r\n	this.render = function ( scene, camera ) {\r\n\r\n		if ( _renderer.shadowMapEnabled === false ) return;\r\n\r\n		var i, il, j, jl, n,\r\n\r\n		shadowMap, shadowMatrix, shadowCamera,\r\n		program, buffer, material,\r\n		webglObject, object, light,\r\n\r\n		lights = [],\r\n		k = 0,\r\n\r\n		fog = null;\r\n\r\n		// set GL state for depth map\r\n\r\n		_gl.clearColor( 1, 1, 1, 1 );\r\n		_gl.disable( _gl.BLEND );\r\n\r\n		_gl.enable( _gl.CULL_FACE );\r\n		_gl.frontFace( _gl.CCW );\r\n\r\n		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n			_gl.cullFace( _gl.FRONT );\r\n\r\n		} else {\r\n\r\n			_gl.cullFace( _gl.BACK );\r\n\r\n		}\r\n\r\n		_renderer.setDepthTest( true );\r\n\r\n		// preprocess lights\r\n		// 	- skip lights that are not casting shadows\r\n		//	- create virtual lights for cascaded shadow maps\r\n\r\n		for ( i = 0, il = _lights.length; i < il; i ++ ) {\r\n\r\n			light = _lights[ i ];\r\n\r\n			if ( ! light.castShadow ) continue;\r\n\r\n			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {\r\n\r\n				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {\r\n\r\n					var virtualLight;\r\n\r\n					if ( ! light.shadowCascadeArray[ n ] ) {\r\n\r\n						virtualLight = createVirtualLight( light, n );\r\n						virtualLight.originalCamera = camera;\r\n\r\n						var gyro = new THREE.Gyroscope();\r\n						gyro.position.copy( light.shadowCascadeOffset );\r\n\r\n						gyro.add( virtualLight );\r\n						gyro.add( virtualLight.target );\r\n\r\n						camera.add( gyro );\r\n\r\n						light.shadowCascadeArray[ n ] = virtualLight;\r\n\r\n						console.log( \"Created virtualLight\", virtualLight );\r\n\r\n					} else {\r\n\r\n						virtualLight = light.shadowCascadeArray[ n ];\r\n\r\n					}\r\n\r\n					updateVirtualLight( light, n );\r\n\r\n					lights[ k ] = virtualLight;\r\n					k ++;\r\n\r\n				}\r\n\r\n			} else {\r\n\r\n				lights[ k ] = light;\r\n				k ++;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// render depth map\r\n\r\n		for ( i = 0, il = lights.length; i < il; i ++ ) {\r\n\r\n			light = lights[ i ];\r\n\r\n			if ( ! light.shadowMap ) {\r\n\r\n				var shadowFilter = THREE.LinearFilter;\r\n\r\n				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n					shadowFilter = THREE.NearestFilter;\r\n\r\n				}\r\n\r\n				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };\r\n\r\n				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );\r\n				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );\r\n\r\n				light.shadowMatrix = new THREE.Matrix4();\r\n\r\n			}\r\n\r\n			if ( ! light.shadowCamera ) {\r\n\r\n				if ( light instanceof THREE.SpotLight ) {\r\n\r\n					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n				} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );\r\n\r\n				} else {\r\n\r\n					console.error( \"Unsupported light type for shadow\" );\r\n					continue;\r\n\r\n				}\r\n\r\n				scene.add( light.shadowCamera );\r\n\r\n				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n			}\r\n\r\n			if ( light.shadowCameraVisible && ! light.cameraHelper ) {\r\n\r\n				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );\r\n				scene.add( light.cameraHelper );\r\n\r\n			}\r\n\r\n			if ( light.isVirtual && virtualLight.originalCamera == camera ) {\r\n\r\n				updateShadowCamera( camera, light );\r\n\r\n			}\r\n\r\n			shadowMap = light.shadowMap;\r\n			shadowMatrix = light.shadowMatrix;\r\n			shadowCamera = light.shadowCamera;\r\n\r\n			//\r\n\r\n			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );\r\n			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );\r\n			shadowCamera.lookAt( _matrixPosition );\r\n			shadowCamera.updateMatrixWorld();\r\n\r\n			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n			//\r\n\r\n			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;\r\n			if ( light.shadowCameraVisible ) light.cameraHelper.update();\r\n\r\n			// compute shadow matrix\r\n\r\n			shadowMatrix.set(\r\n				0.5, 0.0, 0.0, 0.5,\r\n				0.0, 0.5, 0.0, 0.5,\r\n				0.0, 0.0, 0.5, 0.5,\r\n				0.0, 0.0, 0.0, 1.0\r\n			);\r\n\r\n			shadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n			// update camera matrices and frustum\r\n\r\n			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n			_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n			// render shadow map\r\n\r\n			_renderer.setRenderTarget( shadowMap );\r\n			_renderer.clear();\r\n\r\n			// set object matrices & frustum culling\r\n\r\n			_renderList.length = 0;\r\n\r\n			projectObject( scene, scene, shadowCamera );\r\n\r\n\r\n			// render regular objects\r\n\r\n			var objectMaterial, useMorphing, useSkinning;\r\n\r\n			for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n				webglObject = _renderList[ j ];\r\n\r\n				object = webglObject.object;\r\n				buffer = webglObject.buffer;\r\n\r\n				// culling is overriden globally for all objects\r\n				// while rendering depth map\r\n\r\n				// need to deal with MeshFaceMaterial somehow\r\n				// in that case just use the first of material.materials for now\r\n				// (proper solution would require to break objects by materials\r\n				//  similarly to regular rendering and then set corresponding\r\n				//  depth materials per each chunk instead of just once per object)\r\n\r\n				objectMaterial = getObjectMaterial( object );\r\n\r\n				useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;\r\n				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;\r\n\r\n				if ( object.customDepthMaterial ) {\r\n\r\n					material = object.customDepthMaterial;\r\n\r\n				} else if ( useSkinning ) {\r\n\r\n					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;\r\n\r\n				} else if ( useMorphing ) {\r\n\r\n					material = _depthMaterialMorph;\r\n\r\n				} else {\r\n\r\n					material = _depthMaterial;\r\n\r\n				}\r\n\r\n				_renderer.setMaterialFaces( objectMaterial );\r\n\r\n				if ( buffer instanceof THREE.BufferGeometry ) {\r\n\r\n					_renderer.renderBufferDirect( shadowCamera, _lights, fog, material, buffer, object );\r\n\r\n				} else {\r\n\r\n					_renderer.renderBuffer( shadowCamera, _lights, fog, material, buffer, object );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// set matrices and render immediate objects\r\n\r\n			for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {\r\n\r\n				webglObject = _webglObjectsImmediate[ j ];\r\n				object = webglObject.object;\r\n\r\n				if ( object.visible && object.castShadow ) {\r\n\r\n					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\r\n					_renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// restore GL state\r\n\r\n		var clearColor = _renderer.getClearColor(),\r\n		clearAlpha = _renderer.getClearAlpha();\r\n\r\n		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );\r\n		_gl.enable( _gl.BLEND );\r\n\r\n		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {\r\n\r\n			_gl.cullFace( _gl.BACK );\r\n\r\n		}\r\n\r\n		_renderer.resetGLState();\r\n\r\n	};\r\n\r\n	function projectObject( scene, object, shadowCamera ){\r\n\r\n		if ( object.visible ) {\r\n\r\n			var webglObjects = _webglObjects[ object.id ];\r\n\r\n			if ( webglObjects && object.castShadow && (object.frustumCulled === false || _frustum.intersectsObject( object ) === true) ) {\r\n\r\n				for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {\r\n\r\n					var webglObject = webglObjects[ i ];\r\n\r\n					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n					_renderList.push( webglObject );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			for ( var i = 0, l = object.children.length; i < l; i ++ ) {\r\n\r\n				projectObject( scene, object.children[ i ], shadowCamera );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function createVirtualLight( light, cascade ) {\r\n\r\n		var virtualLight = new THREE.DirectionalLight();\r\n\r\n		virtualLight.isVirtual = true;\r\n\r\n		virtualLight.onlyShadow = true;\r\n		virtualLight.castShadow = true;\r\n\r\n		virtualLight.shadowCameraNear = light.shadowCameraNear;\r\n		virtualLight.shadowCameraFar = light.shadowCameraFar;\r\n\r\n		virtualLight.shadowCameraLeft = light.shadowCameraLeft;\r\n		virtualLight.shadowCameraRight = light.shadowCameraRight;\r\n		virtualLight.shadowCameraBottom = light.shadowCameraBottom;\r\n		virtualLight.shadowCameraTop = light.shadowCameraTop;\r\n\r\n		virtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n\r\n		virtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];\r\n		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];\r\n\r\n		virtualLight.pointsWorld = [];\r\n		virtualLight.pointsFrustum = [];\r\n\r\n		var pointsWorld = virtualLight.pointsWorld,\r\n			pointsFrustum = virtualLight.pointsFrustum;\r\n\r\n		for ( var i = 0; i < 8; i ++ ) {\r\n\r\n			pointsWorld[ i ] = new THREE.Vector3();\r\n			pointsFrustum[ i ] = new THREE.Vector3();\r\n\r\n		}\r\n\r\n		var nearZ = light.shadowCascadeNearZ[ cascade ];\r\n		var farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n		pointsFrustum[ 0 ].set( - 1, - 1, nearZ );\r\n		pointsFrustum[ 1 ].set(  1, - 1, nearZ );\r\n		pointsFrustum[ 2 ].set( - 1,  1, nearZ );\r\n		pointsFrustum[ 3 ].set(  1,  1, nearZ );\r\n\r\n		pointsFrustum[ 4 ].set( - 1, - 1, farZ );\r\n		pointsFrustum[ 5 ].set(  1, - 1, farZ );\r\n		pointsFrustum[ 6 ].set( - 1,  1, farZ );\r\n		pointsFrustum[ 7 ].set(  1,  1, farZ );\r\n\r\n		return virtualLight;\r\n\r\n	}\r\n\r\n	// Synchronize virtual light with the original light\r\n\r\n	function updateVirtualLight( light, cascade ) {\r\n\r\n		var virtualLight = light.shadowCascadeArray[ cascade ];\r\n\r\n		virtualLight.position.copy( light.position );\r\n		virtualLight.target.position.copy( light.target.position );\r\n		virtualLight.lookAt( virtualLight.target );\r\n\r\n		virtualLight.shadowCameraVisible = light.shadowCameraVisible;\r\n		virtualLight.shadowDarkness = light.shadowDarkness;\r\n\r\n		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];\r\n\r\n		var nearZ = light.shadowCascadeNearZ[ cascade ];\r\n		var farZ = light.shadowCascadeFarZ[ cascade ];\r\n\r\n		var pointsFrustum = virtualLight.pointsFrustum;\r\n\r\n		pointsFrustum[ 0 ].z = nearZ;\r\n		pointsFrustum[ 1 ].z = nearZ;\r\n		pointsFrustum[ 2 ].z = nearZ;\r\n		pointsFrustum[ 3 ].z = nearZ;\r\n\r\n		pointsFrustum[ 4 ].z = farZ;\r\n		pointsFrustum[ 5 ].z = farZ;\r\n		pointsFrustum[ 6 ].z = farZ;\r\n		pointsFrustum[ 7 ].z = farZ;\r\n\r\n	}\r\n\r\n	// Fit shadow camera's ortho frustum to camera frustum\r\n\r\n	function updateShadowCamera( camera, light ) {\r\n\r\n		var shadowCamera = light.shadowCamera,\r\n			pointsFrustum = light.pointsFrustum,\r\n			pointsWorld = light.pointsWorld;\r\n\r\n		_min.set( Infinity, Infinity, Infinity );\r\n		_max.set( - Infinity, - Infinity, - Infinity );\r\n\r\n		for ( var i = 0; i < 8; i ++ ) {\r\n\r\n			var p = pointsWorld[ i ];\r\n\r\n			p.copy( pointsFrustum[ i ] );\r\n			p.unproject( camera );\r\n\r\n			p.applyMatrix4( shadowCamera.matrixWorldInverse );\r\n\r\n			if ( p.x < _min.x ) _min.x = p.x;\r\n			if ( p.x > _max.x ) _max.x = p.x;\r\n\r\n			if ( p.y < _min.y ) _min.y = p.y;\r\n			if ( p.y > _max.y ) _max.y = p.y;\r\n\r\n			if ( p.z < _min.z ) _min.z = p.z;\r\n			if ( p.z > _max.z ) _max.z = p.z;\r\n\r\n		}\r\n\r\n		shadowCamera.left = _min.x;\r\n		shadowCamera.right = _max.x;\r\n		shadowCamera.top = _max.y;\r\n		shadowCamera.bottom = _min.y;\r\n\r\n		// can't really fit near/far\r\n		//shadowCamera.near = _min.z;\r\n		//shadowCamera.far = _max.z;\r\n\r\n		shadowCamera.updateProjectionMatrix();\r\n\r\n	}\r\n\r\n	// For the moment just ignore objects that have multiple materials with different animation methods\r\n	// Only the first material will be taken into account for deciding which depth material to use for shadow maps\r\n\r\n	function getObjectMaterial( object ) {\r\n\r\n		return object.material instanceof THREE.MeshFaceMaterial\r\n			? object.material.materials[ 0 ]\r\n			: object.material;\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n	var gl = renderer.context;\r\n\r\n	var vertexBuffer, elementBuffer;\r\n	var program, attributes, uniforms;\r\n\r\n	var texture;\r\n\r\n	// decompose matrixWorld\r\n\r\n	var spritePosition = new THREE.Vector3();\r\n	var spriteRotation = new THREE.Quaternion();\r\n	var spriteScale = new THREE.Vector3();\r\n\r\n	var init = function () {\r\n\r\n		var vertices = new Float32Array( [\r\n			- 0.5, - 0.5,  0, 0,\r\n			  0.5, - 0.5,  1, 0,\r\n			  0.5,   0.5,  1, 1,\r\n			- 0.5,   0.5,  0, 1\r\n		] );\r\n\r\n		var faces = new Uint16Array( [\r\n			0, 1, 2,\r\n			0, 2, 3\r\n		] );\r\n\r\n		vertexBuffer  = gl.createBuffer();\r\n		elementBuffer = gl.createBuffer();\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n		program = createProgram();\r\n\r\n		attributes = {\r\n			position:			gl.getAttribLocation ( program, 'position' ),\r\n			uv:					gl.getAttribLocation ( program, 'uv' )\r\n		};\r\n\r\n		uniforms = {\r\n			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),\r\n			uvScale:			gl.getUniformLocation( program, 'uvScale' ),\r\n\r\n			rotation:			gl.getUniformLocation( program, 'rotation' ),\r\n			scale:				gl.getUniformLocation( program, 'scale' ),\r\n\r\n			color:				gl.getUniformLocation( program, 'color' ),\r\n			map:				gl.getUniformLocation( program, 'map' ),\r\n			opacity:			gl.getUniformLocation( program, 'opacity' ),\r\n\r\n			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),\r\n			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n			fogType:			gl.getUniformLocation( program, 'fogType' ),\r\n			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),\r\n			fogNear:			gl.getUniformLocation( program, 'fogNear' ),\r\n			fogFar:				gl.getUniformLocation( program, 'fogFar' ),\r\n			fogColor:			gl.getUniformLocation( program, 'fogColor' ),\r\n\r\n			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )\r\n		};\r\n\r\n		var canvas = document.createElement( 'canvas' );\r\n		canvas.width = 8;\r\n		canvas.height = 8;\r\n\r\n		var context = canvas.getContext( '2d' );\r\n		context.fillStyle = 'white';\r\n		context.fillRect( 0, 0, 8, 8 );\r\n\r\n		texture = new THREE.Texture( canvas );\r\n		texture.needsUpdate = true;\r\n\r\n	};\r\n\r\n	this.render = function ( scene, camera ) {\r\n\r\n		if ( sprites.length === 0 ) return;\r\n\r\n		// setup gl\r\n\r\n		if ( program === undefined ) {\r\n\r\n			init();\r\n\r\n		}\r\n\r\n		gl.useProgram( program );\r\n\r\n		gl.enableVertexAttribArray( attributes.position );\r\n		gl.enableVertexAttribArray( attributes.uv );\r\n\r\n		gl.disable( gl.CULL_FACE );\r\n		gl.enable( gl.BLEND );\r\n\r\n		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n		gl.activeTexture( gl.TEXTURE0 );\r\n		gl.uniform1i( uniforms.map, 0 );\r\n\r\n		var oldFogType = 0;\r\n		var sceneFogType = 0;\r\n		var fog = scene.fog;\r\n\r\n		if ( fog ) {\r\n\r\n			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n			if ( fog instanceof THREE.Fog ) {\r\n\r\n				gl.uniform1f( uniforms.fogNear, fog.near );\r\n				gl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n				gl.uniform1i( uniforms.fogType, 1 );\r\n				oldFogType = 1;\r\n				sceneFogType = 1;\r\n\r\n			} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n				gl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n				gl.uniform1i( uniforms.fogType, 2 );\r\n				oldFogType = 2;\r\n				sceneFogType = 2;\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			gl.uniform1i( uniforms.fogType, 0 );\r\n			oldFogType = 0;\r\n			sceneFogType = 0;\r\n\r\n		}\r\n\r\n\r\n		// update positions and sort\r\n\r\n		for ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n			var sprite = sprites[ i ];\r\n\r\n			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n			sprite.z = - sprite._modelViewMatrix.elements[ 14 ];\r\n\r\n		}\r\n\r\n		sprites.sort( painterSortStable );\r\n\r\n		// render all sprites\r\n\r\n		var scale = [];\r\n\r\n		for ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n			var sprite = sprites[ i ];\r\n			var material = sprite.material;\r\n\r\n			gl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );\r\n\r\n			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n			scale[ 0 ] = spriteScale.x;\r\n			scale[ 1 ] = spriteScale.y;\r\n\r\n			var fogType = 0;\r\n\r\n			if ( scene.fog && material.fog ) {\r\n\r\n				fogType = sceneFogType;\r\n\r\n			}\r\n\r\n			if ( oldFogType !== fogType ) {\r\n\r\n				gl.uniform1i( uniforms.fogType, fogType );\r\n				oldFogType = fogType;\r\n\r\n			}\r\n\r\n			if ( material.map !== null ) {\r\n\r\n				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n			} else {\r\n\r\n				gl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n				gl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n			}\r\n\r\n			gl.uniform1f( uniforms.opacity, material.opacity );\r\n			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n			gl.uniform1f( uniforms.rotation, material.rotation );\r\n			gl.uniform2fv( uniforms.scale, scale );\r\n\r\n			renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n			renderer.setDepthTest( material.depthTest );\r\n			renderer.setDepthWrite( material.depthWrite );\r\n\r\n			if ( material.map && material.map.image && material.map.image.width ) {\r\n\r\n				renderer.setTexture( material.map, 0 );\r\n\r\n			} else {\r\n\r\n				renderer.setTexture( texture, 0 );\r\n\r\n			}\r\n\r\n			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n		}\r\n\r\n		// restore gl\r\n\r\n		gl.enable( gl.CULL_FACE );\r\n\r\n		renderer.resetGLState();\r\n\r\n	};\r\n\r\n	function createProgram () {\r\n\r\n		var program = gl.createProgram();\r\n\r\n		var vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n		gl.shaderSource( vertexShader, [\r\n\r\n			'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n			'uniform mat4 modelViewMatrix;',\r\n			'uniform mat4 projectionMatrix;',\r\n			'uniform float rotation;',\r\n			'uniform vec2 scale;',\r\n			'uniform vec2 uvOffset;',\r\n			'uniform vec2 uvScale;',\r\n\r\n			'attribute vec2 position;',\r\n			'attribute vec2 uv;',\r\n\r\n			'varying vec2 vUV;',\r\n\r\n			'void main() {',\r\n\r\n				'vUV = uvOffset + uv * uvScale;',\r\n\r\n				'vec2 alignedPosition = position * scale;',\r\n\r\n				'vec2 rotatedPosition;',\r\n				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n				'vec4 finalPosition;',\r\n\r\n				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n				'finalPosition.xy += rotatedPosition;',\r\n				'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n				'gl_Position = finalPosition;',\r\n\r\n			'}'\r\n\r\n		].join( '\\n' ) );\r\n\r\n		gl.shaderSource( fragmentShader, [\r\n\r\n			'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n			'uniform vec3 color;',\r\n			'uniform sampler2D map;',\r\n			'uniform float opacity;',\r\n\r\n			'uniform int fogType;',\r\n			'uniform vec3 fogColor;',\r\n			'uniform float fogDensity;',\r\n			'uniform float fogNear;',\r\n			'uniform float fogFar;',\r\n			'uniform float alphaTest;',\r\n\r\n			'varying vec2 vUV;',\r\n\r\n			'void main() {',\r\n\r\n				'vec4 texture = texture2D( map, vUV );',\r\n\r\n				'if ( texture.a < alphaTest ) discard;',\r\n\r\n				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n				'if ( fogType > 0 ) {',\r\n\r\n					'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n					'float fogFactor = 0.0;',\r\n\r\n					'if ( fogType == 1 ) {',\r\n\r\n						'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n					'} else {',\r\n\r\n						'const float LOG2 = 1.442695;',\r\n						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n					'}',\r\n\r\n					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n				'}',\r\n\r\n			'}'\r\n\r\n		].join( '\\n' ) );\r\n\r\n		gl.compileShader( vertexShader );\r\n		gl.compileShader( fragmentShader );\r\n\r\n		gl.attachShader( program, vertexShader );\r\n		gl.attachShader( program, fragmentShader );\r\n\r\n		gl.linkProgram( program );\r\n\r\n		return program;\r\n\r\n	};\r\n\r\n	function painterSortStable ( a, b ) {\r\n\r\n		if ( a.z !== b.z ) {\r\n\r\n			return b.z - a.z;\r\n\r\n		} else {\r\n\r\n			return b.id - a.id;\r\n\r\n		}\r\n\r\n	};\r\n\r\n};\r\n\r\n// File:src/extras/GeometryUtils.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n	merge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n		var matrix;\r\n\r\n		if ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n			geometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n			matrix = geometry2.matrix;\r\n			geometry2 = geometry2.geometry;\r\n\r\n		}\r\n\r\n		geometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n	},\r\n\r\n	center: function ( geometry ) {\r\n\r\n		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n		return geometry.center();\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/ImageUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Daosheng Mu / https://github.com/DaoshengMu/\r\n */\r\n\r\nTHREE.ImageUtils = {\r\n\r\n	crossOrigin: undefined,\r\n\r\n	loadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n		var loader = new THREE.ImageLoader();\r\n		loader.crossOrigin = this.crossOrigin;\r\n\r\n		var texture = new THREE.Texture( undefined, mapping );\r\n\r\n		loader.load( url, function ( image ) {\r\n\r\n			texture.image = image;\r\n			texture.needsUpdate = true;\r\n\r\n			if ( onLoad ) onLoad( texture );\r\n\r\n		}, undefined, function ( event ) {\r\n\r\n			if ( onError ) onError( event );\r\n\r\n		} );\r\n\r\n		texture.sourceFile = url;\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	loadTextureCube: function ( array, mapping, onLoad, onError ) {\r\n\r\n		var images = [];\r\n\r\n		var loader = new THREE.ImageLoader();\r\n		loader.crossOrigin = this.crossOrigin;\r\n\r\n		var texture = new THREE.CubeTexture( images, mapping );\r\n\r\n		// no flipping needed for cube textures\r\n\r\n		texture.flipY = false;\r\n\r\n		var loaded = 0;\r\n\r\n		var loadTexture = function ( i ) {\r\n\r\n			loader.load( array[ i ], function ( image ) {\r\n\r\n				texture.images[ i ] = image;\r\n\r\n				loaded += 1;\r\n\r\n				if ( loaded === 6 ) {\r\n\r\n					texture.needsUpdate = true;\r\n\r\n					if ( onLoad ) onLoad( texture );\r\n\r\n				}\r\n\r\n			}, undefined, onError );\r\n\r\n		}\r\n\r\n		for ( var i = 0, il = array.length; i < il; ++ i ) {\r\n\r\n			loadTexture( i );\r\n\r\n		}\r\n\r\n		return texture;\r\n\r\n	},\r\n\r\n	loadCompressedTexture: function () {\r\n\r\n		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n	},\r\n\r\n	loadCompressedTextureCube: function () {\r\n\r\n		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )\r\n\r\n	},\r\n\r\n	getNormalMap: function ( image, depth ) {\r\n\r\n		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/\r\n\r\n		var cross = function ( a, b ) {\r\n\r\n			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];\r\n\r\n		}\r\n\r\n		var subtract = function ( a, b ) {\r\n\r\n			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];\r\n\r\n		}\r\n\r\n		var normalize = function ( a ) {\r\n\r\n			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\r\n			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];\r\n\r\n		}\r\n\r\n		depth = depth | 1;\r\n\r\n		var width = image.width;\r\n		var height = image.height;\r\n\r\n		var canvas = document.createElement( 'canvas' );\r\n		canvas.width = width;\r\n		canvas.height = height;\r\n\r\n		var context = canvas.getContext( '2d' );\r\n		context.drawImage( image, 0, 0 );\r\n\r\n		var data = context.getImageData( 0, 0, width, height ).data;\r\n		var imageData = context.createImageData( width, height );\r\n		var output = imageData.data;\r\n\r\n		for ( var x = 0; x < width; x ++ ) {\r\n\r\n			for ( var y = 0; y < height; y ++ ) {\r\n\r\n				var ly = y - 1 < 0 ? 0 : y - 1;\r\n				var uy = y + 1 > height - 1 ? height - 1 : y + 1;\r\n				var lx = x - 1 < 0 ? 0 : x - 1;\r\n				var ux = x + 1 > width - 1 ? width - 1 : x + 1;\r\n\r\n				var points = [];\r\n				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];\r\n				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );\r\n				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );\r\n				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );\r\n				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );\r\n				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );\r\n\r\n				var normals = [];\r\n				var num_points = points.length;\r\n\r\n				for ( var i = 0; i < num_points; i ++ ) {\r\n\r\n					var v1 = points[ i ];\r\n					var v2 = points[ ( i + 1 ) % num_points ];\r\n					v1 = subtract( v1, origin );\r\n					v2 = subtract( v2, origin );\r\n					normals.push( normalize( cross( v1, v2 ) ) );\r\n\r\n				}\r\n\r\n				var normal = [ 0, 0, 0 ];\r\n\r\n				for ( var i = 0; i < normals.length; i ++ ) {\r\n\r\n					normal[ 0 ] += normals[ i ][ 0 ];\r\n					normal[ 1 ] += normals[ i ][ 1 ];\r\n					normal[ 2 ] += normals[ i ][ 2 ];\r\n\r\n				}\r\n\r\n				normal[ 0 ] /= normals.length;\r\n				normal[ 1 ] /= normals.length;\r\n				normal[ 2 ] /= normals.length;\r\n\r\n				var idx = ( y * width + x ) * 4;\r\n\r\n				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;\r\n				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;\r\n				output[ idx + 3 ] = 255;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		context.putImageData( imageData, 0, 0 );\r\n\r\n		return canvas;\r\n\r\n	},\r\n\r\n	generateDataTexture: function ( width, height, color ) {\r\n\r\n		var size = width * height;\r\n		var data = new Uint8Array( 3 * size );\r\n\r\n		var r = Math.floor( color.r * 255 );\r\n		var g = Math.floor( color.g * 255 );\r\n		var b = Math.floor( color.b * 255 );\r\n\r\n		for ( var i = 0; i < size; i ++ ) {\r\n\r\n			data[ i * 3 ] 	   = r;\r\n			data[ i * 3 + 1 ] = g;\r\n			data[ i * 3 + 2 ] = b;\r\n\r\n		}\r\n\r\n		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );\r\n		texture.needsUpdate = true;\r\n\r\n		return texture;\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n	createMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n		var group = new THREE.Object3D();\r\n\r\n		for ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n			group.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n		}\r\n\r\n		return group;\r\n\r\n	},\r\n\r\n	detach: function ( child, parent, scene ) {\r\n\r\n		child.applyMatrix( parent.matrixWorld );\r\n		parent.remove( child );\r\n		scene.add( child );\r\n\r\n	},\r\n\r\n	attach: function ( child, scene, parent ) {\r\n\r\n		var matrixWorldInverse = new THREE.Matrix4();\r\n		matrixWorldInverse.getInverse( parent.matrixWorld );\r\n		child.applyMatrix( matrixWorldInverse );\r\n\r\n		scene.remove( child );\r\n		parent.add( child );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/FontUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For Text operations in three.js (See TextGeometry)\r\n *\r\n * It uses techniques used in:\r\n *\r\n * 	typeface.js and canvastext\r\n * 		For converting fonts and rendering with javascript\r\n *		http://typeface.neocracy.org\r\n *\r\n *	Triangulation ported from AS3\r\n *		Simple Polygon Triangulation\r\n *		http://actionsnippet.com/?p=1462\r\n *\r\n * 	A Method to triangulate shapes with holes\r\n *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/\r\n *\r\n */\r\n\r\nTHREE.FontUtils = {\r\n\r\n	faces: {},\r\n\r\n	// Just for now. face[weight][style]\r\n\r\n	face: 'helvetiker',\r\n	weight: 'normal',\r\n	style: 'normal',\r\n	size: 150,\r\n	divisions: 10,\r\n\r\n	getFace: function () {\r\n\r\n		try {\r\n\r\n			return this.faces[ this.face ][ this.weight ][ this.style ];\r\n\r\n		} catch (e) {\r\n\r\n			throw \"The font \" + this.face + \" with \" + this.weight + \" weight and \" + this.style + \" style is missing.\"\r\n\r\n		};\r\n\r\n	},\r\n\r\n	loadFace: function ( data ) {\r\n\r\n		var family = data.familyName.toLowerCase();\r\n\r\n		var ThreeFont = this;\r\n\r\n		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};\r\n\r\n		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};\r\n		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	drawText: function ( text ) {\r\n\r\n		var characterPts = [], allPts = [];\r\n\r\n		// RenderText\r\n\r\n		var i, p,\r\n			face = this.getFace(),\r\n			scale = this.size / face.resolution,\r\n			offset = 0,\r\n			chars = String( text ).split( '' ),\r\n			length = chars.length;\r\n\r\n		var fontPaths = [];\r\n\r\n		for ( i = 0; i < length; i ++ ) {\r\n\r\n			var path = new THREE.Path();\r\n\r\n			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );\r\n			offset += ret.offset;\r\n\r\n			fontPaths.push( ret.path );\r\n\r\n		}\r\n\r\n		// get the width\r\n\r\n		var width = offset / 2;\r\n		//\r\n		// for ( p = 0; p < allPts.length; p++ ) {\r\n		//\r\n		// 	allPts[ p ].x -= width;\r\n		//\r\n		// }\r\n\r\n		//var extract = this.extractPoints( allPts, characterPts );\r\n		//extract.contour = allPts;\r\n\r\n		//extract.paths = fontPaths;\r\n		//extract.offset = width;\r\n\r\n		return { paths: fontPaths, offset: width };\r\n\r\n	},\r\n\r\n\r\n\r\n\r\n	extractGlyphPoints: function ( c, face, scale, offset, path ) {\r\n\r\n		var pts = [];\r\n\r\n		var i, i2, divisions,\r\n			outline, action, length,\r\n			scaleX, scaleY,\r\n			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,\r\n			laste,\r\n			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];\r\n\r\n		if ( ! glyph ) return;\r\n\r\n		if ( glyph.o ) {\r\n\r\n			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n			length = outline.length;\r\n\r\n			scaleX = scale;\r\n			scaleY = scale;\r\n\r\n			for ( i = 0; i < length; ) {\r\n\r\n				action = outline[ i ++ ];\r\n\r\n				//console.log( action );\r\n\r\n				switch ( action ) {\r\n\r\n				case 'm':\r\n\r\n					// Move To\r\n\r\n					x = outline[ i ++ ] * scaleX + offset;\r\n					y = outline[ i ++ ] * scaleY;\r\n\r\n					path.moveTo( x, y );\r\n					break;\r\n\r\n				case 'l':\r\n\r\n					// Line To\r\n\r\n					x = outline[ i ++ ] * scaleX + offset;\r\n					y = outline[ i ++ ] * scaleY;\r\n					path.lineTo( x,y );\r\n					break;\r\n\r\n				case 'q':\r\n\r\n					// QuadraticCurveTo\r\n\r\n					cpx  = outline[ i ++ ] * scaleX + offset;\r\n					cpy  = outline[ i ++ ] * scaleY;\r\n					cpx1 = outline[ i ++ ] * scaleX + offset;\r\n					cpy1 = outline[ i ++ ] * scaleY;\r\n\r\n					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n					laste = pts[ pts.length - 1 ];\r\n\r\n					if ( laste ) {\r\n\r\n						cpx0 = laste.x;\r\n						cpy0 = laste.y;\r\n\r\n						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n							var t = i2 / divisions;\r\n							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n					  }\r\n\r\n				  }\r\n\r\n				  break;\r\n\r\n				case 'b':\r\n\r\n					// Cubic Bezier Curve\r\n\r\n					cpx  = outline[ i ++ ] *  scaleX + offset;\r\n					cpy  = outline[ i ++ ] *  scaleY;\r\n					cpx1 = outline[ i ++ ] *  scaleX + offset;\r\n					cpy1 = outline[ i ++ ] *  scaleY;\r\n					cpx2 = outline[ i ++ ] *  scaleX + offset;\r\n					cpy2 = outline[ i ++ ] *  scaleY;\r\n\r\n					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n					laste = pts[ pts.length - 1 ];\r\n\r\n					if ( laste ) {\r\n\r\n						cpx0 = laste.x;\r\n						cpy0 = laste.y;\r\n\r\n						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {\r\n\r\n							var t = i2 / divisions;\r\n							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n						}\r\n\r\n					}\r\n\r\n					break;\r\n\r\n				}\r\n\r\n			}\r\n		}\r\n\r\n\r\n\r\n		return { offset: glyph.ha * scale, path:path };\r\n	}\r\n\r\n};\r\n\r\n\r\nTHREE.FontUtils.generateShapes = function ( text, parameters ) {\r\n\r\n	// Parameters \r\n\r\n	parameters = parameters || {};\r\n\r\n	var size = parameters.size !== undefined ? parameters.size : 100;\r\n	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;\r\n\r\n	var font = parameters.font !== undefined ? parameters.font : 'helvetiker';\r\n	var weight = parameters.weight !== undefined ? parameters.weight : 'normal';\r\n	var style = parameters.style !== undefined ? parameters.style : 'normal';\r\n\r\n	THREE.FontUtils.size = size;\r\n	THREE.FontUtils.divisions = curveSegments;\r\n\r\n	THREE.FontUtils.face = font;\r\n	THREE.FontUtils.weight = weight;\r\n	THREE.FontUtils.style = style;\r\n\r\n	// Get a Font data json object\r\n\r\n	var data = THREE.FontUtils.drawText( text );\r\n\r\n	var paths = data.paths;\r\n	var shapes = [];\r\n\r\n	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n	}\r\n\r\n	return shapes;\r\n\r\n};\r\n\r\n\r\n/**\r\n * This code is a quick port of code written in C++ which was submitted to\r\n * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n * See original code and more information here:\r\n * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n *\r\n * ported to actionscript by Zevan Rosser\r\n * www.actionsnippet.com\r\n *\r\n * ported to javascript by Joshua Koo\r\n * http://www.lab4games.net/zz85/blog\r\n *\r\n */\r\n\r\n\r\n( function ( namespace ) {\r\n\r\n	var EPSILON = 0.0000000001;\r\n\r\n	// takes in an contour array and returns\r\n\r\n	var process = function ( contour, indices ) {\r\n\r\n		var n = contour.length;\r\n\r\n		if ( n < 3 ) return null;\r\n\r\n		var result = [],\r\n			verts = [],\r\n			vertIndices = [];\r\n\r\n		/* we want a counter-clockwise polygon in verts */\r\n\r\n		var u, v, w;\r\n\r\n		if ( area( contour ) > 0.0 ) {\r\n\r\n			for ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n		} else {\r\n\r\n			for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n		}\r\n\r\n		var nv = n;\r\n\r\n		/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n		var count = 2 * nv;   /* error detection */\r\n\r\n		for ( v = nv - 1; nv > 2; ) {\r\n\r\n			/* if we loop, it is probably a non-simple polygon */\r\n\r\n			if ( ( count -- ) <= 0 ) {\r\n\r\n				//** Triangulate: ERROR - probable bad polygon!\r\n\r\n				//throw ( \"Warning, unable to triangulate polygon!\" );\r\n				//return null;\r\n				// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n				console.log( 'Warning, unable to triangulate polygon!' );\r\n\r\n				if ( indices ) return vertIndices;\r\n				return result;\r\n\r\n			}\r\n\r\n			/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */\r\n			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n			if ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n				var a, b, c, s, t;\r\n\r\n				/* true names of the vertices */\r\n\r\n				a = verts[ u ];\r\n				b = verts[ v ];\r\n				c = verts[ w ];\r\n\r\n				/* output Triangle */\r\n\r\n				result.push( [ contour[ a ],\r\n					contour[ b ],\r\n					contour[ c ] ] );\r\n\r\n\r\n				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n				/* remove v from the remaining polygon */\r\n\r\n				for ( s = v, t = v + 1; t < nv; s++, t++ ) {\r\n\r\n					verts[ s ] = verts[ t ];\r\n\r\n				}\r\n\r\n				nv --;\r\n\r\n				/* reset error detection counter */\r\n\r\n				count = 2 * nv;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		if ( indices ) return vertIndices;\r\n		return result;\r\n\r\n	};\r\n\r\n	// calculate area of the contour polygon\r\n\r\n	var area = function ( contour ) {\r\n\r\n		var n = contour.length;\r\n		var a = 0.0;\r\n\r\n		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n		}\r\n\r\n		return a * 0.5;\r\n\r\n	};\r\n\r\n	var snip = function ( contour, u, v, w, n, verts ) {\r\n\r\n		var p;\r\n		var ax, ay, bx, by;\r\n		var cx, cy, px, py;\r\n\r\n		ax = contour[ verts[ u ] ].x;\r\n		ay = contour[ verts[ u ] ].y;\r\n\r\n		bx = contour[ verts[ v ] ].x;\r\n		by = contour[ verts[ v ] ].y;\r\n\r\n		cx = contour[ verts[ w ] ].x;\r\n		cy = contour[ verts[ w ] ].y;\r\n\r\n		if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n		var aX, aY, bX, bY, cX, cY;\r\n		var apx, apy, bpx, bpy, cpx, cpy;\r\n		var cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n		aX = cx - bx;  aY = cy - by;\r\n		bX = ax - cx;  bY = ay - cy;\r\n		cX = bx - ax;  cY = by - ay;\r\n\r\n		for ( p = 0; p < n; p ++ ) {\r\n\r\n			px = contour[ verts[ p ] ].x\r\n			py = contour[ verts[ p ] ].y\r\n\r\n			if ( ( ( px === ax ) && ( py === ay ) ) ||\r\n				 ( ( px === bx ) && ( py === by ) ) ||\r\n				 ( ( px === cx ) && ( py === cy ) ) )	continue;\r\n\r\n			apx = px - ax;  apy = py - ay;\r\n			bpx = px - bx;  bpy = py - by;\r\n			cpx = px - cx;  cpy = py - cy;\r\n\r\n			// see if p is inside triangle abc\r\n\r\n			aCROSSbp = aX * bpy - aY * bpx;\r\n			cCROSSap = cX * apy - cY * apx;\r\n			bCROSScp = bX * cpy - bY * cpx;\r\n\r\n			if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	};\r\n\r\n\r\n	namespace.Triangulate = process;\r\n	namespace.Triangulate.area = area;\r\n\r\n	return namespace;\r\n\r\n} )( THREE.FontUtils );\r\n\r\n// To use the typeface.js face files, hook up the API\r\nself._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };\r\nTHREE.typeface_js = self._typeface_js;\r\n\r\n// File:src/extras/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'Audio';\r\n\r\n	this.context = listener.context;\r\n	this.source = this.context.createBufferSource();\r\n\r\n	this.gain = this.context.createGain();\r\n	this.gain.connect( this.context.destination );\r\n\r\n	this.panner = this.context.createPanner();\r\n	this.panner.connect( this.gain );\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Audio.prototype.constructor = THREE.Audio;\r\n\r\nTHREE.Audio.prototype.load = function ( file ) {\r\n\r\n	var scope = this;\r\n\r\n	var request = new XMLHttpRequest();\r\n	request.open( 'GET', file, true );\r\n	request.responseType = 'arraybuffer';\r\n	request.onload = function ( e ) {\r\n\r\n		scope.context.decodeAudioData( this.response, function ( buffer ) {\r\n\r\n			scope.source.buffer = buffer;\r\n			scope.source.connect( scope.panner );\r\n			scope.source.start( 0 );\r\n\r\n		} );\r\n\r\n	};\r\n	request.send();\r\n\r\n	return this;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setLoop = function ( value ) {\r\n\r\n	this.source.loop = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRefDistance = function ( value ) {\r\n\r\n	this.panner.refDistance = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.setRolloffFactor = function ( value ) {\r\n\r\n	this.panner.rolloffFactor = value;\r\n\r\n};\r\n\r\nTHREE.Audio.prototype.updateMatrixWorld = ( function () {\r\n\r\n	var position = new THREE.Vector3();\r\n\r\n	return function ( force ) {\r\n\r\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n		position.setFromMatrixPosition( this.matrixWorld );\r\n\r\n		this.panner.setPosition( position.x, position.y, position.z );\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/extras/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.type = 'AudioListener';\r\n\r\n	this.context = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.AudioListener.prototype.constructor = THREE.AudioListener;\r\n\r\nTHREE.AudioListener.prototype.updateMatrixWorld = ( function () {\r\n\r\n	var position = new THREE.Vector3();\r\n	var quaternion = new THREE.Quaternion();\r\n	var scale = new THREE.Vector3();\r\n\r\n	var orientation = new THREE.Vector3();\r\n	var velocity = new THREE.Vector3();\r\n\r\n	var positionPrev = new THREE.Vector3();\r\n\r\n	return function ( force ) {\r\n\r\n		THREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n		var listener = this.context.listener;\r\n		var up = this.up;\r\n\r\n		this.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n		orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );\r\n		velocity.subVectors( position, positionPrev );\r\n\r\n		listener.setPosition( position.x, position.y, position.z );\r\n		listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n		listener.setVelocity( velocity.x, velocity.y, velocity.z );\r\n\r\n		positionPrev.copy( position );\r\n\r\n	};\r\n\r\n} )();\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n * THREE.ClosedSplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *	Abstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\n// Virtual base class method to overwrite and implement in subclasses\r\n//	- t [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPoint = function ( t ) {\r\n\r\n	console.log( \"Warning, getPoint() not implemented!\" );\r\n	return null;\r\n\r\n};\r\n\r\n// Get point at relative position in curve according to arc length\r\n// - u [0 .. 1]\r\n\r\nTHREE.Curve.prototype.getPointAt = function ( u ) {\r\n\r\n	var t = this.getUtoTmapping( u );\r\n	return this.getPoint( t );\r\n\r\n};\r\n\r\n// Get sequence of points using getPoint( t )\r\n\r\nTHREE.Curve.prototype.getPoints = function ( divisions ) {\r\n\r\n	if ( ! divisions ) divisions = 5;\r\n\r\n	var d, pts = [];\r\n\r\n	for ( d = 0; d <= divisions; d ++ ) {\r\n\r\n		pts.push( this.getPoint( d / divisions ) );\r\n\r\n	}\r\n\r\n	return pts;\r\n\r\n};\r\n\r\n// Get sequence of points using getPointAt( u )\r\n\r\nTHREE.Curve.prototype.getSpacedPoints = function ( divisions ) {\r\n\r\n	if ( ! divisions ) divisions = 5;\r\n\r\n	var d, pts = [];\r\n\r\n	for ( d = 0; d <= divisions; d ++ ) {\r\n\r\n		pts.push( this.getPointAt( d / divisions ) );\r\n\r\n	}\r\n\r\n	return pts;\r\n\r\n};\r\n\r\n// Get total curve arc length\r\n\r\nTHREE.Curve.prototype.getLength = function () {\r\n\r\n	var lengths = this.getLengths();\r\n	return lengths[ lengths.length - 1 ];\r\n\r\n};\r\n\r\n// Get list of cumulative segment lengths\r\n\r\nTHREE.Curve.prototype.getLengths = function ( divisions ) {\r\n\r\n	if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;\r\n\r\n	if ( this.cacheArcLengths\r\n		&& ( this.cacheArcLengths.length == divisions + 1 )\r\n		&& ! this.needsUpdate) {\r\n\r\n		//console.log( \"cached\", this.cacheArcLengths );\r\n		return this.cacheArcLengths;\r\n\r\n	}\r\n\r\n	this.needsUpdate = false;\r\n\r\n	var cache = [];\r\n	var current, last = this.getPoint( 0 );\r\n	var p, sum = 0;\r\n\r\n	cache.push( 0 );\r\n\r\n	for ( p = 1; p <= divisions; p ++ ) {\r\n\r\n		current = this.getPoint ( p / divisions );\r\n		sum += current.distanceTo( last );\r\n		cache.push( sum );\r\n		last = current;\r\n\r\n	}\r\n\r\n	this.cacheArcLengths = cache;\r\n\r\n	return cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.updateArcLengths = function() {\r\n	this.needsUpdate = true;\r\n	this.getLengths();\r\n};\r\n\r\n// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance\r\n\r\nTHREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {\r\n\r\n	var arcLengths = this.getLengths();\r\n\r\n	var i = 0, il = arcLengths.length;\r\n\r\n	var targetArcLength; // The targeted u distance value to get\r\n\r\n	if ( distance ) {\r\n\r\n		targetArcLength = distance;\r\n\r\n	} else {\r\n\r\n		targetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n	}\r\n\r\n	//var time = Date.now();\r\n\r\n	// binary search for the index with largest value smaller than target u distance\r\n\r\n	var low = 0, high = il - 1, comparison;\r\n\r\n	while ( low <= high ) {\r\n\r\n		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n		comparison = arcLengths[ i ] - targetArcLength;\r\n\r\n		if ( comparison < 0 ) {\r\n\r\n			low = i + 1;\r\n			continue;\r\n\r\n		} else if ( comparison > 0 ) {\r\n\r\n			high = i - 1;\r\n			continue;\r\n\r\n		} else {\r\n\r\n			high = i;\r\n			break;\r\n\r\n			// DONE\r\n\r\n		}\r\n\r\n	}\r\n\r\n	i = high;\r\n\r\n	//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n	if ( arcLengths[ i ] == targetArcLength ) {\r\n\r\n		var t = i / ( il - 1 );\r\n		return t;\r\n\r\n	}\r\n\r\n	// we could get finer grain at lengths, or use simple interpolatation between two points\r\n\r\n	var lengthBefore = arcLengths[ i ];\r\n    var lengthAfter = arcLengths[ i + 1 ];\r\n\r\n    var segmentLength = lengthAfter - lengthBefore;\r\n\r\n    // determine where we are between the 'before' and 'after' points\r\n\r\n    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n    // add that fractional amount to t\r\n\r\n    var t = ( i + segmentFraction ) / ( il -1 );\r\n\r\n	return t;\r\n\r\n};\r\n\r\n// Returns a unit vector tangent at t\r\n// In case any sub curve does not implement its tangent derivation,\r\n// 2 points a small delta apart will be used to find its gradient\r\n// which seems to give a reasonable approximation\r\n\r\nTHREE.Curve.prototype.getTangent = function( t ) {\r\n\r\n	var delta = 0.0001;\r\n	var t1 = t - delta;\r\n	var t2 = t + delta;\r\n\r\n	// Capping in case of danger\r\n\r\n	if ( t1 < 0 ) t1 = 0;\r\n	if ( t2 > 1 ) t2 = 1;\r\n\r\n	var pt1 = this.getPoint( t1 );\r\n	var pt2 = this.getPoint( t2 );\r\n\r\n	var vec = pt2.clone().sub(pt1);\r\n	return vec.normalize();\r\n\r\n};\r\n\r\n\r\nTHREE.Curve.prototype.getTangentAt = function ( u ) {\r\n\r\n	var t = this.getUtoTmapping( u );\r\n	return this.getTangent( t );\r\n\r\n};\r\n\r\n\r\n\r\n\r\n\r\n/**************************************************************\r\n *	Utils\r\n **************************************************************/\r\n\r\nTHREE.Curve.Utils = {\r\n\r\n	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n	},\r\n\r\n	// Puay Bing, thanks for helping with this derivative!\r\n\r\n	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {\r\n\r\n		return - 3 * p0 * (1 - t) * (1 - t)  +\r\n			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +\r\n			6 * t *  p2 * (1-t) - 3 * t * t * p2 +\r\n			3 * t * t * p3;\r\n\r\n	},\r\n\r\n	tangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n		// To check if my formulas are correct\r\n\r\n		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1\r\n		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2\r\n		var h11 = 3 * t * t - 2 * t;	// t3 − t2\r\n\r\n		return h00 + h10 + h01 + h11;\r\n\r\n	},\r\n\r\n	// Catmull-Rom\r\n\r\n	interpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n		var v0 = ( p2 - p0 ) * 0.5;\r\n		var v1 = ( p3 - p1 ) * 0.5;\r\n		var t2 = t * t;\r\n		var t3 = t * t2;\r\n		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *	3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n	constructor.prototype = Object.create( THREE.Curve.prototype );\r\n	constructor.prototype.constructor = constructor;\r\n	constructor.prototype.getPoint = getPointFunc;\r\n\r\n	return constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *	Curved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n	this.curves = [];\r\n	this.bends = [];\r\n	\r\n	this.autoClose = false; // Automatically closes the path\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CurvePath.prototype.constructor = THREE.CurvePath;\r\n\r\nTHREE.CurvePath.prototype.add = function ( curve ) {\r\n\r\n	this.curves.push( curve );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.checkConnection = function() {\r\n	// TODO\r\n	// If the ending of curve is not connected to the starting\r\n	// or the next curve, then, this is not a real path\r\n};\r\n\r\nTHREE.CurvePath.prototype.closePath = function() {\r\n	// TODO Test\r\n	// and verify for vector3 (needs to implement equals)\r\n	// Add a line curve if start and end of lines are not connected\r\n	var startPoint = this.curves[0].getPoint(0);\r\n	var endPoint = this.curves[this.curves.length-1].getPoint(1);\r\n	\r\n	if (! startPoint.equals(endPoint)) {\r\n		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );\r\n	}\r\n	\r\n};\r\n\r\n// To get accurate point with reference to\r\n// entire path distance at time t,\r\n// following has to be done:\r\n\r\n// 1. Length of each sub path have to be known\r\n// 2. Locate and identify type of curve\r\n// 3. Get t for the curve\r\n// 4. Return curve.getPointAt(t')\r\n\r\nTHREE.CurvePath.prototype.getPoint = function( t ) {\r\n\r\n	var d = t * this.getLength();\r\n	var curveLengths = this.getCurveLengths();\r\n	var i = 0, diff, curve;\r\n\r\n	// To think about boundaries points.\r\n\r\n	while ( i < curveLengths.length ) {\r\n\r\n		if ( curveLengths[ i ] >= d ) {\r\n\r\n			diff = curveLengths[ i ] - d;\r\n			curve = this.curves[ i ];\r\n\r\n			var u = 1 - diff / curve.getLength();\r\n\r\n			return curve.getPointAt( u );\r\n\r\n			break;\r\n		}\r\n\r\n		i ++;\r\n\r\n	}\r\n\r\n	return null;\r\n\r\n	// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n};\r\n\r\n/*\r\nTHREE.CurvePath.prototype.getTangent = function( t ) {\r\n};*/\r\n\r\n\r\n// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n// getPoint() depends on getLength\r\n\r\nTHREE.CurvePath.prototype.getLength = function() {\r\n\r\n	var lens = this.getCurveLengths();\r\n	return lens[ lens.length - 1 ];\r\n\r\n};\r\n\r\n// Compute lengths and cache them\r\n// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\nTHREE.CurvePath.prototype.getCurveLengths = function() {\r\n\r\n	// We use cache values if curves and cache array are same length\r\n\r\n	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {\r\n\r\n		return this.cacheLengths;\r\n\r\n	};\r\n\r\n	// Get length of subsurve\r\n	// Push sums into cached array\r\n\r\n	var lengths = [], sums = 0;\r\n	var i, il = this.curves.length;\r\n\r\n	for ( i = 0; i < il; i ++ ) {\r\n\r\n		sums += this.curves[ i ].getLength();\r\n		lengths.push( sums );\r\n\r\n	}\r\n\r\n	this.cacheLengths = lengths;\r\n\r\n	return lengths;\r\n\r\n};\r\n\r\n\r\n\r\n// Returns min and max coordinates\r\n\r\nTHREE.CurvePath.prototype.getBoundingBox = function () {\r\n\r\n	var points = this.getPoints();\r\n\r\n	var maxX, maxY, maxZ;\r\n	var minX, minY, minZ;\r\n\r\n	maxX = maxY = Number.NEGATIVE_INFINITY;\r\n	minX = minY = Number.POSITIVE_INFINITY;\r\n\r\n	var p, i, il, sum;\r\n\r\n	var v3 = points[0] instanceof THREE.Vector3;\r\n\r\n	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();\r\n\r\n	for ( i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n		p = points[ i ];\r\n\r\n		if ( p.x > maxX ) maxX = p.x;\r\n		else if ( p.x < minX ) minX = p.x;\r\n\r\n		if ( p.y > maxY ) maxY = p.y;\r\n		else if ( p.y < minY ) minY = p.y;\r\n\r\n		if ( v3 ) {\r\n\r\n			if ( p.z > maxZ ) maxZ = p.z;\r\n			else if ( p.z < minZ ) minZ = p.z;\r\n\r\n		}\r\n\r\n		sum.add( p );\r\n\r\n	}\r\n\r\n	var ret = {\r\n\r\n		minX: minX,\r\n		minY: minY,\r\n		maxX: maxX,\r\n		maxY: maxY\r\n\r\n	};\r\n\r\n	if ( v3 ) {\r\n\r\n		ret.maxZ = maxZ;\r\n		ret.minZ = minZ;\r\n\r\n	}\r\n\r\n	return ret;\r\n\r\n};\r\n\r\n/**************************************************************\r\n *	Create Geometries Helpers\r\n **************************************************************/\r\n\r\n/// Generate geometry from path points (for Line or Points objects)\r\n\r\nTHREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {\r\n\r\n	var pts = this.getPoints( divisions, true );\r\n	return this.createGeometry( pts );\r\n\r\n};\r\n\r\n// Generate geometry from equidistance sampling along the path\r\n\r\nTHREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {\r\n\r\n	var pts = this.getSpacedPoints( divisions, true );\r\n	return this.createGeometry( pts );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.createGeometry = function( points ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	for ( var i = 0; i < points.length; i ++ ) {\r\n\r\n		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );\r\n\r\n	}\r\n\r\n	return geometry;\r\n\r\n};\r\n\r\n\r\n/**************************************************************\r\n *	Bend / Wrap Helper Methods\r\n **************************************************************/\r\n\r\n// Wrap path / Bend modifiers?\r\n\r\nTHREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {\r\n\r\n	this.bends.push( bendpath );\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {\r\n\r\n	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints\r\n	var i, il;\r\n\r\n	if ( ! bends ) {\r\n\r\n		bends = this.bends;\r\n\r\n	}\r\n\r\n	for ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n		oldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n	}\r\n\r\n	return oldPts;\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {\r\n\r\n	var oldPts = this.getSpacedPoints( segments );\r\n\r\n	var i, il;\r\n\r\n	if ( ! bends ) {\r\n\r\n		bends = this.bends;\r\n\r\n	}\r\n\r\n	for ( i = 0, il = bends.length; i < il; i ++ ) {\r\n\r\n		oldPts = this.getWrapPoints( oldPts, bends[ i ] );\r\n\r\n	}\r\n\r\n	return oldPts;\r\n\r\n};\r\n\r\n// This returns getPoints() bend/wrapped around the contour of a path.\r\n// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html\r\n\r\nTHREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {\r\n\r\n	var bounds = this.getBoundingBox();\r\n\r\n	var i, il, p, oldX, oldY, xNorm;\r\n\r\n	for ( i = 0, il = oldPts.length; i < il; i ++ ) {\r\n\r\n		p = oldPts[ i ];\r\n\r\n		oldX = p.x;\r\n		oldY = p.y;\r\n\r\n		xNorm = oldX / bounds.maxX;\r\n\r\n		// If using actual distance, for length > path, requires line extrusions\r\n		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance\r\n\r\n		xNorm = path.getUtoTmapping( xNorm, oldX );\r\n\r\n		// check for out of bounds?\r\n\r\n		var pathPt = path.getPoint( xNorm );\r\n		var normal = path.getTangent( xNorm );\r\n		normal.set( - normal.y, normal.x ).multiplyScalar( oldY );\r\n\r\n		p.x = pathPt.x + normal.x;\r\n		p.y = pathPt.y + normal.y;\r\n\r\n	}\r\n\r\n	return oldPts;\r\n\r\n};\r\n\r\n\r\n// File:src/extras/core/Gyroscope.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Gyroscope = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n};\r\n\r\nTHREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Gyroscope.prototype.constructor = THREE.Gyroscope;\r\n\r\nTHREE.Gyroscope.prototype.updateMatrixWorld = ( function () {\r\n\r\n	var translationObject = new THREE.Vector3();\r\n	var quaternionObject = new THREE.Quaternion();\r\n	var scaleObject = new THREE.Vector3();\r\n\r\n	var translationWorld = new THREE.Vector3();\r\n	var quaternionWorld = new THREE.Quaternion();\r\n	var scaleWorld = new THREE.Vector3();\r\n\r\n	return function ( force ) {\r\n\r\n		this.matrixAutoUpdate && this.updateMatrix();\r\n\r\n		// update matrixWorld\r\n\r\n		if ( this.matrixWorldNeedsUpdate || force ) {\r\n\r\n			if ( this.parent ) {\r\n\r\n				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n				this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );\r\n				this.matrix.decompose( translationObject, quaternionObject, scaleObject );\r\n\r\n				this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );\r\n\r\n\r\n			} else {\r\n\r\n				this.matrixWorld.copy( this.matrix );\r\n\r\n			}\r\n\r\n\r\n			this.matrixWorldNeedsUpdate = false;\r\n\r\n			force = true;\r\n\r\n		}\r\n\r\n		// update children\r\n\r\n		for ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n			this.children[ i ].updateMatrixWorld( force );\r\n\r\n		}\r\n\r\n	};\r\n	\r\n}() );\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n	THREE.CurvePath.call(this);\r\n\r\n	this.actions = [];\r\n\r\n	if ( points ) {\r\n\r\n		this.fromPoints( points );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.create( THREE.CurvePath.prototype );\r\nTHREE.Path.prototype.constructor = THREE.Path;\r\n\r\nTHREE.PathActions = {\r\n\r\n	MOVE_TO: 'moveTo',\r\n	LINE_TO: 'lineTo',\r\n	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve\r\n	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve\r\n	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline\r\n	ARC: 'arc',								// Circle\r\n	ELLIPSE: 'ellipse'\r\n};\r\n\r\n// TODO Clean up PATH API\r\n\r\n// Create path using straight lines to connect all points\r\n// - vectors: array of Vector2\r\n\r\nTHREE.Path.prototype.fromPoints = function ( vectors ) {\r\n\r\n	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {\r\n\r\n		this.lineTo( vectors[ v ].x, vectors[ v ].y );\r\n\r\n	};\r\n\r\n};\r\n\r\n// startPath() endPath()?\r\n\r\nTHREE.Path.prototype.moveTo = function ( x, y ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.lineTo = function ( x, y ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),\r\n												new THREE.Vector2( aCPx, aCPy ),\r\n												new THREE.Vector2( aX, aY ) );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,\r\n											   aCP2x, aCP2y,\r\n											   aX, aY ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),\r\n											new THREE.Vector2( aCP1x, aCP1y ),\r\n											new THREE.Vector2( aCP2x, aCP2y ),\r\n											new THREE.Vector2( aX, aY ) );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );\r\n\r\n};\r\n\r\nTHREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n	var lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n//---\r\n	var npts = [ new THREE.Vector2( x0, y0 ) ];\r\n	Array.prototype.push.apply( npts, pts );\r\n\r\n	var curve = new THREE.SplineCurve( npts );\r\n	this.curves.push( curve );\r\n\r\n	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );\r\n\r\n};\r\n\r\n// FUTURE: Change the API or follow canvas API?\r\n\r\nTHREE.Path.prototype.arc = function ( aX, aY, aRadius,\r\n									  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1].args;\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	this.absarc(aX + x0, aY + y0, aRadius,\r\n		aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n THREE.Path.prototype.absarc = function ( aX, aY, aRadius,\r\n									  aStartAngle, aEndAngle, aClockwise ) {\r\n	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\r\n };\r\n\r\nTHREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,\r\n									  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	var lastargs = this.actions[ this.actions.length - 1].args;\r\n	var x0 = lastargs[ lastargs.length - 2 ];\r\n	var y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,\r\n		aStartAngle, aEndAngle, aClockwise );\r\n\r\n };\r\n\r\n\r\nTHREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,\r\n									  aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	var args = Array.prototype.slice.call( arguments );\r\n	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,\r\n									aStartAngle, aEndAngle, aClockwise );\r\n	this.curves.push( curve );\r\n\r\n	var lastPoint = curve.getPoint(1);\r\n	args.push(lastPoint.x);\r\n	args.push(lastPoint.y);\r\n\r\n	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );\r\n\r\n };\r\n\r\nTHREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {\r\n\r\n	if ( ! divisions ) divisions = 40;\r\n\r\n	var points = [];\r\n\r\n	for ( var i = 0; i < divisions; i ++ ) {\r\n\r\n		points.push( this.getPoint( i / divisions ) );\r\n\r\n		//if( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n	}\r\n\r\n	// if ( closedPath ) {\r\n	//\r\n	// 	points.push( points[ 0 ] );\r\n	//\r\n	// }\r\n\r\n	return points;\r\n\r\n};\r\n\r\n/* Return an array of vectors based on contour of the path */\r\n\r\nTHREE.Path.prototype.getPoints = function( divisions, closedPath ) {\r\n\r\n	if (this.useSpacedPoints) {\r\n		console.log('tata');\r\n		return this.getSpacedPoints( divisions, closedPath );\r\n	}\r\n\r\n	divisions = divisions || 12;\r\n\r\n	var points = [];\r\n\r\n	var i, il, item, action, args;\r\n	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n		laste, j,\r\n		t, tx, ty;\r\n\r\n	for ( i = 0, il = this.actions.length; i < il; i ++ ) {\r\n\r\n		item = this.actions[ i ];\r\n\r\n		action = item.action;\r\n		args = item.args;\r\n\r\n		switch( action ) {\r\n\r\n		case THREE.PathActions.MOVE_TO:\r\n\r\n			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.LINE_TO:\r\n\r\n			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.QUADRATIC_CURVE_TO:\r\n\r\n			cpx  = args[ 2 ];\r\n			cpy  = args[ 3 ];\r\n\r\n			cpx1 = args[ 0 ];\r\n			cpy1 = args[ 1 ];\r\n\r\n			if ( points.length > 0 ) {\r\n\r\n				laste = points[ points.length - 1 ];\r\n\r\n				cpx0 = laste.x;\r\n				cpy0 = laste.y;\r\n\r\n			} else {\r\n\r\n				laste = this.actions[ i - 1 ].args;\r\n\r\n				cpx0 = laste[ laste.length - 2 ];\r\n				cpy0 = laste[ laste.length - 1 ];\r\n\r\n			}\r\n\r\n			for ( j = 1; j <= divisions; j ++ ) {\r\n\r\n				t = j / divisions;\r\n\r\n				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );\r\n				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.BEZIER_CURVE_TO:\r\n\r\n			cpx  = args[ 4 ];\r\n			cpy  = args[ 5 ];\r\n\r\n			cpx1 = args[ 0 ];\r\n			cpy1 = args[ 1 ];\r\n\r\n			cpx2 = args[ 2 ];\r\n			cpy2 = args[ 3 ];\r\n\r\n			if ( points.length > 0 ) {\r\n\r\n				laste = points[ points.length - 1 ];\r\n\r\n				cpx0 = laste.x;\r\n				cpy0 = laste.y;\r\n\r\n			} else {\r\n\r\n				laste = this.actions[ i - 1 ].args;\r\n\r\n				cpx0 = laste[ laste.length - 2 ];\r\n				cpy0 = laste[ laste.length - 1 ];\r\n\r\n			}\r\n\r\n\r\n			for ( j = 1; j <= divisions; j ++ ) {\r\n\r\n				t = j / divisions;\r\n\r\n				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );\r\n				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.CSPLINE_THRU:\r\n\r\n			laste = this.actions[ i - 1 ].args;\r\n\r\n			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n			var spts = [ last ];\r\n\r\n			var n = divisions * args[ 0 ].length;\r\n\r\n			spts = spts.concat( args[ 0 ] );\r\n\r\n			var spline = new THREE.SplineCurve( spts );\r\n\r\n			for ( j = 1; j <= n; j ++ ) {\r\n\r\n				points.push( spline.getPointAt( j / n ) ) ;\r\n\r\n			}\r\n\r\n			break;\r\n\r\n		case THREE.PathActions.ARC:\r\n\r\n			var aX = args[ 0 ], aY = args[ 1 ],\r\n				aRadius = args[ 2 ],\r\n				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n				aClockwise = !! args[ 5 ];\r\n\r\n			var deltaAngle = aEndAngle - aStartAngle;\r\n			var angle;\r\n			var tdivisions = divisions * 2;\r\n\r\n			for ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n				t = j / tdivisions;\r\n\r\n				if ( ! aClockwise ) {\r\n\r\n					t = 1 - t;\r\n\r\n				}\r\n\r\n				angle = aStartAngle + t * deltaAngle;\r\n\r\n				tx = aX + aRadius * Math.cos( angle );\r\n				ty = aY + aRadius * Math.sin( angle );\r\n\r\n				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			//console.log(points);\r\n\r\n		  break;\r\n		  \r\n		case THREE.PathActions.ELLIPSE:\r\n\r\n			var aX = args[ 0 ], aY = args[ 1 ],\r\n				xRadius = args[ 2 ],\r\n				yRadius = args[ 3 ],\r\n				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n				aClockwise = !! args[ 6 ];\r\n\r\n\r\n			var deltaAngle = aEndAngle - aStartAngle;\r\n			var angle;\r\n			var tdivisions = divisions * 2;\r\n\r\n			for ( j = 1; j <= tdivisions; j ++ ) {\r\n\r\n				t = j / tdivisions;\r\n\r\n				if ( ! aClockwise ) {\r\n\r\n					t = 1 - t;\r\n\r\n				}\r\n\r\n				angle = aStartAngle + t * deltaAngle;\r\n\r\n				tx = aX + xRadius * Math.cos( angle );\r\n				ty = aY + yRadius * Math.sin( angle );\r\n\r\n				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n				points.push( new THREE.Vector2( tx, ty ) );\r\n\r\n			}\r\n\r\n			//console.log(points);\r\n\r\n		  break;\r\n\r\n		} // end switch\r\n\r\n	}\r\n\r\n\r\n\r\n	// Normalize to remove the closing point by default.\r\n	var lastPoint = points[ points.length - 1];\r\n	var EPSILON = 0.0000000001;\r\n	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&\r\n			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)\r\n		points.splice( points.length - 1, 1);\r\n	if ( closedPath ) {\r\n\r\n		points.push( points[ 0 ] );\r\n\r\n	}\r\n\r\n	return points;\r\n\r\n};\r\n\r\n//\r\n// Breaks path into shapes\r\n//\r\n//	Assumptions (if parameter isCCW==true the opposite holds):\r\n//	- solid shapes are defined clockwise (CW)\r\n//	- holes are defined counterclockwise (CCW)\r\n//\r\n//	If parameter noHoles==true:\r\n//  - all subPaths are regarded as solid shapes\r\n//  - definition order CW/CCW has no relevance\r\n//\r\n\r\nTHREE.Path.prototype.toShapes = function( isCCW, noHoles ) {\r\n\r\n	function extractSubpaths( inActions ) {\r\n\r\n		var i, il, item, action, args;\r\n\r\n		var subPaths = [], lastPath = new THREE.Path();\r\n\r\n		for ( i = 0, il = inActions.length; i < il; i ++ ) {\r\n\r\n			item = inActions[ i ];\r\n\r\n			args = item.args;\r\n			action = item.action;\r\n\r\n			if ( action == THREE.PathActions.MOVE_TO ) {\r\n\r\n				if ( lastPath.actions.length != 0 ) {\r\n\r\n					subPaths.push( lastPath );\r\n					lastPath = new THREE.Path();\r\n\r\n				}\r\n\r\n			}\r\n\r\n			lastPath[ action ].apply( lastPath, args );\r\n\r\n		}\r\n\r\n		if ( lastPath.actions.length != 0 ) {\r\n\r\n			subPaths.push( lastPath );\r\n\r\n		}\r\n\r\n		// console.log(subPaths);\r\n\r\n		return	subPaths;\r\n	}\r\n\r\n	function toShapesNoHoles( inSubpaths ) {\r\n\r\n		var shapes = [];\r\n\r\n		for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {\r\n\r\n			var tmpPath = inSubpaths[ i ];\r\n\r\n			var tmpShape = new THREE.Shape();\r\n			tmpShape.actions = tmpPath.actions;\r\n			tmpShape.curves = tmpPath.curves;\r\n\r\n			shapes.push( tmpShape );\r\n		}\r\n\r\n		//console.log(\"shape\", shapes);\r\n\r\n		return shapes;\r\n	};\r\n\r\n	function isPointInsidePolygon( inPt, inPolygon ) {\r\n		var EPSILON = 0.0000000001;\r\n\r\n		var polyLen = inPolygon.length;\r\n\r\n		// inPt on polygon contour => immediate success    or\r\n		// toggling of inside/outside at every single! intersection point of an edge\r\n		//  with the horizontal line through inPt, left of inPt\r\n		//  not counting lowerY endpoints of edges and whole edges on that line\r\n		var inside = false;\r\n		for( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n			var edgeLowPt  = inPolygon[ p ];\r\n			var edgeHighPt = inPolygon[ q ];\r\n\r\n			var edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n			var edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n			if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel\r\n				if ( edgeDy < 0 ) {\r\n					edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n					edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n				}\r\n				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;\r\n\r\n				if ( inPt.y == edgeLowPt.y ) {\r\n					if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?\r\n					// continue;				// no intersection or edgeLowPt => doesn't count !!!\r\n				} else {\r\n					var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\r\n					if ( perpEdge == 0 )				return	true;		// inPt is on contour ?\r\n					if ( perpEdge < 0 ) 				continue;\r\n					inside = ! inside;		// true intersection left of inPt\r\n				}\r\n			} else {		// parallel or colinear\r\n				if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel\r\n				// egde lies on the same horizontal line as inPt\r\n				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !\r\n				// continue;\r\n			}\r\n		}\r\n\r\n		return	inside;\r\n	}\r\n\r\n\r\n	var subPaths = extractSubpaths( this.actions );\r\n	if ( subPaths.length == 0 ) return [];\r\n\r\n	if ( noHoles === true )	return	toShapesNoHoles( subPaths );\r\n\r\n\r\n	var solid, tmpPath, tmpShape, shapes = [];\r\n\r\n	if ( subPaths.length == 1) {\r\n\r\n		tmpPath = subPaths[0];\r\n		tmpShape = new THREE.Shape();\r\n		tmpShape.actions = tmpPath.actions;\r\n		tmpShape.curves = tmpPath.curves;\r\n		shapes.push( tmpShape );\r\n		return shapes;\r\n\r\n	}\r\n\r\n	var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );\r\n	holesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n	// console.log(\"Holes first\", holesFirst);\r\n	\r\n	var betterShapeHoles = [];\r\n	var newShapes = [];\r\n	var newShapeHoles = [];\r\n	var mainIdx = 0;\r\n	var tmpPoints;\r\n\r\n	newShapes[mainIdx] = undefined;\r\n	newShapeHoles[mainIdx] = [];\r\n\r\n	var i, il;\r\n\r\n	for ( i = 0, il = subPaths.length; i < il; i ++ ) {\r\n\r\n		tmpPath = subPaths[ i ];\r\n		tmpPoints = tmpPath.getPoints();\r\n		solid = THREE.Shape.Utils.isClockWise( tmpPoints );\r\n		solid = isCCW ? ! solid : solid;\r\n\r\n		if ( solid ) {\r\n\r\n			if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx ++;\r\n\r\n			newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };\r\n			newShapes[mainIdx].s.actions = tmpPath.actions;\r\n			newShapes[mainIdx].s.curves = tmpPath.curves;\r\n			\r\n			if ( holesFirst )	mainIdx ++;\r\n			newShapeHoles[mainIdx] = [];\r\n\r\n			//console.log('cw', i);\r\n\r\n		} else {\r\n\r\n			newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );\r\n\r\n			//console.log('ccw', i);\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// only Holes? -> probably all Shapes with wrong orientation\r\n	if ( ! newShapes[0] )	return	toShapesNoHoles( subPaths );\r\n\r\n\r\n	if ( newShapes.length > 1 ) {\r\n		var ambigious = false;\r\n		var toChange = [];\r\n\r\n		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n			betterShapeHoles[sIdx] = [];\r\n		}\r\n		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n			var sh = newShapes[sIdx];\r\n			var sho = newShapeHoles[sIdx];\r\n			for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n				var ho = sho[hIdx];\r\n				var hole_unassigned = true;\r\n				for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n					if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {\r\n						if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n						if ( hole_unassigned ) {\r\n							hole_unassigned = false;\r\n							betterShapeHoles[s2Idx].push( ho );\r\n						} else {\r\n							ambigious = true;\r\n						}\r\n					}\r\n				}\r\n				if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }\r\n			}\r\n		}\r\n		// console.log(\"ambigious: \", ambigious);\r\n		if ( toChange.length > 0 ) {\r\n			// console.log(\"to change: \", toChange);\r\n			if (! ambigious)	newShapeHoles = betterShapeHoles;\r\n		}\r\n	}\r\n\r\n	var tmpHoles, j, jl;\r\n	for ( i = 0, il = newShapes.length; i < il; i ++ ) {\r\n		tmpShape = newShapes[i].s;\r\n		shapes.push( tmpShape );\r\n		tmpHoles = newShapeHoles[i];\r\n		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n			tmpShape.holes.push( tmpHoles[j].h );\r\n		}\r\n	}\r\n\r\n	//console.log(\"shape\", shapes);\r\n\r\n	return shapes;\r\n\r\n};\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n	THREE.Path.apply( this, arguments );\r\n	this.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.create( THREE.Path.prototype );\r\nTHREE.Shape.prototype.constructor = THREE.Shape;\r\n\r\n// Convenience method to return ExtrudeGeometry\r\n\r\nTHREE.Shape.prototype.extrude = function ( options ) {\r\n\r\n	var extruded = new THREE.ExtrudeGeometry( this, options );\r\n	return extruded;\r\n\r\n};\r\n\r\n// Convenience method to return ShapeGeometry\r\n\r\nTHREE.Shape.prototype.makeGeometry = function ( options ) {\r\n\r\n	var geometry = new THREE.ShapeGeometry( this, options );\r\n	return geometry;\r\n\r\n};\r\n\r\n// Get points of holes\r\n\r\nTHREE.Shape.prototype.getPointsHoles = function ( divisions ) {\r\n\r\n	var i, il = this.holes.length, holesPts = [];\r\n\r\n	for ( i = 0; i < il; i ++ ) {\r\n\r\n		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );\r\n\r\n	}\r\n\r\n	return holesPts;\r\n\r\n};\r\n\r\n// Get points of holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {\r\n\r\n	var i, il = this.holes.length, holesPts = [];\r\n\r\n	for ( i = 0; i < il; i ++ ) {\r\n\r\n		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );\r\n\r\n	}\r\n\r\n	return holesPts;\r\n\r\n};\r\n\r\n\r\n// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\nTHREE.Shape.prototype.extractAllPoints = function ( divisions ) {\r\n\r\n	return {\r\n\r\n		shape: this.getTransformedPoints( divisions ),\r\n		holes: this.getPointsHoles( divisions )\r\n\r\n	};\r\n\r\n};\r\n\r\nTHREE.Shape.prototype.extractPoints = function ( divisions ) {\r\n\r\n	if (this.useSpacedPoints) {\r\n		return this.extractAllSpacedPoints(divisions);\r\n	}\r\n\r\n	return this.extractAllPoints(divisions);\r\n\r\n};\r\n\r\n//\r\n// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {\r\n//\r\n// 	return {\r\n//\r\n// 		shape: this.transform( bend, divisions ),\r\n// 		holes: this.getPointsHoles( divisions, bend )\r\n//\r\n// 	};\r\n//\r\n// };\r\n\r\n// Get points of shape and holes (spaced by regular distance)\r\n\r\nTHREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {\r\n\r\n	return {\r\n\r\n		shape: this.getTransformedSpacedPoints( divisions ),\r\n		holes: this.getSpacedPointsHoles( divisions )\r\n\r\n	};\r\n\r\n};\r\n\r\n/**************************************************************\r\n *	Utils\r\n **************************************************************/\r\n\r\nTHREE.Shape.Utils = {\r\n\r\n	triangulateShape: function ( contour, holes ) {\r\n\r\n		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n			// inOtherPt needs to be colinear to the inSegment\r\n			if ( inSegPt1.x != inSegPt2.x ) {\r\n				if ( inSegPt1.x < inSegPt2.x ) {\r\n					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n				} else {\r\n					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n				}\r\n			} else {\r\n				if ( inSegPt1.y < inSegPt2.y ) {\r\n					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n				} else {\r\n					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n				}\r\n			}\r\n		}\r\n\r\n		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n			var EPSILON = 0.0000000001;\r\n\r\n			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;\r\n			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n			if ( Math.abs(limit) > EPSILON ) {			// not parallel\r\n\r\n				var perpSeg2;\r\n				if ( limit > 0 ) {\r\n					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];\r\n					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];\r\n				} else {\r\n					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];\r\n					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];\r\n				}\r\n\r\n				// i.e. to reduce rounding errors\r\n				// intersection at endpoint of segment#1?\r\n				if ( perpSeg2 == 0 ) {\r\n					if ( ( inExcludeAdjacentSegs ) &&\r\n						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];\r\n					return  [ inSeg1Pt1 ];\r\n				}\r\n				if ( perpSeg2 == limit ) {\r\n					if ( ( inExcludeAdjacentSegs ) &&\r\n						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];\r\n					return  [ inSeg1Pt2 ];\r\n				}\r\n				// intersection at endpoint of segment#2?\r\n				if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];\r\n				if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];\r\n\r\n				// return real intersection point\r\n				var factorSeg1 = perpSeg2 / limit;\r\n				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n			} else {		// parallel or colinear\r\n				if ( ( perpSeg1 != 0 ) ||\r\n					 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];\r\n\r\n				// they are collinear or degenerate\r\n				var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?\r\n				var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?\r\n				// both segments are points\r\n				if ( seg1Pt && seg2Pt ) {\r\n					if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||\r\n						 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points\r\n					return  [ inSeg1Pt1 ];                 					// they are the same point\r\n				}\r\n				// segment#1  is a single point\r\n				if ( seg1Pt ) {\r\n					if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2\r\n					return  [ inSeg1Pt1 ];\r\n				}\r\n				// segment#2  is a single point\r\n				if ( seg2Pt ) {\r\n					if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1\r\n					return  [ inSeg2Pt1 ];\r\n				}\r\n\r\n				// they are collinear segments, which might overlap\r\n				var seg1min, seg1max, seg1minVal, seg1maxVal;\r\n				var seg2min, seg2max, seg2minVal, seg2maxVal;\r\n				if (seg1dx != 0) {		// the segments are NOT on a vertical line\r\n					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n					} else {\r\n						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n					}\r\n					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n					} else {\r\n						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n					}\r\n				} else {				// the segments are on a vertical line\r\n					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n					} else {\r\n						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n					}\r\n					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n					} else {\r\n						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n					}\r\n				}\r\n				if ( seg1minVal <= seg2minVal ) {\r\n					if ( seg1maxVal <  seg2minVal )	return [];\r\n					if ( seg1maxVal == seg2minVal )	{\r\n						if ( inExcludeAdjacentSegs )		return [];\r\n						return [ seg2min ];\r\n					}\r\n					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];\r\n					return	[ seg2min, seg2max ];\r\n				} else {\r\n					if ( seg1minVal >  seg2maxVal )	return [];\r\n					if ( seg1minVal == seg2maxVal )	{\r\n						if ( inExcludeAdjacentSegs )		return [];\r\n						return [ seg1min ];\r\n					}\r\n					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];\r\n					return	[ seg1min, seg2max ];\r\n				}\r\n			}\r\n		}\r\n\r\n		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n			// The order of legs is important\r\n\r\n			var EPSILON = 0.0000000001;\r\n\r\n			// translation of all points, so that Vertex is at (0,0)\r\n			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;\r\n			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;\r\n			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;\r\n\r\n			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n			if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.\r\n\r\n				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;\r\n				// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n				if ( from2toAngle > 0 ) {				// main angle < 180 deg.\r\n					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n				} else {								// main angle > 180 deg.\r\n					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n				}\r\n			} else {										// angle == 180 deg.\r\n				// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n				return	( from2otherAngle > 0 );\r\n			}\r\n		}\r\n\r\n\r\n		function removeHoles( contour, holes ) {\r\n\r\n			var shape = contour.concat(); // work on this shape\r\n			var hole;\r\n\r\n			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n				// Check if hole point lies within angle around shape point\r\n				var lastShapeIdx = shape.length - 1;\r\n\r\n				var prevShapeIdx = inShapeIdx - 1;\r\n				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;\r\n\r\n				var nextShapeIdx = inShapeIdx + 1;\r\n				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;\r\n\r\n				var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );\r\n				if (! insideAngle ) {\r\n					// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n					return	false;\r\n				}\r\n\r\n				// Check if shape point lies within angle around hole point\r\n				var lastHoleIdx = hole.length - 1;\r\n\r\n				var prevHoleIdx = inHoleIdx - 1;\r\n				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;\r\n\r\n				var nextHoleIdx = inHoleIdx + 1;\r\n				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;\r\n\r\n				insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );\r\n				if (! insideAngle ) {\r\n					// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n					return	false;\r\n				}\r\n\r\n				return	true;\r\n			}\r\n\r\n			function intersectsShapeEdge( inShapePt, inHolePt ) {\r\n				// checks for intersections with shape edges\r\n				var sIdx, nextIdx, intersection;\r\n				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n					nextIdx = sIdx+1; nextIdx %= shape.length;\r\n					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );\r\n					if ( intersection.length > 0 )		return	true;\r\n				}\r\n\r\n				return	false;\r\n			}\r\n\r\n			var indepHoles = [];\r\n\r\n			function intersectsHoleEdge( inShapePt, inHolePt ) {\r\n				// checks for intersections with hole edges\r\n				var ihIdx, chkHole,\r\n					hIdx, nextIdx, intersection;\r\n				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n					chkHole = holes[indepHoles[ihIdx]];\r\n					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n						nextIdx = hIdx+1; nextIdx %= chkHole.length;\r\n						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );\r\n						if ( intersection.length > 0 )		return	true;\r\n					}\r\n				}\r\n				return	false;\r\n			}\r\n\r\n			var holeIndex, shapeIndex,\r\n				shapePt, holePt,\r\n				holeIdx, cutKey, failedCuts = [],\r\n				tmpShape1, tmpShape2,\r\n				tmpHole1, tmpHole2;\r\n\r\n			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n				indepHoles.push( h );\r\n\r\n			}\r\n\r\n			var minShapeIndex = 0;\r\n			var counter = indepHoles.length * 2;\r\n			while ( indepHoles.length > 0 ) {\r\n				counter --;\r\n				if ( counter < 0 ) {\r\n					console.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n					break;\r\n				}\r\n\r\n				// search for shape-vertex and hole-vertex,\r\n				// which can be connected without intersections\r\n				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n					shapePt = shape[ shapeIndex ];\r\n					holeIndex	= - 1;\r\n\r\n					// search for hole which can be reached without intersections\r\n					for ( var h = 0; h < indepHoles.length; h ++ ) {\r\n						holeIdx = indepHoles[h];\r\n\r\n						// prevent multiple checks\r\n						cutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n						if ( failedCuts[cutKey] !== undefined )			continue;\r\n\r\n						hole = holes[holeIdx];\r\n						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n							holePt = hole[ h2 ];\r\n							if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;\r\n							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;\r\n							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;\r\n\r\n							holeIndex = h2;\r\n							indepHoles.splice(h,1);\r\n\r\n							tmpShape1 = shape.slice( 0, shapeIndex+1 );\r\n							tmpShape2 = shape.slice( shapeIndex );\r\n							tmpHole1 = hole.slice( holeIndex );\r\n							tmpHole2 = hole.slice( 0, holeIndex+1 );\r\n\r\n							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n							minShapeIndex = shapeIndex;\r\n\r\n							// Debug only, to show the selected cuts\r\n							// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n							break;\r\n						}\r\n						if ( holeIndex >= 0 )	break;		// hole-vertex found\r\n\r\n						failedCuts[cutKey] = true;			// remember failure\r\n					}\r\n					if ( holeIndex >= 0 )	break;		// hole-vertex found\r\n				}\r\n			}\r\n\r\n			return shape; 			/* shape with no holes */\r\n		}\r\n\r\n\r\n		var i, il, f, face,\r\n			key, index,\r\n			allPointsMap = {};\r\n\r\n		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n		var allpoints = contour.concat();\r\n\r\n		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			Array.prototype.push.apply( allpoints, holes[h] );\r\n\r\n		}\r\n\r\n		//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n		// prepare all points map\r\n\r\n		for ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n			key = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n			if ( allPointsMap[ key ] !== undefined ) {\r\n\r\n				console.log( \"Duplicate point\", key );\r\n\r\n			}\r\n\r\n			allPointsMap[ key ] = i;\r\n\r\n		}\r\n\r\n		// remove holes by cutting paths to holes and adding them to the shape\r\n		var shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n		//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n		// check all face vertices against all points map\r\n\r\n		for ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n			face = triangles[ i ];\r\n\r\n			for ( f = 0; f < 3; f ++ ) {\r\n\r\n				key = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n				index = allPointsMap[ key ];\r\n\r\n				if ( index !== undefined ) {\r\n\r\n					face[ f ] = index;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return triangles.concat();\r\n\r\n	},\r\n\r\n	isClockWise: function ( pts ) {\r\n\r\n		return THREE.FontUtils.Triangulate.area( pts ) < 0;\r\n\r\n	},\r\n\r\n	// Bezier Curves formulas obtained from\r\n	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n	// Quad Bezier Functions\r\n\r\n	b2p0: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return k * k * p;\r\n\r\n	},\r\n\r\n	b2p1: function ( t, p ) {\r\n\r\n		return 2 * ( 1 - t ) * t * p;\r\n\r\n	},\r\n\r\n	b2p2: function ( t, p ) {\r\n\r\n		return t * t * p;\r\n\r\n	},\r\n\r\n	b2: function ( t, p0, p1, p2 ) {\r\n\r\n		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );\r\n\r\n	},\r\n\r\n	// Cubic Bezier Functions\r\n\r\n	b3p0: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return k * k * k * p;\r\n\r\n	},\r\n\r\n	b3p1: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return 3 * k * k * t * p;\r\n\r\n	},\r\n\r\n	b3p2: function ( t, p ) {\r\n\r\n		var k = 1 - t;\r\n		return 3 * k * t * t * p;\r\n\r\n	},\r\n\r\n	b3p3: function ( t, p ) {\r\n\r\n		return t * t * t * p;\r\n\r\n	},\r\n\r\n	b3: function ( t, p0, p1, p2, p3 ) {\r\n\r\n		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *	Line\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var point = this.v2.clone().sub(this.v1);\r\n	point.multiplyScalar( t ).add( this.v1 );\r\n\r\n	return point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n	return this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n	var tangent = this.v2.clone().sub(this.v1);\r\n\r\n	return tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *	Quadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n	this.v0 = v0;\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var vector = new THREE.Vector2();\r\n\r\n	vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n	vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n	return vector;\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n	var vector = new THREE.Vector2();\r\n\r\n	vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );\r\n	vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );\r\n\r\n	// returns unit vector\r\n\r\n	return vector.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *	Cubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n	this.v0 = v0;\r\n	this.v1 = v1;\r\n	this.v2 = v2;\r\n	this.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var tx, ty;\r\n\r\n	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n	return new THREE.Vector2( tx, ty );\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n	var tx, ty;\r\n\r\n	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n\r\n	var tangent = new THREE.Vector2( tx, ty );\r\n	tangent.normalize();\r\n\r\n	return tangent;\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *	Spline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n	this.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var points = this.points;\r\n	var point = ( points.length - 1 ) * t;\r\n\r\n	var intPoint = Math.floor( point );\r\n	var weight = point - intPoint;\r\n\r\n	var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ]\r\n	var point1 = points[ intPoint ]\r\n	var point2 = points[ intPoint > points.length - 2 ? points.length -1 : intPoint + 1 ]\r\n	var point3 = points[ intPoint > points.length - 3 ? points.length -1 : intPoint + 2 ]\r\n\r\n	var vector = new THREE.Vector2();\r\n\r\n	vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n	vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n\r\n	return vector;\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *	Ellipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	this.aX = aX;\r\n	this.aY = aY;\r\n\r\n	this.xRadius = xRadius;\r\n	this.yRadius = yRadius;\r\n\r\n	this.aStartAngle = aStartAngle;\r\n	this.aEndAngle = aEndAngle;\r\n\r\n	this.aClockwise = aClockwise;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n	var deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n	var angle;\r\n\r\n	if ( this.aClockwise === true ) {\r\n\r\n		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n	} else {\r\n\r\n		angle = this.aStartAngle + t * deltaAngle;\r\n\r\n	}\r\n	\r\n	var vector = new THREE.Vector2();\r\n\r\n	vector.x = this.aX + this.xRadius * Math.cos( angle );\r\n	vector.y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n	return vector;\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *	Arc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *	Line3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n	function ( v1, v2 ) {\r\n\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.subVectors( this.v2, this.v1 ); // diff\r\n		vector.multiplyScalar( t );\r\n		vector.add( this.v1 );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *	Quadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n	function ( v0, v1, v2 ) {\r\n\r\n		this.v0 = v0;\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );\r\n		vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );\r\n		vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *	Cubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n	function ( v0, v1, v2, v3 ) {\r\n\r\n		this.v0 = v0;\r\n		this.v1 = v1;\r\n		this.v2 = v2;\r\n		this.v3 = v3;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );\r\n		vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );\r\n		vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *	Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n	function ( points /* array of Vector3 */) {\r\n\r\n		this.points = ( points == undefined ) ? [] : points;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var points = this.points;\r\n		var point = ( points.length - 1 ) * t;\r\n\r\n		var intPoint = Math.floor( point );\r\n		var weight = point - intPoint;\r\n\r\n		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n		var point1 = points[ intPoint ];\r\n		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *	Closed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = THREE.Curve.create(\r\n\r\n	function ( points /* array of Vector3 */) {\r\n\r\n		this.points = ( points == undefined ) ? [] : points;\r\n\r\n	},\r\n\r\n	function ( t ) {\r\n\r\n		var points = this.points;\r\n		var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1\r\n\r\n		var intPoint = Math.floor( point );\r\n		var weight = point - intPoint;\r\n\r\n		intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n		var point0 = points[ ( intPoint - 1 ) % points.length ];\r\n		var point1 = points[ ( intPoint     ) % points.length ];\r\n		var point2 = points[ ( intPoint + 1 ) % points.length ];\r\n		var point3 = points[ ( intPoint + 2 ) % points.length ];\r\n\r\n		var vector = new THREE.Vector3();\r\n\r\n		vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );\r\n		vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );\r\n		vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );\r\n\r\n		return vector;\r\n\r\n	}\r\n\r\n);\r\n\r\n// File:src/extras/animation/AnimationHandler.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\nTHREE.AnimationHandler = {\r\n\r\n	LINEAR: 0,\r\n	CATMULLROM: 1,\r\n	CATMULLROM_FORWARD: 2,\r\n\r\n	//\r\n\r\n	add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },\r\n	get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },\r\n	remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },\r\n\r\n	//\r\n\r\n	animations: [],\r\n\r\n	init: function ( data ) {\r\n\r\n		if ( data.initialized === true ) return data;\r\n\r\n		// loop through all keys\r\n\r\n		for ( var h = 0; h < data.hierarchy.length; h ++ ) {\r\n\r\n			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n				// remove minus times\r\n\r\n				if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {\r\n\r\n					 data.hierarchy[ h ].keys[ k ].time = 0;\r\n\r\n				}\r\n\r\n				// create quaternions\r\n\r\n				if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&\r\n				  ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {\r\n\r\n					var quat = data.hierarchy[ h ].keys[ k ].rot;\r\n					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			// prepare morph target keys\r\n\r\n			if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {\r\n\r\n				// get all used\r\n\r\n				var usedMorphTargets = {};\r\n\r\n				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];\r\n						usedMorphTargets[ morphTargetName ] = - 1;\r\n\r\n					}\r\n\r\n				}\r\n\r\n				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;\r\n\r\n\r\n				// set all used on all frames\r\n\r\n				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n					var influences = {};\r\n\r\n					for ( var morphTargetName in usedMorphTargets ) {\r\n\r\n						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {\r\n\r\n							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {\r\n\r\n								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];\r\n								break;\r\n\r\n							}\r\n\r\n						}\r\n\r\n						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {\r\n\r\n							influences[ morphTargetName ] = 0;\r\n\r\n						}\r\n\r\n					}\r\n\r\n					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;\r\n\r\n				}\r\n\r\n			}\r\n\r\n\r\n			// remove all keys that are on the same time\r\n\r\n			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {\r\n\r\n					data.hierarchy[ h ].keys.splice( k, 1 );\r\n					k --;\r\n\r\n				}\r\n\r\n			}\r\n\r\n\r\n			// set index\r\n\r\n			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {\r\n\r\n				data.hierarchy[ h ].keys[ k ].index = k;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		data.initialized = true;\r\n\r\n		return data;\r\n\r\n	},\r\n\r\n	parse: function ( root ) {\r\n\r\n		var parseRecurseHierarchy = function ( root, hierarchy ) {\r\n\r\n			hierarchy.push( root );\r\n\r\n			for ( var c = 0; c < root.children.length; c ++ )\r\n				parseRecurseHierarchy( root.children[ c ], hierarchy );\r\n\r\n		};\r\n\r\n		// setup hierarchy\r\n\r\n		var hierarchy = [];\r\n\r\n		if ( root instanceof THREE.SkinnedMesh ) {\r\n\r\n			for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {\r\n\r\n				hierarchy.push( root.skeleton.bones[ b ] );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			parseRecurseHierarchy( root, hierarchy );\r\n\r\n		}\r\n\r\n		return hierarchy;\r\n\r\n	},\r\n\r\n	play: function ( animation ) {\r\n\r\n		if ( this.animations.indexOf( animation ) === - 1 ) {\r\n\r\n			this.animations.push( animation );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	stop: function ( animation ) {\r\n\r\n		var index = this.animations.indexOf( animation );\r\n\r\n		if ( index !== - 1 ) {\r\n\r\n			this.animations.splice( index, 1 );\r\n\r\n		}\r\n\r\n	},\r\n\r\n	update: function ( deltaTimeMS ) {\r\n\r\n		for ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n			this.animations[ i ].resetBlendWeights( );\r\n\r\n		}\r\n\r\n		for ( var i = 0; i < this.animations.length; i ++ ) {\r\n\r\n			this.animations[ i ].update( deltaTimeMS );\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/animation/Animation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Animation = function ( root, data ) {\r\n\r\n	this.root = root;\r\n	this.data = THREE.AnimationHandler.init( data );\r\n	this.hierarchy = THREE.AnimationHandler.parse( root );\r\n\r\n	this.currentTime = 0;\r\n	this.timeScale = 1;\r\n\r\n	this.isPlaying = false;\r\n	this.loop = true;\r\n	this.weight = 0;\r\n\r\n	this.interpolationType = THREE.AnimationHandler.LINEAR;\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.keyTypes = [ \"pos\", \"rot\", \"scl\" ];\r\n\r\n\r\nTHREE.Animation.prototype.play = function ( startTime, weight ) {\r\n\r\n	this.currentTime = startTime !== undefined ? startTime : 0;\r\n	this.weight = weight !== undefined ? weight: 1;\r\n\r\n	this.isPlaying = true;\r\n\r\n	this.reset();\r\n\r\n	THREE.AnimationHandler.play( this );\r\n\r\n};\r\n\r\n\r\nTHREE.Animation.prototype.stop = function() {\r\n\r\n	this.isPlaying = false;\r\n\r\n	THREE.AnimationHandler.stop( this );\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.reset = function () {\r\n\r\n	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n		var object = this.hierarchy[ h ];\r\n\r\n		if ( object.animationCache === undefined ) {\r\n\r\n			object.animationCache = {\r\n				animations: {},\r\n				blending: {\r\n					positionWeight: 0.0,\r\n					quaternionWeight: 0.0,\r\n					scaleWeight: 0.0\r\n				}\r\n			};\r\n		}\r\n\r\n		if ( object.animationCache.animations[this.data.name] === undefined ) {\r\n\r\n			object.animationCache.animations[this.data.name] = {};\r\n			object.animationCache.animations[this.data.name].prevKey = { pos: 0, rot: 0, scl: 0 };\r\n			object.animationCache.animations[this.data.name].nextKey = { pos: 0, rot: 0, scl: 0 };\r\n			object.animationCache.animations[this.data.name].originalMatrix = object.matrix;\r\n\r\n		}\r\n\r\n		var animationCache = object.animationCache.animations[this.data.name];\r\n\r\n		// Get keys to match our current time\r\n\r\n		for ( var t = 0; t < 3; t ++ ) {\r\n\r\n			var type = this.keyTypes[ t ];\r\n\r\n			var prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n			var nextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n			while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n				prevKey = nextKey;\r\n				nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n			}\r\n\r\n			animationCache.prevKey[ type ] = prevKey;\r\n			animationCache.nextKey[ type ] = nextKey;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.resetBlendWeights = function () {\r\n\r\n	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n		var object = this.hierarchy[ h ];\r\n\r\n		if ( object.animationCache !== undefined ) {\r\n\r\n			object.animationCache.blending.positionWeight = 0.0;\r\n			object.animationCache.blending.quaternionWeight = 0.0;\r\n			object.animationCache.blending.scaleWeight = 0.0;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.Animation.prototype.update = (function(){\r\n\r\n	var points = [];\r\n	var target = new THREE.Vector3();\r\n	var newVector = new THREE.Vector3();\r\n	var newQuat = new THREE.Quaternion();\r\n\r\n	// Catmull-Rom spline\r\n\r\n	var interpolateCatmullRom = function ( points, scale ) {\r\n\r\n		var c = [], v3 = [],\r\n		point, intPoint, weight, w2, w3,\r\n		pa, pb, pc, pd;\r\n\r\n		point = ( points.length - 1 ) * scale;\r\n		intPoint = Math.floor( point );\r\n		weight = point - intPoint;\r\n\r\n		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n		c[ 1 ] = intPoint;\r\n		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;\r\n		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;\r\n\r\n		pa = points[ c[ 0 ] ];\r\n		pb = points[ c[ 1 ] ];\r\n		pc = points[ c[ 2 ] ];\r\n		pd = points[ c[ 3 ] ];\r\n\r\n		w2 = weight * weight;\r\n		w3 = weight * w2;\r\n\r\n		v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );\r\n		v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );\r\n		v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );\r\n\r\n		return v3;\r\n\r\n	};\r\n\r\n	var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n		var v0 = ( p2 - p0 ) * 0.5,\r\n			v1 = ( p3 - p1 ) * 0.5;\r\n\r\n		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n	};\r\n\r\n	return function ( delta ) {\r\n\r\n		if ( this.isPlaying === false ) return;\r\n\r\n		this.currentTime += delta * this.timeScale;\r\n\r\n		if ( this.weight === 0 )\r\n			return;\r\n\r\n		//\r\n\r\n		var duration = this.data.length;\r\n\r\n		if ( this.currentTime > duration || this.currentTime < 0 ) {\r\n\r\n			if ( this.loop ) {\r\n\r\n				this.currentTime %= duration;\r\n\r\n				if ( this.currentTime < 0 )\r\n					this.currentTime += duration;\r\n\r\n				this.reset();\r\n\r\n			} else {\r\n\r\n				this.stop();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n			var object = this.hierarchy[ h ];\r\n			var animationCache = object.animationCache.animations[this.data.name];\r\n			var blending = object.animationCache.blending;\r\n\r\n			// loop through pos/rot/scl\r\n\r\n			for ( var t = 0; t < 3; t ++ ) {\r\n\r\n				// get keys\r\n\r\n				var type    = this.keyTypes[ t ];\r\n				var prevKey = animationCache.prevKey[ type ];\r\n				var nextKey = animationCache.nextKey[ type ];\r\n\r\n				if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||\r\n					( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {\r\n\r\n					prevKey = this.data.hierarchy[ h ].keys[ 0 ];\r\n					nextKey = this.getNextKeyWith( type, h, 1 );\r\n\r\n					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n						prevKey = nextKey;\r\n						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );\r\n\r\n					}\r\n\r\n					animationCache.prevKey[ type ] = prevKey;\r\n					animationCache.nextKey[ type ] = nextKey;\r\n\r\n				}\r\n\r\n				var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );\r\n\r\n				var prevXYZ = prevKey[ type ];\r\n				var nextXYZ = nextKey[ type ];\r\n\r\n				if ( scale < 0 ) scale = 0;\r\n				if ( scale > 1 ) scale = 1;\r\n\r\n				// interpolate\r\n\r\n				if ( type === \"pos\" ) {\r\n\r\n					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {\r\n\r\n						newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n						newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n						newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n						// blend\r\n						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n						object.position.lerp( newVector, proportionalWeight );\r\n						blending.positionWeight += this.weight;\r\n\r\n					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n								this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n						points[ 0 ] = this.getPrevKeyWith( \"pos\", h, prevKey.index - 1 )[ \"pos\" ];\r\n						points[ 1 ] = prevXYZ;\r\n						points[ 2 ] = nextXYZ;\r\n						points[ 3 ] = this.getNextKeyWith( \"pos\", h, nextKey.index + 1 )[ \"pos\" ];\r\n\r\n						scale = scale * 0.33 + 0.33;\r\n\r\n						var currentPoint = interpolateCatmullRom( points, scale );\r\n						var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );\r\n						blending.positionWeight += this.weight;\r\n\r\n						// blend\r\n\r\n						var vector = object.position;\r\n						\r\n						vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;\r\n						vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;\r\n						vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;\r\n\r\n						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n							var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );\r\n\r\n							target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );\r\n							target.sub( vector );\r\n							target.y = 0;\r\n							target.normalize();\r\n\r\n							var angle = Math.atan2( target.x, target.z );\r\n							object.rotation.set( 0, angle, 0 );\r\n\r\n						}\r\n\r\n					}\r\n\r\n				} else if ( type === \"rot\" ) {\r\n\r\n					THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );\r\n\r\n					// Avoid paying the cost of an additional slerp if we don't have to\r\n					if ( blending.quaternionWeight === 0 ) {\r\n\r\n						object.quaternion.copy(newQuat);\r\n						blending.quaternionWeight = this.weight;\r\n\r\n					} else {\r\n\r\n						var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );\r\n						THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );\r\n						blending.quaternionWeight += this.weight;\r\n\r\n					}\r\n\r\n				} else if ( type === \"scl\" ) {\r\n\r\n					newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;\r\n					newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;\r\n					newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;\r\n\r\n					var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );\r\n					object.scale.lerp( newVector, proportionalWeight );\r\n					blending.scaleWeight += this.weight;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		return true;\r\n\r\n	};\r\n\r\n})();\r\n\r\n\r\n\r\n\r\n\r\n// Get next key with\r\n\r\nTHREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {\r\n\r\n	var keys = this.data.hierarchy[ h ].keys;\r\n\r\n	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n		key = key < keys.length - 1 ? key : keys.length - 1;\r\n\r\n	} else {\r\n\r\n		key = key % keys.length;\r\n\r\n	}\r\n\r\n	for ( ; key < keys.length; key ++ ) {\r\n\r\n		if ( keys[ key ][ type ] !== undefined ) {\r\n\r\n			return keys[ key ];\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return this.data.hierarchy[ h ].keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {\r\n\r\n	var keys = this.data.hierarchy[ h ].keys;\r\n\r\n	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||\r\n		this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {\r\n\r\n		key = key > 0 ? key : 0;\r\n\r\n	} else {\r\n\r\n		key = key >= 0 ? key : key + keys.length;\r\n\r\n	}\r\n\r\n\r\n	for ( ; key >= 0; key -- ) {\r\n\r\n		if ( keys[ key ][ type ] !== undefined ) {\r\n\r\n			return keys[ key ];\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];\r\n\r\n};\r\n\r\n// File:src/extras/animation/KeyFrameAnimation.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author khang duong\r\n * @author erik kitson\r\n */\r\n\r\nTHREE.KeyFrameAnimation = function ( data ) {\r\n\r\n	this.root = data.node;\r\n	this.data = THREE.AnimationHandler.init( data );\r\n	this.hierarchy = THREE.AnimationHandler.parse( this.root );\r\n	this.currentTime = 0;\r\n	this.timeScale = 0.001;\r\n	this.isPlaying = false;\r\n	this.isPaused = true;\r\n	this.loop = true;\r\n\r\n	// initialize to first keyframes\r\n\r\n	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n		var keys = this.data.hierarchy[h].keys,\r\n			sids = this.data.hierarchy[h].sids,\r\n			obj = this.hierarchy[h];\r\n\r\n		if ( keys.length && sids ) {\r\n\r\n			for ( var s = 0; s < sids.length; s ++ ) {\r\n\r\n				var sid = sids[ s ],\r\n					next = this.getNextKeyWith( sid, h, 0 );\r\n\r\n				if ( next ) {\r\n\r\n					next.apply( sid );\r\n\r\n				}\r\n\r\n			}\r\n\r\n			obj.matrixAutoUpdate = false;\r\n			this.data.hierarchy[h].node.updateMatrix();\r\n			obj.matrixWorldNeedsUpdate = true;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\nTHREE.KeyFrameAnimation.prototype.play = function ( startTime ) {\r\n\r\n	this.currentTime = startTime !== undefined ? startTime : 0;\r\n\r\n	if ( this.isPlaying === false ) {\r\n\r\n		this.isPlaying = true;\r\n\r\n		// reset key cache\r\n\r\n		var h, hl = this.hierarchy.length,\r\n			object,\r\n			node;\r\n\r\n		for ( h = 0; h < hl; h ++ ) {\r\n\r\n			object = this.hierarchy[ h ];\r\n			node = this.data.hierarchy[ h ];\r\n\r\n			if ( node.animationCache === undefined ) {\r\n\r\n				node.animationCache = {};\r\n				node.animationCache.prevKey = null;\r\n				node.animationCache.nextKey = null;\r\n				node.animationCache.originalMatrix = object.matrix;\r\n\r\n			}\r\n\r\n			var keys = this.data.hierarchy[h].keys;\r\n\r\n			if (keys.length) {\r\n\r\n				node.animationCache.prevKey = keys[ 0 ];\r\n				node.animationCache.nextKey = keys[ 1 ];\r\n\r\n				this.startTime = Math.min( keys[0].time, this.startTime );\r\n				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.update( 0 );\r\n\r\n	}\r\n\r\n	this.isPaused = false;\r\n\r\n	THREE.AnimationHandler.play( this );\r\n\r\n};\r\n\r\n\r\nTHREE.KeyFrameAnimation.prototype.stop = function() {\r\n\r\n	this.isPlaying = false;\r\n	this.isPaused  = false;\r\n\r\n	THREE.AnimationHandler.stop( this );\r\n\r\n	// reset JIT matrix and remove cache\r\n\r\n	for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {\r\n		\r\n		var obj = this.hierarchy[ h ];\r\n		var node = this.data.hierarchy[ h ];\r\n\r\n		if ( node.animationCache !== undefined ) {\r\n\r\n			var original = node.animationCache.originalMatrix;\r\n\r\n			original.copy( obj.matrix );\r\n			obj.matrix = original;\r\n\r\n			delete node.animationCache;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// Update\r\n\r\nTHREE.KeyFrameAnimation.prototype.update = function ( delta ) {\r\n\r\n	if ( this.isPlaying === false ) return;\r\n\r\n	this.currentTime += delta * this.timeScale;\r\n\r\n	//\r\n\r\n	var duration = this.data.length;\r\n\r\n	if ( this.loop === true && this.currentTime > duration ) {\r\n\r\n		this.currentTime %= duration;\r\n\r\n	}\r\n\r\n	this.currentTime = Math.min( this.currentTime, duration );\r\n\r\n	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {\r\n\r\n		var object = this.hierarchy[ h ];\r\n		var node = this.data.hierarchy[ h ];\r\n\r\n		var keys = node.keys,\r\n			animationCache = node.animationCache;\r\n\r\n\r\n		if ( keys.length ) {\r\n\r\n			var prevKey = animationCache.prevKey;\r\n			var nextKey = animationCache.nextKey;\r\n\r\n			if ( nextKey.time <= this.currentTime ) {\r\n\r\n				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {\r\n\r\n					prevKey = nextKey;\r\n					nextKey = keys[ prevKey.index + 1 ];\r\n\r\n				}\r\n\r\n				animationCache.prevKey = prevKey;\r\n				animationCache.nextKey = nextKey;\r\n\r\n			}\r\n\r\n			if ( nextKey.time >= this.currentTime ) {\r\n\r\n				prevKey.interpolate( nextKey, this.currentTime );\r\n\r\n			} else {\r\n\r\n				prevKey.interpolate( nextKey, nextKey.time );\r\n\r\n			}\r\n\r\n			this.data.hierarchy[ h ].node.updateMatrix();\r\n			object.matrixWorldNeedsUpdate = true;\r\n\r\n		}\r\n\r\n	}\r\n\r\n};\r\n\r\n// Get next key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {\r\n\r\n	var keys = this.data.hierarchy[ h ].keys;\r\n	key = key % keys.length;\r\n\r\n	for ( ; key < keys.length; key ++ ) {\r\n\r\n		if ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n			return keys[ key ];\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return keys[ 0 ];\r\n\r\n};\r\n\r\n// Get previous key with\r\n\r\nTHREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {\r\n\r\n	var keys = this.data.hierarchy[ h ].keys;\r\n	key = key >= 0 ? key : key + keys.length;\r\n\r\n	for ( ; key >= 0; key -- ) {\r\n\r\n		if ( keys[ key ].hasTarget( sid ) ) {\r\n\r\n			return keys[ key ];\r\n\r\n		}\r\n\r\n	}\r\n\r\n	return keys[ keys.length - 1 ];\r\n\r\n};\r\n\r\n// File:src/extras/animation/MorphAnimation.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com\r\n * @author willy-vvu / http://willy-vvu.github.io\r\n */\r\n\r\nTHREE.MorphAnimation = function ( mesh ) {\r\n\r\n	this.mesh = mesh;\r\n	this.frames = mesh.morphTargetInfluences.length;\r\n	this.currentTime = 0;\r\n	this.duration = 1000;\r\n	this.loop = true;\r\n	this.lastFrame = 0;\r\n	this.currentFrame = 0;\r\n\r\n	this.isPlaying = false;\r\n\r\n};\r\n\r\nTHREE.MorphAnimation.prototype = {\r\n\r\n	constructor: THREE.MorphAnimation,\r\n\r\n	play: function () {\r\n\r\n		this.isPlaying = true;\r\n\r\n	},\r\n\r\n	pause: function () {\r\n\r\n		this.isPlaying = false;\r\n\r\n	},\r\n\r\n	update: function ( delta ) {\r\n\r\n		if ( this.isPlaying === false ) return;\r\n\r\n		this.currentTime += delta;\r\n\r\n		if ( this.loop === true && this.currentTime > this.duration ) {\r\n\r\n			this.currentTime %= this.duration;\r\n\r\n		}\r\n\r\n		this.currentTime = Math.min( this.currentTime, this.duration );\r\n\r\n		var interpolation = this.duration / this.frames;\r\n		var frame = Math.floor( this.currentTime / interpolation );\r\n\r\n		if ( frame != this.currentFrame ) {\r\n\r\n			this.mesh.morphTargetInfluences[ this.lastFrame ] = 0;\r\n			this.mesh.morphTargetInfluences[ this.currentFrame ] = 1;\r\n			this.mesh.morphTargetInfluences[ frame ] = 0;\r\n\r\n			this.lastFrame = this.currentFrame;\r\n			this.currentFrame = frame;\r\n\r\n		}\r\n\r\n		this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;\r\n		this.mesh.morphTargetInfluences[ this.lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'BoxGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		depth: depth,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		depthSegments: depthSegments\r\n	};\r\n\r\n	this.widthSegments = widthSegments || 1;\r\n	this.heightSegments = heightSegments || 1;\r\n	this.depthSegments = depthSegments || 1;\r\n\r\n	var scope = this;\r\n\r\n	var width_half = width / 2;\r\n	var height_half = height / 2;\r\n	var depth_half = depth / 2;\r\n\r\n	buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half, 0 ); // px\r\n	buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half, 1 ); // nx\r\n	buildPlane( 'x', 'z',   1,   1, width, depth, height_half, 2 ); // py\r\n	buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half, 3 ); // ny\r\n	buildPlane( 'x', 'y',   1, - 1, width, height, depth_half, 4 ); // pz\r\n	buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half, 5 ); // nz\r\n\r\n	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {\r\n\r\n		var w, ix, iy,\r\n		gridX = scope.widthSegments,\r\n		gridY = scope.heightSegments,\r\n		width_half = width / 2,\r\n		height_half = height / 2,\r\n		offset = scope.vertices.length;\r\n\r\n		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {\r\n\r\n			w = 'z';\r\n\r\n		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {\r\n\r\n			w = 'y';\r\n			gridY = scope.depthSegments;\r\n\r\n		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {\r\n\r\n			w = 'x';\r\n			gridX = scope.depthSegments;\r\n\r\n		}\r\n\r\n		var gridX1 = gridX + 1,\r\n		gridY1 = gridY + 1,\r\n		segment_width = width / gridX,\r\n		segment_height = height / gridY,\r\n		normal = new THREE.Vector3();\r\n\r\n		normal[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n		for ( iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n			for ( ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n				var vector = new THREE.Vector3();\r\n				vector[ u ] = ( ix * segment_width - width_half ) * udir;\r\n				vector[ v ] = ( iy * segment_height - height_half ) * vdir;\r\n				vector[ w ] = depth;\r\n\r\n				scope.vertices.push( vector );\r\n\r\n			}\r\n\r\n		}\r\n\r\n		for ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n			for ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n				var a = ix + gridX1 * iy;\r\n				var b = ix + gridX1 * ( iy + 1 );\r\n				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n				var d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );\r\n				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );\r\n				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );\r\n				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );\r\n\r\n				var face = new THREE.Face3( a + offset, b + offset, d + offset );\r\n				face.normal.copy( normal );\r\n				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n				face.materialIndex = materialIndex;\r\n\r\n				scope.faces.push( face );\r\n				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n				face = new THREE.Face3( b + offset, c + offset, d + offset );\r\n				face.normal.copy( normal );\r\n				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );\r\n				face.materialIndex = materialIndex;\r\n\r\n				scope.faces.push( face );\r\n				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'CircleGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		segments: segments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radius = radius || 50;\r\n	segments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n	var i, uvs = [],\r\n	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );\r\n\r\n	this.vertices.push(center);\r\n	uvs.push( centerUV );\r\n\r\n	for ( i = 0; i <= segments; i ++ ) {\r\n\r\n		var vertex = new THREE.Vector3();\r\n		var segment = thetaStart + i / segments * thetaLength;\r\n\r\n		vertex.x = radius * Math.cos( segment );\r\n		vertex.y = radius * Math.sin( segment );\r\n\r\n		this.vertices.push( vertex );\r\n		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );\r\n\r\n	}\r\n\r\n	var n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n	for ( i = 1; i <= segments; i ++ ) {\r\n\r\n		this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );\r\n		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\n// File:src/extras/geometries/CubeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\nTHREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n	console.warn( 'THREE.CubeGeometry has been renamed to THREE.BoxGeometry.' );\r\n	return new THREE.BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments );\r\n\r\n };\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'CylinderGeometry';\r\n\r\n	this.parameters = {\r\n		radiusTop: radiusTop,\r\n		radiusBottom: radiusBottom,\r\n		height: height,\r\n		radialSegments: radialSegments,\r\n		heightSegments: heightSegments,\r\n		openEnded: openEnded,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	radiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n	height = height !== undefined ? height : 100;\r\n\r\n	radialSegments = radialSegments || 8;\r\n	heightSegments = heightSegments || 1;\r\n\r\n	openEnded = openEnded !== undefined ? openEnded : false;\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;\r\n\r\n	var heightHalf = height / 2;\r\n\r\n	var x, y, vertices = [], uvs = [];\r\n\r\n	for ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n		var verticesRow = [];\r\n		var uvsRow = [];\r\n\r\n		var v = y / heightSegments;\r\n		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n		for ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n			var u = x / radialSegments;\r\n\r\n			var vertex = new THREE.Vector3();\r\n			vertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n			vertex.y = - v * height + heightHalf;\r\n			vertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\r\n			this.vertices.push( vertex );\r\n\r\n			verticesRow.push( this.vertices.length - 1 );\r\n			uvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n		}\r\n\r\n		vertices.push( verticesRow );\r\n		uvs.push( uvsRow );\r\n\r\n	}\r\n\r\n	var tanTheta = ( radiusBottom - radiusTop ) / height;\r\n	var na, nb;\r\n\r\n	for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n		if ( radiusTop !== 0 ) {\r\n\r\n			na = this.vertices[ vertices[ 0 ][ x ] ].clone();\r\n			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();\r\n\r\n		} else {\r\n\r\n			na = this.vertices[ vertices[ 1 ][ x ] ].clone();\r\n			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();\r\n\r\n		}\r\n\r\n		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();\r\n		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();\r\n\r\n		for ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n			var v1 = vertices[ y ][ x ];\r\n			var v2 = vertices[ y + 1 ][ x ];\r\n			var v3 = vertices[ y + 1 ][ x + 1 ];\r\n			var v4 = vertices[ y ][ x + 1 ];\r\n\r\n			var n1 = na.clone();\r\n			var n2 = na.clone();\r\n			var n3 = nb.clone();\r\n			var n4 = nb.clone();\r\n\r\n			var uv1 = uvs[ y ][ x ].clone();\r\n			var uv2 = uvs[ y + 1 ][ x ].clone();\r\n			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();\r\n			var uv4 = uvs[ y ][ x + 1 ].clone();\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// top cap\r\n\r\n	if ( openEnded === false && radiusTop > 0 ) {\r\n\r\n		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );\r\n\r\n		for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ 0 ][ x ];\r\n			var v2 = vertices[ 0 ][ x + 1 ];\r\n			var v3 = this.vertices.length - 1;\r\n\r\n			var n1 = new THREE.Vector3( 0, 1, 0 );\r\n			var n2 = new THREE.Vector3( 0, 1, 0 );\r\n			var n3 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n			var uv1 = uvs[ 0 ][ x ].clone();\r\n			var uv2 = uvs[ 0 ][ x + 1 ].clone();\r\n			var uv3 = new THREE.Vector2( uv2.x, 0 );\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// bottom cap\r\n\r\n	if ( openEnded === false && radiusBottom > 0 ) {\r\n\r\n		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );\r\n\r\n		for ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ heightSegments ][ x + 1 ];\r\n			var v2 = vertices[ heightSegments ][ x ];\r\n			var v3 = this.vertices.length - 1;\r\n\r\n			var n1 = new THREE.Vector3( 0, - 1, 0 );\r\n			var n2 = new THREE.Vector3( 0, - 1, 0 );\r\n			var n3 = new THREE.Vector3( 0, - 1, 0 );\r\n\r\n			var uv1 = uvs[ heightSegments ][ x + 1 ].clone();\r\n			var uv2 = uvs[ heightSegments ][ x ].clone();\r\n			var uv3 = new THREE.Vector2( uv2.x, 1 );\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  material: <int> // material index for front and back faces\r\n *  extrudeMaterial: <int> // material index for extrusion and beveled faces\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n	if ( typeof( shapes ) === \"undefined\" ) {\r\n		shapes = [];\r\n		return;\r\n	}\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ExtrudeGeometry';\r\n\r\n	shapes = shapes instanceof Array ? shapes : [ shapes ];\r\n\r\n	this.addShapeList( shapes, options );\r\n\r\n	this.computeFaceNormals();\r\n\r\n	// can't really use automatic vertex normals\r\n	// as then front and back sides get smoothed too\r\n	// should do separate smoothing just for sides\r\n\r\n	//this.computeVertexNormals();\r\n\r\n	//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n	var sl = shapes.length;\r\n\r\n	for ( var s = 0; s < sl; s ++ ) {\r\n		var shape = shapes[ s ];\r\n		this.addShape( shape, options );\r\n	}\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n	var amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n	var steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n	var extrudePath = options.extrudePath;\r\n	var extrudePts, extrudeByPath = false;\r\n\r\n	var material = options.material;\r\n	var extrudeMaterial = options.extrudeMaterial;\r\n\r\n	// Use default WorldUVGenerator if no UV generators are specified.\r\n	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n	var splineTube, binormal, normal, position2;\r\n	if ( extrudePath ) {\r\n\r\n		extrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n		extrudeByPath = true;\r\n		bevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n		// SETUP TNB variables\r\n\r\n		// Reuse TNB from TubeGeomtry for now.\r\n		// TODO1 - have a .isClosed in spline?\r\n\r\n		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);\r\n\r\n		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n		binormal = new THREE.Vector3();\r\n		normal = new THREE.Vector3();\r\n		position2 = new THREE.Vector3();\r\n\r\n	}\r\n\r\n	// Safeguards if bevels are not enabled\r\n\r\n	if ( ! bevelEnabled ) {\r\n\r\n		bevelSegments = 0;\r\n		bevelThickness = 0;\r\n		bevelSize = 0;\r\n\r\n	}\r\n\r\n	// Variables initalization\r\n\r\n	var ahole, h, hl; // looping of holes\r\n	var scope = this;\r\n	var bevelPoints = [];\r\n\r\n	var shapesOffset = this.vertices.length;\r\n\r\n	var shapePoints = shape.extractPoints( curveSegments );\r\n\r\n	var vertices = shapePoints.shape;\r\n	var holes = shapePoints.holes;\r\n\r\n	var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;\r\n\r\n	if ( reverse ) {\r\n\r\n		vertices = vertices.reverse();\r\n\r\n		// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n\r\n			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {\r\n\r\n				holes[ h ] = ahole.reverse();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n	}\r\n\r\n\r\n	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );\r\n\r\n	/* Vertices */\r\n\r\n	var contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n		ahole = holes[ h ];\r\n\r\n		vertices = vertices.concat( ahole );\r\n\r\n	}\r\n\r\n\r\n	function scalePt2 ( pt, vec, size ) {\r\n\r\n		if ( ! vec ) console.log( \"die\" );\r\n\r\n		return vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n	}\r\n\r\n	var b, bs, t, z,\r\n		vert, vlen = vertices.length,\r\n		face, flen = faces.length,\r\n		cont, clen = contour.length;\r\n\r\n\r\n	// Find directions for point movement\r\n\r\n	var RAD_TO_DEGREES = 180 / Math.PI;\r\n\r\n\r\n	function getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n		var EPSILON = 0.0000000001;\r\n		\r\n		// computes for inPt the corresponding point inPt' on a new contour\r\n		//   shiftet by 1 unit (length of normalized vector) to the left\r\n		// if we walk along contour clockwise, this new contour is outside the old one\r\n		//\r\n		// inPt' is the intersection of the two lines parallel to the two\r\n		//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n		\r\n		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt\r\n\r\n		// good reading for geometry algorithms (here: line-line intersection)\r\n		// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n		\r\n		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n		\r\n		// check for colinear edges\r\n		var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n		\r\n		if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear\r\n			\r\n			// length of vectors for normalizing\r\n	\r\n			var v_prev_len = Math.sqrt( v_prev_lensq );\r\n			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n			\r\n			// shift adjacent points by unit vectors to the left\r\n	\r\n			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n			\r\n			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n	\r\n			// scaling factor for v_prev to intersection point\r\n	\r\n			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n	\r\n			// vector from inPt to intersection point\r\n	\r\n			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n	\r\n			// Don't normalize!, otherwise sharp corners become ugly\r\n			//  but prevent crazy spikes\r\n			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )\r\n			if ( v_trans_lensq <= 2 ) {\r\n				return	new THREE.Vector2( v_trans_x, v_trans_y );\r\n			} else {\r\n				shrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n			}\r\n			\r\n		} else {		// handle special case of colinear edges\r\n\r\n			var direction_eq = false;		// assumes: opposite\r\n			if ( v_prev_x > EPSILON ) {\r\n				if ( v_next_x > EPSILON ) { direction_eq = true; }\r\n			} else {\r\n				if ( v_prev_x < - EPSILON ) {\r\n					if ( v_next_x < - EPSILON ) { direction_eq = true; }\r\n				} else {\r\n					if ( Math.sign(v_prev_y) == Math.sign(v_next_y) ) { direction_eq = true; }\r\n				}\r\n			}\r\n\r\n			if ( direction_eq ) {\r\n				// console.log(\"Warning: lines are a straight sequence\");\r\n				v_trans_x = - v_prev_y;\r\n				v_trans_y =  v_prev_x;\r\n				shrink_by = Math.sqrt( v_prev_lensq );\r\n			} else {\r\n				// console.log(\"Warning: lines are a straight spike\");\r\n				v_trans_x = v_prev_x;\r\n				v_trans_y = v_prev_y;\r\n				shrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n			}\r\n\r\n		}\r\n\r\n		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n	}\r\n\r\n\r\n	var contourMovements = [];\r\n\r\n	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n		if ( j === il ) j = 0;\r\n		if ( k === il ) k = 0;\r\n\r\n		//  (j)---(i)---(k)\r\n		// console.log('i,j,k', i, j , k)\r\n\r\n		var pt_i = contour[ i ];\r\n		var pt_j = contour[ j ];\r\n		var pt_k = contour[ k ];\r\n\r\n		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n	}\r\n\r\n	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n	for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n		ahole = holes[ h ];\r\n\r\n		oneHoleMovements = [];\r\n\r\n		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n			if ( j === il ) j = 0;\r\n			if ( k === il ) k = 0;\r\n\r\n			//  (j)---(i)---(k)\r\n			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n		}\r\n\r\n		holesMovements.push( oneHoleMovements );\r\n		verticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n	}\r\n\r\n\r\n	// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n	for ( b = 0; b < bevelSegments; b ++ ) {\r\n	//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n		t = b / bevelSegments;\r\n		z = bevelThickness * ( 1 - t );\r\n\r\n		//z = bevelThickness * t;\r\n		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved\r\n		//bs = bevelSize * t ; // linear\r\n\r\n		// contract shape\r\n\r\n		for ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n			v( vert.x, vert.y,  - z );\r\n\r\n		}\r\n\r\n		// expand holes\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			oneHoleMovements = holesMovements[ h ];\r\n\r\n			for ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n				v( vert.x, vert.y,  - z );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	bs = bevelSize;\r\n\r\n	// Back facing vertices\r\n\r\n	for ( i = 0; i < vlen; i ++ ) {\r\n\r\n		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n		if ( ! extrudeByPath ) {\r\n\r\n			v( vert.x, vert.y, 0 );\r\n\r\n		} else {\r\n\r\n			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);\r\n			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);\r\n\r\n			position2.copy( extrudePts[0] ).add(normal).add(binormal);\r\n\r\n			v( position2.x, position2.y, position2.z );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// Add stepped vertices...\r\n	// Including front facing vertices\r\n\r\n	var s;\r\n\r\n	for ( s = 1; s <= steps; s ++ ) {\r\n\r\n		for ( i = 0; i < vlen; i ++ ) {\r\n\r\n			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n			if ( ! extrudeByPath ) {\r\n\r\n				v( vert.x, vert.y, amount / steps * s );\r\n\r\n			} else {\r\n\r\n				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );\r\n				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );\r\n\r\n				position2.copy( extrudePts[s] ).add( normal ).add( binormal );\r\n\r\n				v( position2.x, position2.y, position2.z );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Add bevel segments planes\r\n\r\n	//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n	for ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n		t = b / bevelSegments;\r\n		z = bevelThickness * ( 1 - t );\r\n		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;\r\n\r\n		// contract shape\r\n\r\n		for ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n			v( vert.x, vert.y,  amount + z );\r\n\r\n		}\r\n\r\n		// expand holes\r\n\r\n		for ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			oneHoleMovements = holesMovements[ h ];\r\n\r\n			for ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n				if ( ! extrudeByPath ) {\r\n\r\n					v( vert.x, vert.y,  amount + z );\r\n\r\n				} else {\r\n\r\n					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	/* Faces */\r\n\r\n	// Top and bottom faces\r\n\r\n	buildLidFaces();\r\n\r\n	// Sides faces\r\n\r\n	buildSideFaces();\r\n\r\n\r\n	/////  Internal functions\r\n\r\n	function buildLidFaces() {\r\n\r\n		if ( bevelEnabled ) {\r\n\r\n			var layer = 0 ; // steps + 1\r\n			var offset = vlen * layer;\r\n\r\n			// Bottom faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset );\r\n\r\n			}\r\n\r\n			layer = steps + bevelSegments * 2;\r\n			offset = vlen * layer;\r\n\r\n			// Top faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			// Bottom faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n			}\r\n\r\n			// Top faces\r\n\r\n			for ( i = 0; i < flen; i ++ ) {\r\n\r\n				face = faces[ i ];\r\n				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n			}\r\n		}\r\n\r\n	}\r\n\r\n	// Create faces for the z-sides of the shape\r\n\r\n	function buildSideFaces() {\r\n\r\n		var layeroffset = 0;\r\n		sidewalls( contour, layeroffset );\r\n		layeroffset += contour.length;\r\n\r\n		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {\r\n\r\n			ahole = holes[ h ];\r\n			sidewalls( ahole, layeroffset );\r\n\r\n			//, true\r\n			layeroffset += ahole.length;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	function sidewalls( contour, layeroffset ) {\r\n\r\n		var j, k;\r\n		i = contour.length;\r\n\r\n		while ( --i >= 0 ) {\r\n\r\n			j = i;\r\n			k = i - 1;\r\n			if ( k < 0 ) k = contour.length - 1;\r\n\r\n			//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n			var s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n			for ( s = 0; s < sl; s ++ ) {\r\n\r\n				var slen1 = vlen * s;\r\n				var slen2 = vlen * ( s + 1 );\r\n\r\n				var a = layeroffset + j + slen1,\r\n					b = layeroffset + k + slen1,\r\n					c = layeroffset + k + slen2,\r\n					d = layeroffset + j + slen2;\r\n\r\n				f4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n			}\r\n		}\r\n\r\n	}\r\n\r\n\r\n	function v( x, y, z ) {\r\n\r\n		scope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n	}\r\n\r\n	function f3( a, b, c ) {\r\n\r\n		a += shapesOffset;\r\n		b += shapesOffset;\r\n		c += shapesOffset;\r\n\r\n		// normal, color, material\r\n		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\r\n		var uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n 		scope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n	}\r\n\r\n	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n		a += shapesOffset;\r\n		b += shapesOffset;\r\n		c += shapesOffset;\r\n		d += shapesOffset;\r\n\r\n 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );\r\n 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );\r\n\r\n 		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n	generateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n		var vertices = geometry.vertices;\r\n\r\n		var a = vertices[ indexA ];\r\n		var b = vertices[ indexB ];\r\n		var c = vertices[ indexC ];\r\n\r\n		return [\r\n			new THREE.Vector2( a.x, a.y ),\r\n			new THREE.Vector2( b.x, b.y ),\r\n			new THREE.Vector2( c.x, c.y )\r\n		];\r\n\r\n	},\r\n\r\n	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n		var vertices = geometry.vertices;\r\n\r\n		var a = vertices[ indexA ];\r\n		var b = vertices[ indexB ];\r\n		var c = vertices[ indexC ];\r\n		var d = vertices[ indexD ];\r\n\r\n		if ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n			return [\r\n				new THREE.Vector2( a.x, 1 - a.z ),\r\n				new THREE.Vector2( b.x, 1 - b.z ),\r\n				new THREE.Vector2( c.x, 1 - c.z ),\r\n				new THREE.Vector2( d.x, 1 - d.z )\r\n			];\r\n		} else {\r\n			return [\r\n				new THREE.Vector2( a.y, 1 - a.z ),\r\n				new THREE.Vector2( b.y, 1 - b.z ),\r\n				new THREE.Vector2( c.y, 1 - c.z ),\r\n				new THREE.Vector2( d.y, 1 - d.z )\r\n			];\r\n		}\r\n	}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *	material: <int> // material index for front and back faces\r\n *	uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ShapeGeometry';\r\n\r\n	if ( shapes instanceof Array === false ) shapes = [ shapes ];\r\n\r\n	this.addShapeList( shapes, options );\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n	for ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n		this.addShape( shapes[ i ], options );\r\n\r\n	}\r\n\r\n	return this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n	if ( options === undefined ) options = {};\r\n	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n	var material = options.material;\r\n	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n	//\r\n\r\n	var i, l, hole, s;\r\n\r\n	var shapesOffset = this.vertices.length;\r\n	var shapePoints = shape.extractPoints( curveSegments );\r\n\r\n	var vertices = shapePoints.shape;\r\n	var holes = shapePoints.holes;\r\n\r\n	var reverse = ! THREE.Shape.Utils.isClockWise( vertices );\r\n\r\n	if ( reverse ) {\r\n\r\n		vertices = vertices.reverse();\r\n\r\n		// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n		for ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n			hole = holes[ i ];\r\n\r\n			if ( THREE.Shape.Utils.isClockWise( hole ) ) {\r\n\r\n				holes[ i ] = hole.reverse();\r\n\r\n			}\r\n\r\n		}\r\n\r\n		reverse = false;\r\n\r\n	}\r\n\r\n	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );\r\n\r\n	// Vertices\r\n\r\n	var contour = vertices;\r\n\r\n	for ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n		hole = holes[ i ];\r\n		vertices = vertices.concat( hole );\r\n\r\n	}\r\n\r\n	//\r\n\r\n	var vert, vlen = vertices.length;\r\n	var face, flen = faces.length;\r\n	var cont, clen = contour.length;\r\n\r\n	for ( i = 0; i < vlen; i ++ ) {\r\n\r\n		vert = vertices[ i ];\r\n\r\n		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n	}\r\n\r\n	for ( i = 0; i < flen; i ++ ) {\r\n\r\n		face = faces[ i ];\r\n\r\n		var a = face[ 0 ] + shapesOffset;\r\n		var b = face[ 1 ] + shapesOffset;\r\n		var c = face[ 2 ] + shapesOffset;\r\n\r\n		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n	}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points \r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2*PI) range of the lathed section\r\n//    2*pi is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'LatheGeometry';\r\n\r\n	this.parameters = {\r\n		points: points,\r\n		segments: segments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength\r\n	};\r\n\r\n	segments = segments || 12;\r\n	phiStart = phiStart || 0;\r\n	phiLength = phiLength || 2 * Math.PI;\r\n\r\n	var inversePointLength = 1.0 / ( points.length - 1 );\r\n	var inverseSegments = 1.0 / segments;\r\n\r\n	for ( var i = 0, il = segments; i <= il; i ++ ) {\r\n\r\n		var phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n		var c = Math.cos( phi ),\r\n			s = Math.sin( phi );\r\n\r\n		for ( var j = 0, jl = points.length; j < jl; j ++ ) {\r\n\r\n			var pt = points[ j ];\r\n\r\n			var vertex = new THREE.Vector3();\r\n\r\n			vertex.x = c * pt.x - s * pt.y;\r\n			vertex.y = s * pt.x + c * pt.y;\r\n			vertex.z = pt.z;\r\n\r\n			this.vertices.push( vertex );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var np = points.length;\r\n\r\n	for ( var i = 0, il = segments; i < il; i ++ ) {\r\n\r\n		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {\r\n\r\n			var base = j + np * i;\r\n			var a = base;\r\n			var b = base + np;\r\n			var c = base + 1 + np;\r\n			var d = base + 1;\r\n\r\n			var u0 = i * inverseSegments;\r\n			var v0 = j * inversePointLength;\r\n			var u1 = u0 + inverseSegments;\r\n			var v1 = v0 + inversePointLength;\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n\r\n			this.faceVertexUvs[ 0 ].push( [\r\n\r\n				new THREE.Vector2( u0, v0 ),\r\n				new THREE.Vector2( u1, v0 ),\r\n				new THREE.Vector2( u0, v1 )\r\n\r\n			] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n\r\n			this.faceVertexUvs[ 0 ].push( [\r\n\r\n				new THREE.Vector2( u1, v0 ),\r\n				new THREE.Vector2( u1, v1 ),\r\n				new THREE.Vector2( u0, v1 )\r\n\r\n			] );\r\n\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.mergeVertices();\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n	console.info( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'PlaneGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments\r\n	};\r\n\r\n	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n	THREE.BufferGeometry.call( this );\r\n\r\n	this.type = 'PlaneBufferGeometry';\r\n\r\n	this.parameters = {\r\n		width: width,\r\n		height: height,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments\r\n	};\r\n\r\n	var width_half = width / 2;\r\n	var height_half = height / 2;\r\n\r\n	var gridX = widthSegments || 1;\r\n	var gridY = heightSegments || 1;\r\n\r\n	var gridX1 = gridX + 1;\r\n	var gridY1 = gridY + 1;\r\n\r\n	var segment_width = width / gridX;\r\n	var segment_height = height / gridY;\r\n\r\n	var vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n	var normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n	var uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n	var offset = 0;\r\n	var offset2 = 0;\r\n\r\n	for ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n		var y = iy * segment_height - height_half;\r\n\r\n		for ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n			var x = ix * segment_width - width_half;\r\n\r\n			vertices[ offset     ] = x;\r\n			vertices[ offset + 1 ] = - y;\r\n\r\n			normals[ offset + 2 ] = 1;\r\n\r\n			uvs[ offset2     ] = ix / gridX;\r\n			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n			offset += 3;\r\n			offset2 += 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	offset = 0;\r\n\r\n	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n	for ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n		for ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n			var a = ix + gridX1 * iy;\r\n			var b = ix + gridX1 * ( iy + 1 );\r\n			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n			var d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n			indices[ offset     ] = a;\r\n			indices[ offset + 1 ] = b;\r\n			indices[ offset + 2 ] = d;\r\n\r\n			indices[ offset + 3 ] = b;\r\n			indices[ offset + 4 ] = c;\r\n			indices[ offset + 5 ] = d;\r\n\r\n			offset += 6;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );\r\n	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'RingGeometry';\r\n\r\n	this.parameters = {\r\n		innerRadius: innerRadius,\r\n		outerRadius: outerRadius,\r\n		thetaSegments: thetaSegments,\r\n		phiSegments: phiSegments,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength\r\n	};\r\n\r\n	innerRadius = innerRadius || 0;\r\n	outerRadius = outerRadius || 50;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;\r\n\r\n	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\r\n	for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring\r\n\r\n		for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle\r\n\r\n			var vertex = new THREE.Vector3();\r\n			var segment = thetaStart + o / thetaSegments * thetaLength;\r\n			vertex.x = radius * Math.cos( segment );\r\n			vertex.y = radius * Math.sin( segment );\r\n\r\n			this.vertices.push( vertex );\r\n			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );\r\n		}\r\n\r\n		radius += radiusStep;\r\n\r\n	}\r\n\r\n	var n = new THREE.Vector3( 0, 0, 1 );\r\n\r\n	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring\r\n\r\n		var thetaSegment = i * (thetaSegments + 1);\r\n\r\n		for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle\r\n\r\n			var segment = o + thetaSegment;\r\n\r\n			var v1 = segment;\r\n			var v2 = segment + thetaSegments + 1;\r\n			var v3 = segment + thetaSegments + 2;\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n			v1 = segment;\r\n			v2 = segment + thetaSegments + 2;\r\n			v3 = segment + 1;\r\n\r\n			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);\r\n\r\n		}\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'SphereGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		widthSegments: widthSegments,\r\n		heightSegments: heightSegments,\r\n		phiStart: phiStart,\r\n		phiLength: phiLength,\r\n		thetaStart: thetaStart,\r\n		thetaLength: thetaLength \r\n	};\r\n\r\n	radius = radius || 50;\r\n\r\n	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n	phiStart = phiStart !== undefined ? phiStart : 0;\r\n	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n	thetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n	var x, y, vertices = [], uvs = [];\r\n\r\n	for ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n		var verticesRow = [];\r\n		var uvsRow = [];\r\n\r\n		for ( x = 0; x <= widthSegments; x ++ ) {\r\n\r\n			var u = x / widthSegments;\r\n			var v = y / heightSegments;\r\n\r\n			var vertex = new THREE.Vector3();\r\n			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );\r\n			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n			this.vertices.push( vertex );\r\n\r\n			verticesRow.push( this.vertices.length - 1 );\r\n			uvsRow.push( new THREE.Vector2( u, 1 - v ) );\r\n\r\n		}\r\n\r\n		vertices.push( verticesRow );\r\n		uvs.push( uvsRow );\r\n\r\n	}\r\n\r\n	for ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n		for ( x = 0; x < widthSegments; x ++ ) {\r\n\r\n			var v1 = vertices[ y ][ x + 1 ];\r\n			var v2 = vertices[ y ][ x ];\r\n			var v3 = vertices[ y + 1 ][ x ];\r\n			var v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n			var n1 = this.vertices[ v1 ].clone().normalize();\r\n			var n2 = this.vertices[ v2 ].clone().normalize();\r\n			var n3 = this.vertices[ v3 ].clone().normalize();\r\n			var n4 = this.vertices[ v4 ].clone().normalize();\r\n\r\n			var uv1 = uvs[ y ][ x + 1 ].clone();\r\n			var uv2 = uvs[ y ][ x ].clone();\r\n			var uv3 = uvs[ y + 1 ][ x ].clone();\r\n			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();\r\n\r\n			if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {\r\n\r\n				uv1.x = ( uv1.x + uv2.x ) / 2;\r\n				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );\r\n				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );\r\n\r\n			} else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {\r\n\r\n				uv3.x = ( uv3.x + uv4.x ) / 2;\r\n				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );\r\n				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );\r\n\r\n			} else {\r\n\r\n				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );\r\n				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );\r\n\r\n				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );\r\n				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * For creating 3D text geometry in three.js\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  size: 			<float>, 	// size of the text\r\n *  height: 		<float>, 	// thickness to extrude text\r\n *  curveSegments: 	<int>,		// number of points on the curves\r\n *\r\n *  font: 			<string>,		// font name\r\n *  weight: 		<string>,		// font weight (normal, bold)\r\n *  style: 			<string>,		// font style  (normal, italics)\r\n *\r\n *  bevelEnabled:	<bool>,			// turn on bevel\r\n *  bevelThickness: <float>, 		// how deep into text bevel goes\r\n *  bevelSize:		<float>, 		// how far from text outline is bevel\r\n *  }\r\n *\r\n */\r\n\r\n/*	Usage Examples\r\n\r\n	// TextGeometry wrapper\r\n\r\n	var text3d = new TextGeometry( text, options );\r\n\r\n	// Complete manner\r\n\r\n	var textShapes = THREE.FontUtils.generateShapes( text, options );\r\n	var text3d = new ExtrudeGeometry( textShapes, options );\r\n\r\n*/\r\n\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n	parameters = parameters || {};\r\n\r\n	var textShapes = THREE.FontUtils.generateShapes( text, parameters );\r\n\r\n	// translate parameters to ExtrudeGeometry API\r\n\r\n	parameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n	// defaults\r\n\r\n	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n	THREE.ExtrudeGeometry.call( this, textShapes, parameters );\r\n\r\n	this.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TorusGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		tube: tube,\r\n		radialSegments: radialSegments,\r\n		tubularSegments: tubularSegments,\r\n		arc: arc\r\n	};\r\n\r\n	radius = radius || 100;\r\n	tube = tube || 40;\r\n	radialSegments = radialSegments || 8;\r\n	tubularSegments = tubularSegments || 6;\r\n	arc = arc || Math.PI * 2;\r\n\r\n	var center = new THREE.Vector3(), uvs = [], normals = [];\r\n\r\n	for ( var j = 0; j <= radialSegments; j ++ ) {\r\n\r\n		for ( var i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n			var u = i / tubularSegments * arc;\r\n			var v = j / radialSegments * Math.PI * 2;\r\n\r\n			center.x = radius * Math.cos( u );\r\n			center.y = radius * Math.sin( u );\r\n\r\n			var vertex = new THREE.Vector3();\r\n			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n			vertex.z = tube * Math.sin( v );\r\n\r\n			this.vertices.push( vertex );\r\n\r\n			uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );\r\n			normals.push( vertex.clone().sub( center ).normalize() );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var j = 1; j <= radialSegments; j ++ ) {\r\n\r\n		for ( var i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n			var a = ( tubularSegments + 1 ) * j + i - 1;\r\n			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n			var d = ( tubularSegments + 1 ) * j + i;\r\n\r\n			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );\r\n			this.faces.push( face );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );\r\n\r\n			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );\r\n			this.faces.push( face );\r\n			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TorusKnotGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		tube: tube,\r\n		radialSegments: radialSegments,\r\n		tubularSegments: tubularSegments,\r\n		p: p,\r\n		q: q,\r\n		heightScale: heightScale\r\n	};\r\n\r\n	radius = radius || 100;\r\n	tube = tube || 40;\r\n	radialSegments = radialSegments || 64;\r\n	tubularSegments = tubularSegments || 8;\r\n	p = p || 2;\r\n	q = q || 3;\r\n	heightScale = heightScale || 1;\r\n	\r\n	var grid = new Array( radialSegments );\r\n	var tang = new THREE.Vector3();\r\n	var n = new THREE.Vector3();\r\n	var bitan = new THREE.Vector3();\r\n\r\n	for ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n		grid[ i ] = new Array( tubularSegments );\r\n		var u = i / radialSegments * 2 * p * Math.PI;\r\n		var p1 = getPos( u, q, p, radius, heightScale );\r\n		var p2 = getPos( u + 0.01, q, p, radius, heightScale );\r\n		tang.subVectors( p2, p1 );\r\n		n.addVectors( p2, p1 );\r\n\r\n		bitan.crossVectors( tang, n );\r\n		n.crossVectors( bitan, tang );\r\n		bitan.normalize();\r\n		n.normalize();\r\n\r\n		for ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n			var v = j / tubularSegments * 2 * Math.PI;\r\n			var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n			var cy = tube * Math.sin( v );\r\n\r\n			var pos = new THREE.Vector3();\r\n			pos.x = p1.x + cx * n.x + cy * bitan.x;\r\n			pos.y = p1.y + cx * n.y + cy * bitan.y;\r\n			pos.z = p1.z + cx * n.z + cy * bitan.z;\r\n\r\n			grid[ i ][ j ] = this.vertices.push( pos ) - 1;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var i = 0; i < radialSegments; ++ i ) {\r\n\r\n		for ( var j = 0; j < tubularSegments; ++ j ) {\r\n\r\n			var ip = ( i + 1 ) % radialSegments;\r\n			var jp = ( j + 1 ) % tubularSegments;\r\n\r\n			var a = grid[ i ][ j ];\r\n			var b = grid[ ip ][ j ];\r\n			var c = grid[ ip ][ jp ];\r\n			var d = grid[ i ][ jp ];\r\n\r\n			var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );\r\n			var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );\r\n			var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );\r\n			var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n	function getPos( u, in_q, in_p, radius, heightScale ) {\r\n\r\n		var cu = Math.cos( u );\r\n		var su = Math.sin( u );\r\n		var quOverP = in_q / in_p * u;\r\n		var cs = Math.cos( quOverP );\r\n\r\n		var tx = radius * ( 2 + cs ) * 0.5 * cu;\r\n		var ty = radius * ( 2 + cs ) * su * 0.5;\r\n		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;\r\n\r\n		return new THREE.Vector3( tx, ty, tz );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'TubeGeometry';\r\n\r\n	this.parameters = {\r\n		path: path,\r\n		segments: segments,\r\n		radius: radius,\r\n		radialSegments: radialSegments,\r\n		closed: closed\r\n	};\r\n\r\n	segments = segments || 64;\r\n	radius = radius || 1;\r\n	radialSegments = radialSegments || 8;\r\n	closed = closed || false;\r\n	taper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n	var grid = [];\r\n\r\n	var scope = this,\r\n\r\n		tangent,\r\n		normal,\r\n		binormal,\r\n\r\n		numpoints = segments + 1,\r\n\r\n		x, y, z,\r\n		tx, ty, tz,\r\n		u, v, r,\r\n\r\n		cx, cy,\r\n		pos, pos2 = new THREE.Vector3(),\r\n		i, j,\r\n		ip, jp,\r\n		a, b, c, d,\r\n		uva, uvb, uvc, uvd;\r\n\r\n	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n		tangents = frames.tangents,\r\n		normals = frames.normals,\r\n		binormals = frames.binormals;\r\n\r\n	// proxy internals\r\n	this.tangents = tangents;\r\n	this.normals = normals;\r\n	this.binormals = binormals;\r\n\r\n	function vert( x, y, z ) {\r\n\r\n		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n	}\r\n\r\n	// consruct the grid\r\n\r\n	for ( i = 0; i < numpoints; i ++ ) {\r\n\r\n		grid[ i ] = [];\r\n\r\n		u = i / ( numpoints - 1 );\r\n\r\n		pos = path.getPointAt( u );\r\n\r\n		tangent = tangents[ i ];\r\n		normal = normals[ i ];\r\n		binormal = binormals[ i ];\r\n\r\n		r = radius * taper( u );\r\n\r\n		for ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n			v = j / radialSegments * 2 * Math.PI;\r\n\r\n			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n			cy = r * Math.sin( v );\r\n\r\n			pos2.copy( pos );\r\n			pos2.x += cx * normal.x + cy * binormal.x;\r\n			pos2.y += cx * normal.y + cy * binormal.y;\r\n			pos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n		}\r\n	}\r\n\r\n\r\n	// construct the mesh\r\n\r\n	for ( i = 0; i < segments; i ++ ) {\r\n\r\n		for ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n			ip = ( closed ) ? (i + 1) % segments : i + 1;\r\n			jp = (j + 1) % radialSegments;\r\n\r\n			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***\r\n			b = grid[ ip ][ j ];\r\n			c = grid[ ip ][ jp ];\r\n			d = grid[ i ][ jp ];\r\n\r\n			uva = new THREE.Vector2( i / segments, j / radialSegments );\r\n			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n			this.faces.push( new THREE.Face3( a, b, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n			this.faces.push( new THREE.Face3( b, c, d ) );\r\n			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n	}\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n	return 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n	return Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n	var	tangent = new THREE.Vector3(),\r\n		normal = new THREE.Vector3(),\r\n		binormal = new THREE.Vector3(),\r\n\r\n		tangents = [],\r\n		normals = [],\r\n		binormals = [],\r\n\r\n		vec = new THREE.Vector3(),\r\n		mat = new THREE.Matrix4(),\r\n\r\n		numpoints = segments + 1,\r\n		theta,\r\n		epsilon = 0.0001,\r\n		smallest,\r\n\r\n		tx, ty, tz,\r\n		i, u, v;\r\n\r\n\r\n	// expose internals\r\n	this.tangents = tangents;\r\n	this.normals = normals;\r\n	this.binormals = binormals;\r\n\r\n	// compute the tangent vectors for each segment on the path\r\n\r\n	for ( i = 0; i < numpoints; i ++ ) {\r\n\r\n		u = i / ( numpoints - 1 );\r\n\r\n		tangents[ i ] = path.getTangentAt( u );\r\n		tangents[ i ].normalize();\r\n\r\n	}\r\n\r\n	initialNormal3();\r\n\r\n	/*\r\n	function initialNormal1(lastBinormal) {\r\n		// fixed start binormal. Has dangers of 0 vectors\r\n		normals[ 0 ] = new THREE.Vector3();\r\n		binormals[ 0 ] = new THREE.Vector3();\r\n		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n	}\r\n\r\n	function initialNormal2() {\r\n\r\n		// This uses the Frenet-Serret formula for deriving binormal\r\n		var t2 = path.getTangentAt( epsilon );\r\n\r\n		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n	}\r\n	*/\r\n\r\n	function initialNormal3() {\r\n		// select an initial normal vector perpenicular to the first tangent vector,\r\n		// and in the direction of the smallest tangent xyz component\r\n\r\n		normals[ 0 ] = new THREE.Vector3();\r\n		binormals[ 0 ] = new THREE.Vector3();\r\n		smallest = Number.MAX_VALUE;\r\n		tx = Math.abs( tangents[ 0 ].x );\r\n		ty = Math.abs( tangents[ 0 ].y );\r\n		tz = Math.abs( tangents[ 0 ].z );\r\n\r\n		if ( tx <= smallest ) {\r\n			smallest = tx;\r\n			normal.set( 1, 0, 0 );\r\n		}\r\n\r\n		if ( ty <= smallest ) {\r\n			smallest = ty;\r\n			normal.set( 0, 1, 0 );\r\n		}\r\n\r\n		if ( tz <= smallest ) {\r\n			normal.set( 0, 0, 1 );\r\n		}\r\n\r\n		vec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n		normals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n	}\r\n\r\n\r\n	// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n	for ( i = 1; i < numpoints; i ++ ) {\r\n\r\n		normals[ i ] = normals[ i-1 ].clone();\r\n\r\n		binormals[ i ] = binormals[ i-1 ].clone();\r\n\r\n		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );\r\n\r\n		if ( vec.length() > epsilon ) {\r\n\r\n			vec.normalize();\r\n\r\n			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n		}\r\n\r\n		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n	}\r\n\r\n\r\n	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n	if ( closed ) {\r\n\r\n		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), - 1, 1 ) );\r\n		theta /= ( numpoints - 1 );\r\n\r\n		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {\r\n\r\n			theta = - theta;\r\n\r\n		}\r\n\r\n		for ( i = 1; i < numpoints; i ++ ) {\r\n\r\n			// twist a little...\r\n			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n		}\r\n\r\n	}\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'PolyhedronGeometry';\r\n\r\n	this.parameters = {\r\n		vertices: vertices,\r\n		indices: indices,\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n	radius = radius || 1;\r\n	detail = detail || 0;\r\n\r\n	var that = this;\r\n\r\n	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n	}\r\n\r\n	var midpoints = [], p = this.vertices;\r\n\r\n	var faces = [];\r\n\r\n	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n		var v1 = p[ indices[ i     ] ];\r\n		var v2 = p[ indices[ i + 1 ] ];\r\n		var v3 = p[ indices[ i + 2 ] ];\r\n\r\n		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n\r\n	}\r\n\r\n	var centroid = new THREE.Vector3();\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		subdivide( faces[ i ], detail );\r\n\r\n	}\r\n\r\n\r\n	// Handle case when face straddles the seam\r\n\r\n	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n		var uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n		var x0 = uvs[ 0 ].x;\r\n		var x1 = uvs[ 1 ].x;\r\n		var x2 = uvs[ 2 ].x;\r\n\r\n		var max = Math.max( x0, Math.max( x1, x2 ) );\r\n		var min = Math.min( x0, Math.min( x1, x2 ) );\r\n\r\n		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary\r\n\r\n			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Apply radius\r\n\r\n	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n		this.vertices[ i ].multiplyScalar( radius );\r\n\r\n	}\r\n\r\n\r\n	// Merge vertices\r\n\r\n	this.mergeVertices();\r\n\r\n	this.computeFaceNormals();\r\n\r\n	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n	// Project vector onto sphere's surface\r\n\r\n	function prepare( vector ) {\r\n\r\n		var vertex = vector.normalize().clone();\r\n		vertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n		var u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n		var v = inclination( vector ) / Math.PI + 0.5;\r\n		vertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n		return vertex;\r\n\r\n	}\r\n\r\n\r\n	// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n	function make( v1, v2, v3 ) {\r\n\r\n		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );\r\n		that.faces.push( face );\r\n\r\n		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n		var azi = azimuth( centroid );\r\n\r\n		that.faceVertexUvs[ 0 ].push( [\r\n			correctUV( v1.uv, v1, azi ),\r\n			correctUV( v2.uv, v2, azi ),\r\n			correctUV( v3.uv, v3, azi )\r\n		] );\r\n\r\n	}\r\n\r\n\r\n	// Analytically subdivide a face to the required detail level.\r\n\r\n	function subdivide( face, detail ) {\r\n\r\n		var cols = Math.pow(2, detail);\r\n		var cells = Math.pow(4, detail);\r\n		var a = prepare( that.vertices[ face.a ] );\r\n		var b = prepare( that.vertices[ face.b ] );\r\n		var c = prepare( that.vertices[ face.c ] );\r\n		var v = [];\r\n\r\n		// Construct all of the vertices for this subdivision.\r\n\r\n		for ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n			v[ i ] = [];\r\n\r\n			var aj = prepare( a.clone().lerp( c, i / cols ) );\r\n			var bj = prepare( b.clone().lerp( c, i / cols ) );\r\n			var rows = cols - i;\r\n\r\n			for ( var j = 0; j <= rows; j ++) {\r\n\r\n				if ( j == 0 && i == cols ) {\r\n\r\n					v[ i ][ j ] = aj;\r\n\r\n				} else {\r\n\r\n					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		// Construct all of the faces.\r\n\r\n		for ( var i = 0; i < cols ; i ++ ) {\r\n\r\n			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {\r\n\r\n				var k = Math.floor( j / 2 );\r\n\r\n				if ( j % 2 == 0 ) {\r\n\r\n					make(\r\n						v[ i ][ k + 1],\r\n						v[ i + 1 ][ k ],\r\n						v[ i ][ k ]\r\n					);\r\n\r\n				} else {\r\n\r\n					make(\r\n						v[ i ][ k + 1 ],\r\n						v[ i + 1][ k + 1],\r\n						v[ i + 1 ][ k ]\r\n					);\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n\r\n	// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n	function azimuth( vector ) {\r\n\r\n		return Math.atan2( vector.z, - vector.x );\r\n\r\n	}\r\n\r\n\r\n	// Angle above the XZ plane.\r\n\r\n	function inclination( vector ) {\r\n\r\n		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n	}\r\n\r\n\r\n	// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n	function correctUV( uv, vector, azimuth ) {\r\n\r\n		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n		return uv.clone();\r\n\r\n	}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n	var t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n	var r = 1 / t;\r\n\r\n	var vertices = [\r\n\r\n		// (±1, ±1, ±1)\r\n		-1, -1, -1,    -1, -1,  1,\r\n		-1,  1, -1,    -1,  1,  1,\r\n		 1, -1, -1,     1, -1,  1,\r\n		 1,  1, -1,     1,  1,  1,\r\n\r\n		// (0, ±1/φ, ±φ)\r\n		 0, -r, -t,     0, -r,  t,\r\n		 0,  r, -t,     0,  r,  t,\r\n\r\n		// (±1/φ, ±φ, 0)\r\n		-r, -t,  0,    -r,  t,  0,\r\n		 r, -t,  0,     r,  t,  0,\r\n\r\n		// (±φ, 0, ±1/φ)\r\n		-t,  0, -r,     t,  0, -r,\r\n		-t,  0,  r,     t,  0,  r\r\n	];\r\n\r\n	var indices = [\r\n		 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n		 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n		17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n		 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n		 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n		 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n		 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n		18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n		 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n		11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n		19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n		 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n	var t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n	var vertices = [\r\n		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n	];\r\n\r\n	var indices = [\r\n		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'IcosahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n	var vertices = [\r\n		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1\r\n	];\r\n\r\n	var indices = [\r\n		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'OctahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n	var vertices = [\r\n		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n	];\r\n\r\n	var indices = [\r\n		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n	];\r\n\r\n	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n	this.type = 'TetrahedronGeometry';\r\n\r\n	this.parameters = {\r\n		radius: radius,\r\n		detail: detail\r\n	};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n	THREE.Geometry.call( this );\r\n\r\n	this.type = 'ParametricGeometry';\r\n\r\n	this.parameters = {\r\n		func: func,\r\n		slices: slices,\r\n		stacks: stacks\r\n	};\r\n\r\n	var verts = this.vertices;\r\n	var faces = this.faces;\r\n	var uvs = this.faceVertexUvs[ 0 ];\r\n\r\n	var i, il, j, p;\r\n	var u, v;\r\n\r\n	var stackCount = stacks + 1;\r\n	var sliceCount = slices + 1;\r\n\r\n	for ( i = 0; i <= stacks; i ++ ) {\r\n\r\n		v = i / stacks;\r\n\r\n		for ( j = 0; j <= slices; j ++ ) {\r\n\r\n			u = j / slices;\r\n\r\n			p = func( u, v );\r\n			verts.push( p );\r\n\r\n		}\r\n	}\r\n\r\n	var a, b, c, d;\r\n	var uva, uvb, uvc, uvd;\r\n\r\n	for ( i = 0; i < stacks; i ++ ) {\r\n\r\n		for ( j = 0; j < slices; j ++ ) {\r\n\r\n			a = i * sliceCount + j;\r\n			b = i * sliceCount + j + 1;\r\n			c = (i + 1) * sliceCount + j + 1;\r\n			d = (i + 1) * sliceCount + j;\r\n\r\n			uva = new THREE.Vector2( j / slices, i / stacks );\r\n			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n			faces.push( new THREE.Face3( a, b, d ) );\r\n			uvs.push( [ uva, uvb, uvd ] );\r\n\r\n			faces.push( new THREE.Face3( b, c, d ) );\r\n			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	// console.log(this);\r\n\r\n	// magic bullet\r\n	// var diff = this.mergeVertices();\r\n	// console.log('removed ', diff, ' vertices by merging');\r\n\r\n	this.computeFaceNormals();\r\n	this.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n	size = size || 1;\r\n\r\n	var vertices = new Float32Array( [\r\n		0, 0, 0,  size, 0, 0,\r\n		0, 0, 0,  0, size, 0,\r\n		0, 0, 0,  0, 0, size\r\n	] );\r\n\r\n	var colors = new Float32Array( [\r\n		1, 0, 0,  1, 0.6, 0,\r\n		0, 1, 0,  0.6, 1, 0,\r\n		0, 0, 1,  0, 0.6, 1\r\n	] );\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n	THREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://exocortex.com\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n	var lineGeometry = new THREE.Geometry();\r\n	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );\r\n\r\n	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );\r\n	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n\r\n	return function ( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n		// dir is assumed to be normalized\r\n\r\n		THREE.Object3D.call( this );\r\n\r\n		if ( color === undefined ) color = 0xffff00;\r\n		if ( length === undefined ) length = 1;\r\n		if ( headLength === undefined ) headLength = 0.2 * length;\r\n		if ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n		this.position.copy( origin );\r\n\r\n		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n		this.line.matrixAutoUpdate = false;\r\n		this.add( this.line );\r\n\r\n		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n		this.cone.matrixAutoUpdate = false;\r\n		this.add( this.cone );\r\n\r\n		this.setDirection( dir );\r\n		this.setLength( length, headLength, headWidth );\r\n\r\n	}\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n	var axis = new THREE.Vector3();\r\n	var radians;\r\n\r\n	return function ( dir ) {\r\n\r\n		// dir is assumed to be normalized\r\n\r\n		if ( dir.y > 0.99999 ) {\r\n\r\n			this.quaternion.set( 0, 0, 0, 1 );\r\n\r\n		} else if ( dir.y < - 0.99999 ) {\r\n\r\n			this.quaternion.set( 1, 0, 0, 0 );\r\n\r\n		} else {\r\n\r\n			axis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n			radians = Math.acos( dir.y );\r\n\r\n			this.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n		}\r\n\r\n	};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n	if ( headLength === undefined ) headLength = 0.2 * length;\r\n	if ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n	this.line.scale.set( 1, length - headLength, 1 );\r\n	this.line.updateMatrix();\r\n\r\n	this.cone.scale.set( headWidth, headLength, headWidth );\r\n	this.cone.position.y = length;\r\n	this.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n	this.line.material.color.set( color );\r\n	this.cone.material.color.set( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n	var geometry = new THREE.BufferGeometry();\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );\r\n\r\n	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );\r\n\r\n	if ( object !== undefined ) {\r\n\r\n		this.update( object );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = function ( object ) {\r\n\r\n	var geometry = object.geometry;\r\n\r\n	if ( geometry.boundingBox === null ) {\r\n\r\n		geometry.computeBoundingBox();\r\n\r\n	}\r\n\r\n	var min = geometry.boundingBox.min;\r\n	var max = geometry.boundingBox.max;\r\n\r\n	/*\r\n	  5____4\r\n	1/___0/|\r\n	| 6__|_7\r\n	2/___3/\r\n\r\n	0: max.x, max.y, max.z\r\n	1: min.x, max.y, max.z\r\n	2: min.x, min.y, max.z\r\n	3: max.x, min.y, max.z\r\n	4: max.x, max.y, min.z\r\n	5: min.x, max.y, min.z\r\n	6: min.x, min.y, min.z\r\n	7: max.x, min.y, min.z\r\n	*/\r\n\r\n	var vertices = this.geometry.attributes.position.array;\r\n\r\n	vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;\r\n	vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;\r\n\r\n	vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;\r\n	vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;\r\n\r\n	vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;\r\n	vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;\r\n\r\n	vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;\r\n	vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;\r\n\r\n	//\r\n\r\n	vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;\r\n	vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;\r\n\r\n	vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;\r\n	vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;\r\n\r\n	vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;\r\n	vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;\r\n\r\n	vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;\r\n	vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;\r\n\r\n	//\r\n\r\n	vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;\r\n	vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;\r\n\r\n	vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;\r\n	vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;\r\n\r\n	vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;\r\n	vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;\r\n\r\n	vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;\r\n	vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;\r\n\r\n	this.geometry.attributes.position.needsUpdate = true;\r\n\r\n	this.geometry.computeBoundingSphere();\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n	this.object = object;\r\n\r\n	this.box = new THREE.Box3();\r\n\r\n	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n	this.box.setFromObject( this.object );\r\n\r\n	this.box.size( this.scale );\r\n\r\n	this.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *	- shows frustum, line of sight and up of the camera\r\n *	- suitable for fast updates\r\n * 	- based on frustum visualization in lightgl.js shadowmap example\r\n *		http://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n	var pointMap = {};\r\n\r\n	// colors\r\n\r\n	var hexFrustum = 0xffaa00;\r\n	var hexCone = 0xff0000;\r\n	var hexUp = 0x00aaff;\r\n	var hexTarget = 0xffffff;\r\n	var hexCross = 0x333333;\r\n\r\n	// near\r\n\r\n	addLine( \"n1\", \"n2\", hexFrustum );\r\n	addLine( \"n2\", \"n4\", hexFrustum );\r\n	addLine( \"n4\", \"n3\", hexFrustum );\r\n	addLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n	// far\r\n\r\n	addLine( \"f1\", \"f2\", hexFrustum );\r\n	addLine( \"f2\", \"f4\", hexFrustum );\r\n	addLine( \"f4\", \"f3\", hexFrustum );\r\n	addLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n	// sides\r\n\r\n	addLine( \"n1\", \"f1\", hexFrustum );\r\n	addLine( \"n2\", \"f2\", hexFrustum );\r\n	addLine( \"n3\", \"f3\", hexFrustum );\r\n	addLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n	// cone\r\n\r\n	addLine( \"p\", \"n1\", hexCone );\r\n	addLine( \"p\", \"n2\", hexCone );\r\n	addLine( \"p\", \"n3\", hexCone );\r\n	addLine( \"p\", \"n4\", hexCone );\r\n\r\n	// up\r\n\r\n	addLine( \"u1\", \"u2\", hexUp );\r\n	addLine( \"u2\", \"u3\", hexUp );\r\n	addLine( \"u3\", \"u1\", hexUp );\r\n\r\n	// target\r\n\r\n	addLine( \"c\", \"t\", hexTarget );\r\n	addLine( \"p\", \"c\", hexCross );\r\n\r\n	// cross\r\n\r\n	addLine( \"cn1\", \"cn2\", hexCross );\r\n	addLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n	addLine( \"cf1\", \"cf2\", hexCross );\r\n	addLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n	function addLine( a, b, hex ) {\r\n\r\n		addPoint( a, hex );\r\n		addPoint( b, hex );\r\n\r\n	}\r\n\r\n	function addPoint( id, hex ) {\r\n\r\n		geometry.vertices.push( new THREE.Vector3() );\r\n		geometry.colors.push( new THREE.Color( hex ) );\r\n\r\n		if ( pointMap[ id ] === undefined ) {\r\n\r\n			pointMap[ id ] = [];\r\n\r\n		}\r\n\r\n		pointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n	}\r\n\r\n	THREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n	this.camera = camera;\r\n	this.matrix = camera.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.pointMap = pointMap;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n	var geometry, pointMap;\r\n	\r\n	var vector = new THREE.Vector3();\r\n	var camera = new THREE.Camera();\r\n\r\n	var setPoint = function ( point, x, y, z ) {\r\n\r\n		vector.set( x, y, z ).unproject( camera );\r\n\r\n		var points = pointMap[ point ];\r\n\r\n		if ( points !== undefined ) {\r\n\r\n			for ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n				geometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n			}\r\n\r\n		}\r\n\r\n	};\r\n\r\n	return function () {\r\n\r\n		geometry = this.geometry;\r\n		pointMap = this.pointMap;\r\n\r\n		var w = 1, h = 1;\r\n\r\n		// we need just camera projection matrix\r\n		// world matrix must be identity\r\n\r\n		camera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n		// center / target\r\n\r\n		setPoint( \"c\", 0, 0, - 1 );\r\n		setPoint( \"t\", 0, 0,  1 );\r\n\r\n		// near\r\n\r\n		setPoint( \"n1\", - w, - h, - 1 );\r\n		setPoint( \"n2\",   w, - h, - 1 );\r\n		setPoint( \"n3\", - w,   h, - 1 );\r\n		setPoint( \"n4\",   w,   h, - 1 );\r\n\r\n		// far\r\n\r\n		setPoint( \"f1\", - w, - h, 1 );\r\n		setPoint( \"f2\",   w, - h, 1 );\r\n		setPoint( \"f3\", - w,   h, 1 );\r\n		setPoint( \"f4\",   w,   h, 1 );\r\n\r\n		// up\r\n\r\n		setPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n		setPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n		setPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n		// cross\r\n\r\n		setPoint( \"cf1\", - w,   0, 1 );\r\n		setPoint( \"cf2\",   w,   0, 1 );\r\n		setPoint( \"cf3\",   0, - h, 1 );\r\n		setPoint( \"cf4\",   0,   h, 1 );\r\n\r\n		setPoint( \"cn1\", - w,   0, - 1 );\r\n		setPoint( \"cn2\",   w,   0, - 1 );\r\n		setPoint( \"cn3\",   0, - h, - 1 );\r\n		setPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n		geometry.verticesNeedUpdate = true;\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	size = size || 1;\r\n\r\n	var geometry = new THREE.Geometry();\r\n	geometry.vertices.push(\r\n		new THREE.Vector3( - size,   size, 0 ),\r\n		new THREE.Vector3(   size,   size, 0 ),\r\n		new THREE.Vector3(   size, - size, 0 ),\r\n		new THREE.Vector3( - size, - size, 0 ),\r\n		new THREE.Vector3( - size,   size, 0 )\r\n	);\r\n\r\n	var material = new THREE.LineBasicMaterial( { fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	this.lightPlane = new THREE.Line( geometry, material );\r\n	this.add( this.lightPlane );\r\n\r\n	geometry = new THREE.Geometry();\r\n	geometry.vertices.push(\r\n		new THREE.Vector3(),\r\n		new THREE.Vector3()\r\n	);\r\n\r\n	material = new THREE.LineBasicMaterial( { fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	this.targetLine = new THREE.Line( geometry, material );\r\n	this.add( this.targetLine );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n	this.lightPlane.geometry.dispose();\r\n	this.lightPlane.material.dispose();\r\n	this.targetLine.geometry.dispose();\r\n	this.targetLine.material.dispose();\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n	var v1 = new THREE.Vector3();\r\n	var v2 = new THREE.Vector3();\r\n	var v3 = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		v1.setFromMatrixPosition( this.light.matrixWorld );\r\n		v2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n		v3.subVectors( v2, v1 );\r\n\r\n		this.lightPlane.lookAt( v3 );\r\n		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n		this.targetLine.geometry.vertices[ 1 ].copy( v3 );\r\n		this.targetLine.geometry.verticesNeedUpdate = true;\r\n		this.targetLine.material.color.copy( this.lightPlane.material.color );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n	var edge = [ 0, 0 ], hash = {};\r\n	var sortFunction = function ( a, b ) { return a - b };\r\n\r\n	var keys = [ 'a', 'b', 'c' ];\r\n	var geometry = new THREE.BufferGeometry();\r\n\r\n	var geometry2 = object.geometry.clone();\r\n\r\n	geometry2.mergeVertices();\r\n	geometry2.computeFaceNormals();\r\n\r\n	var vertices = geometry2.vertices;\r\n	var faces = geometry2.faces;\r\n	var numEdges = 0;\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		var face = faces[ i ];\r\n\r\n		for ( var j = 0; j < 3; j ++ ) {\r\n\r\n			edge[ 0 ] = face[ keys[ j ] ];\r\n			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n			edge.sort( sortFunction );\r\n\r\n			var key = edge.toString();\r\n\r\n			if ( hash[ key ] === undefined ) {\r\n\r\n				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n				numEdges ++;\r\n\r\n			} else {\r\n\r\n				hash[ key ].face2 = i;\r\n\r\n			}\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n	var index = 0;\r\n\r\n	for ( var key in hash ) {\r\n\r\n		var h = hash[ key ];\r\n\r\n		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK\r\n\r\n			var vertex = vertices[ h.vert1 ];\r\n			coords[ index ++ ] = vertex.x;\r\n			coords[ index ++ ] = vertex.y;\r\n			coords[ index ++ ] = vertex.z;\r\n\r\n			vertex = vertices[ h.vert2 ];\r\n			coords[ index ++ ] = vertex.x;\r\n			coords[ index ++ ] = vertex.y;\r\n			coords[ index ++ ] = vertex.z;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n	this.object = object;\r\n\r\n	this.size = ( size !== undefined ) ? size : 1;\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n	var width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	var faces = this.object.geometry.faces;\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\r\n	}\r\n\r\n	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.normalMatrix = new THREE.Matrix3();\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = function () {\r\n\r\n	var vertices = this.geometry.vertices;\r\n\r\n	var object = this.object;\r\n	var objectVertices = object.geometry.vertices;\r\n	var objectFaces = object.geometry.faces;\r\n	var objectWorldMatrix = object.matrixWorld;\r\n\r\n	object.updateMatrixWorld( true );\r\n\r\n	this.normalMatrix.getNormalMatrix( objectWorldMatrix );\r\n\r\n	for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {\r\n\r\n		var face = objectFaces[ i ];\r\n\r\n		vertices[ i2 ].copy( objectVertices[ face.a ] )\r\n			.add( objectVertices[ face.b ] )\r\n			.add( objectVertices[ face.c ] )\r\n			.divideScalar( 3 )\r\n			.applyMatrix4( objectWorldMatrix );\r\n\r\n		vertices[ i2 + 1 ].copy( face.normal )\r\n			.applyMatrix3( this.normalMatrix )\r\n			.normalize()\r\n			.multiplyScalar( this.size )\r\n			.add( vertices[ i2 ] );\r\n\r\n	}\r\n\r\n	this.geometry.verticesNeedUpdate = true;\r\n\r\n	return this;\r\n\r\n};\r\n\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step ) {\r\n\r\n	var geometry = new THREE.Geometry();\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n	this.color1 = new THREE.Color( 0x444444 );\r\n	this.color2 = new THREE.Color( 0x888888 );\r\n\r\n	for ( var i = - size; i <= size; i += step ) {\r\n\r\n		geometry.vertices.push(\r\n			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),\r\n			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )\r\n		);\r\n\r\n		var color = i === 0 ? this.color1 : this.color2;\r\n\r\n		geometry.colors.push( color, color, color, color );\r\n\r\n	}\r\n\r\n	THREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {\r\n\r\n	this.color1.set( colorCenterLine );\r\n	this.color2.set( colorGrid );\r\n\r\n	this.geometry.colorsNeedUpdate = true;\r\n\r\n}\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n	for ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n	}\r\n\r\n	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n	this.lightSphere = new THREE.Mesh( geometry, material );\r\n	this.add( this.lightSphere );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n	this.lightSphere.geometry.dispose();\r\n	this.lightSphere.material.dispose();\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n	var vector = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n		this.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n	}\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.matrix = this.light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	/*\r\n	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n	var d = light.distance;\r\n\r\n	if ( d === 0.0 ) {\r\n\r\n		this.lightDistance.visible = false;\r\n\r\n	} else {\r\n\r\n		this.lightDistance.scale.set( d, d, d );\r\n\r\n	}\r\n\r\n	this.add( this.lightDistance );\r\n	*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n	this.geometry.dispose();\r\n	this.material.dispose();\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	/*\r\n	var d = this.light.distance;\r\n\r\n	if ( d === 0.0 ) {\r\n\r\n		this.lightDistance.visible = false;\r\n\r\n	} else {\r\n\r\n		this.lightDistance.visible = true;\r\n		this.lightDistance.scale.set( d, d, d );\r\n\r\n	}\r\n	*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n	this.bones = this.getBoneList( object );\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	for ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n		var bone = this.bones[ i ];\r\n\r\n		if ( bone.parent instanceof THREE.Bone ) {\r\n\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n	THREE.Line.call( this, geometry, material, THREE.LinePieces );\r\n\r\n	this.root = object;\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n	var boneList = [];\r\n\r\n	if ( object instanceof THREE.Bone ) {\r\n\r\n		boneList.push( object );\r\n\r\n	}\r\n\r\n	for ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n	}\r\n\r\n	return boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n	var geometry = this.geometry;\r\n\r\n	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n	var boneMatrix = new THREE.Matrix4();\r\n\r\n	var j = 0;\r\n\r\n	for ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n		var bone = this.bones[ i ];\r\n\r\n		if ( bone.parent instanceof THREE.Bone ) {\r\n\r\n			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n			j += 2;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	geometry.verticesNeedUpdate = true;\r\n\r\n	geometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.light = light;\r\n	this.light.updateMatrixWorld();\r\n\r\n	this.matrix = light.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );\r\n\r\n	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );\r\n	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );\r\n\r\n	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\r\n	this.cone = new THREE.Mesh( geometry, material );\r\n	this.add( this.cone );\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n	this.cone.geometry.dispose();\r\n	this.cone.material.dispose();\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n	var vector = new THREE.Vector3();\r\n	var vector2 = new THREE.Vector3();\r\n\r\n	return function () {\r\n\r\n		var coneLength = this.light.distance ? this.light.distance : 10000;\r\n		var coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n		this.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n		vector.setFromMatrixPosition( this.light.matrixWorld );\r\n		vector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n		this.cone.lookAt( vector2.sub( vector ) );\r\n\r\n		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n	};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n	this.object = object;\r\n\r\n	this.size = ( size !== undefined ) ? size : 1;\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n	var width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	var vertices = object.geometry.vertices;\r\n\r\n	var faces = object.geometry.faces;\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		var face = faces[ i ];\r\n\r\n		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n			geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.normalMatrix = new THREE.Matrix3();\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function ( object ) {\r\n\r\n	var v1 = new THREE.Vector3();\r\n\r\n	return function( object ) {\r\n\r\n		var keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n		this.object.updateMatrixWorld( true );\r\n\r\n		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n		var vertices = this.geometry.vertices;\r\n\r\n		var verts = this.object.geometry.vertices;\r\n\r\n		var faces = this.object.geometry.faces;\r\n\r\n		var worldMatrix = this.object.matrixWorld;\r\n\r\n		var idx = 0;\r\n\r\n		for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n				var vertexId = face[ keys[ j ] ];\r\n				var vertex = verts[ vertexId ];\r\n\r\n				var normal = face.vertexNormals[ j ];\r\n\r\n				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );\r\n\r\n				v1.add( vertices[ idx ] );\r\n				idx = idx + 1;\r\n\r\n				vertices[ idx ].copy( v1 );\r\n				idx = idx + 1;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.geometry.verticesNeedUpdate = true;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n}());\r\n\r\n// File:src/extras/helpers/VertexTangentsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n	this.object = object;\r\n\r\n	this.size = ( size !== undefined ) ? size : 1;\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0x0000ff;\r\n\r\n	var width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n	var geometry = new THREE.Geometry();\r\n\r\n	var vertices = object.geometry.vertices;\r\n\r\n	var faces = object.geometry.faces;\r\n\r\n	for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n		var face = faces[ i ];\r\n\r\n		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n			geometry.vertices.push( new THREE.Vector3() );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );\r\n\r\n	this.matrixAutoUpdate = false;\r\n\r\n	this.update();\r\n\r\n};\r\n\r\nTHREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;\r\n\r\nTHREE.VertexTangentsHelper.prototype.update = ( function ( object ) {\r\n\r\n	var v1 = new THREE.Vector3();\r\n\r\n	return function( object ) {\r\n\r\n		var keys = [ 'a', 'b', 'c', 'd' ];\r\n\r\n		this.object.updateMatrixWorld( true );\r\n\r\n		var vertices = this.geometry.vertices;\r\n\r\n		var verts = this.object.geometry.vertices;\r\n\r\n		var faces = this.object.geometry.faces;\r\n\r\n		var worldMatrix = this.object.matrixWorld;\r\n\r\n		var idx = 0;\r\n\r\n		for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {\r\n\r\n				var vertexId = face[ keys[ j ] ];\r\n				var vertex = verts[ vertexId ];\r\n\r\n				var tangent = face.vertexTangents[ j ];\r\n\r\n				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );\r\n\r\n				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );\r\n\r\n				v1.add( vertices[ idx ] );\r\n				idx = idx + 1;\r\n\r\n				vertices[ idx ].copy( v1 );\r\n				idx = idx + 1;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		this.geometry.verticesNeedUpdate = true;\r\n\r\n		return this;\r\n\r\n	}\r\n\r\n}());\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n	var color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n	var edge = [ 0, 0 ], hash = {};\r\n	var sortFunction = function ( a, b ) { return a - b };\r\n\r\n	var keys = [ 'a', 'b', 'c' ];\r\n	var geometry = new THREE.BufferGeometry();\r\n\r\n	if ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n		var vertices = object.geometry.vertices;\r\n		var faces = object.geometry.faces;\r\n		var numEdges = 0;\r\n\r\n		// allocate maximal size\r\n		var edges = new Uint32Array( 6 * faces.length );\r\n\r\n		for ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n			var face = faces[ i ];\r\n\r\n			for ( var j = 0; j < 3; j ++ ) {\r\n\r\n				edge[ 0 ] = face[ keys[ j ] ];\r\n				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n				edge.sort( sortFunction );\r\n\r\n				var key = edge.toString();\r\n\r\n				if ( hash[ key ] === undefined ) {\r\n\r\n					edges[ 2 * numEdges ] = edge[ 0 ];\r\n					edges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n					hash[ key ] = true;\r\n					numEdges ++;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		}\r\n\r\n		var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n		for ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n			for ( var j = 0; j < 2; j ++ ) {\r\n\r\n				var vertex = vertices[ edges [ 2 * i + j] ];\r\n\r\n				var index = 6 * i + 3 * j;\r\n				coords[ index + 0 ] = vertex.x;\r\n				coords[ index + 1 ] = vertex.y;\r\n				coords[ index + 2 ] = vertex.z;\r\n\r\n			}\r\n\r\n		}\r\n\r\n		geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n	} else if ( object.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n		if ( object.geometry.attributes.index !== undefined ) { // Indexed BufferGeometry\r\n\r\n			var vertices = object.geometry.attributes.position.array;\r\n			var indices = object.geometry.attributes.index.array;\r\n			var drawcalls = object.geometry.drawcalls;\r\n			var numEdges = 0;\r\n\r\n			if ( drawcalls.length === 0 ) {\r\n\r\n				drawcalls = [ { count : indices.length, index : 0, start : 0 } ];\r\n\r\n			}\r\n\r\n			// allocate maximal size\r\n			var edges = new Uint32Array( 2 * indices.length );\r\n\r\n			for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {\r\n\r\n				var start = drawcalls[ o ].start;\r\n				var count = drawcalls[ o ].count;\r\n				var index = drawcalls[ o ].index;\r\n\r\n				for ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n					for ( var j = 0; j < 3; j ++ ) {\r\n\r\n						edge[ 0 ] = index + indices[ i + j ];\r\n						edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];\r\n						edge.sort( sortFunction );\r\n\r\n						var key = edge.toString();\r\n\r\n						if ( hash[ key ] === undefined ) {\r\n\r\n							edges[ 2 * numEdges ] = edge[ 0 ];\r\n							edges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n							hash[ key ] = true;\r\n							numEdges ++;\r\n\r\n						}\r\n\r\n					}\r\n\r\n				}\r\n\r\n			}\r\n\r\n			var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n			for ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n				for ( var j = 0; j < 2; j ++ ) {\r\n\r\n					var index = 6 * i + 3 * j;\r\n					var index2 = 3 * edges[ 2 * i + j];\r\n					coords[ index + 0 ] = vertices[ index2 ];\r\n					coords[ index + 1 ] = vertices[ index2 + 1 ];\r\n					coords[ index + 2 ] = vertices[ index2 + 2 ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n		} else { // non-indexed BufferGeometry\r\n\r\n			var vertices = object.geometry.attributes.position.array;\r\n			var numEdges = vertices.length / 3;\r\n			var numTris = numEdges / 3;\r\n\r\n			var coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n			for ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n				for ( var j = 0; j < 3; j ++ ) {\r\n\r\n					var index = 18 * i + 6 * j;\r\n\r\n					var index1 = 9 * i + 3 * j;\r\n					coords[ index + 0 ] = vertices[ index1 ];\r\n					coords[ index + 1 ] = vertices[ index1 + 1 ];\r\n					coords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n					coords[ index + 3 ] = vertices[ index2 ];\r\n					coords[ index + 4 ] = vertices[ index2 + 1 ];\r\n					coords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n				}\r\n\r\n			}\r\n\r\n			geometry.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n		}\r\n\r\n	}\r\n\r\n	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );\r\n\r\n	this.matrix = object.matrixWorld;\r\n	this.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function () {\r\n\r\n	THREE.Object3D.call( this );\r\n\r\n	this.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n	THREE.Mesh.call( this, geometry, material );\r\n\r\n	this.animationsMap = {};\r\n	this.animationsList = [];\r\n\r\n	// prepare default animation\r\n	// (all frames played together in 1 second)\r\n\r\n	var numFrames = this.geometry.morphTargets.length;\r\n\r\n	var name = \"__default\";\r\n\r\n	var startFrame = 0;\r\n	var endFrame = numFrames - 1;\r\n\r\n	var fps = numFrames / 1;\r\n\r\n	this.createAnimation( name, startFrame, endFrame, fps );\r\n	this.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n	var animation = {\r\n\r\n		startFrame: start,\r\n		endFrame: end,\r\n\r\n		length: end - start + 1,\r\n\r\n		fps: fps,\r\n		duration: ( end - start ) / fps,\r\n\r\n		lastFrame: 0,\r\n		currentFrame: 0,\r\n\r\n		active: false,\r\n\r\n		time: 0,\r\n		direction: 1,\r\n		weight: 1,\r\n\r\n		directionBackwards: false,\r\n		mirroredLoop: false\r\n\r\n	};\r\n\r\n	this.animationsMap[ name ] = animation;\r\n	this.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n	var pattern = /([a-z]+)_?(\\d+)/;\r\n\r\n	var firstAnimation, frameRanges = {};\r\n\r\n	var geometry = this.geometry;\r\n\r\n	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n		var morph = geometry.morphTargets[ i ];\r\n		var chunks = morph.name.match( pattern );\r\n\r\n		if ( chunks && chunks.length > 1 ) {\r\n\r\n			var name = chunks[ 1 ];\r\n			var num = chunks[ 2 ];\r\n\r\n			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n			var range = frameRanges[ name ];\r\n\r\n			if ( i < range.start ) range.start = i;\r\n			if ( i > range.end ) range.end = i;\r\n\r\n			if ( ! firstAnimation ) firstAnimation = name;\r\n\r\n		}\r\n\r\n	}\r\n\r\n	for ( var name in frameRanges ) {\r\n\r\n		var range = frameRanges[ name ];\r\n		this.createAnimation( name, range.start, range.end, fps );\r\n\r\n	}\r\n\r\n	this.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.direction = 1;\r\n		animation.directionBackwards = false;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.direction = - 1;\r\n		animation.directionBackwards = true;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.fps = fps;\r\n		animation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.duration = duration;\r\n		animation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.weight = weight;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.time = time;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n	var time = 0;\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		time = animation.time;\r\n\r\n	}\r\n\r\n	return time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n	var duration = - 1;\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		duration = animation.duration;\r\n\r\n	}\r\n\r\n	return duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.time = 0;\r\n		animation.active = true;\r\n\r\n	} else {\r\n\r\n		console.warn( \"animation[\" + name + \"] undefined\" );\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n	var animation = this.animationsMap[ name ];\r\n\r\n	if ( animation ) {\r\n\r\n		animation.active = false;\r\n\r\n	}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n		var animation = this.animationsList[ i ];\r\n\r\n		if ( ! animation.active ) continue;\r\n\r\n		var frameTime = animation.duration / animation.length;\r\n\r\n		animation.time += animation.direction * delta;\r\n\r\n		if ( animation.mirroredLoop ) {\r\n\r\n			if ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n				animation.direction *= - 1;\r\n\r\n				if ( animation.time > animation.duration ) {\r\n\r\n					animation.time = animation.duration;\r\n					animation.directionBackwards = true;\r\n\r\n				}\r\n\r\n				if ( animation.time < 0 ) {\r\n\r\n					animation.time = 0;\r\n					animation.directionBackwards = false;\r\n\r\n				}\r\n\r\n			}\r\n\r\n		} else {\r\n\r\n			animation.time = animation.time % animation.duration;\r\n\r\n			if ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n		}\r\n\r\n		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n		var weight = animation.weight;\r\n\r\n		if ( keyframe !== animation.currentFrame ) {\r\n\r\n			this.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n			this.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n			animation.lastFrame = animation.currentFrame;\r\n			animation.currentFrame = keyframe;\r\n\r\n		}\r\n\r\n		var mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n		if ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n	}\r\n\r\n};\r\n\r\n\r\n// Export the THREE object for **Node.js**, with\r\n// backwards-compatibility for the old `require()` API. If we're in\r\n// the browser, add `_` as a global object via a string identifier,\r\n// for Closure Compiler \"advanced\" mode.\r\nif (true) {\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    exports = module.exports = THREE;\r\n  }\r\n  exports.THREE = THREE;\r\n} else {\r\n  this['THREE'] = THREE;\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/three.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/three/three.js?");

}]);